
AVRA   Ver. 1.4.2 ATmega328P_uOS.asm Sat Feb 21 14:55:01 2026


         ; "$Id: ATmega328P_uOS.asm,v 1.22 2026/02/21 13:46:51 administrateur Exp $"
         
         ; - Projet: ATmega328P_uOS
         ;
         ; - r1.1: Continuite du projet 'ATmega328P_uOS_P1'
         ;         => Production sur Ubuntu-LinuxShop a partir des outils de Ubuntu-Dell + Sources...
         
         ; 2024/06/10 - Change 'rjmp uos_main_program' to 'jmp  0x0000' into 'ATmega328P_uOS_P4.sub' file
         ; 2024/06/17 - Add define 'USE_TABLES_WORDS' pour passage des tables de 'callback' en 'jmp'
         ;              => Facilite le codage en Langage C des ces tables ;-)
         ; 2024/06/21 - Add 'callback_init' method
         ; 2024/06/21 - Suppression du code inutilise pour gagner de la place
         ; 2024/06/22 - Suppression de 'REG_PORTB_OUT' au profit de 'UOS_G_PORTB_IMAGE'
         ; 2024/06/21 - Suppressions de 'REG_FLAGS_0' au profit de 'REG_TEMP_R24'
         ;              et 'REG_FLAGS_1' au profit de 'REG_TEMP_R25'
         ; 2024/10/07 - Suppression de '_uos_valid_address_range_2_from' en doublon de 'uos_tim1_compa_isr_program'
         ;              => Empeche la simulation du fait de 'uos_tim1_compa_isr_program' non referencee ;-(
         ;            - Ajustement a 100 uS exactement (Prise en compte de la mS a l'It suivante ;-)
         ;              => Cf. 'ATmega328P_uOS_P4.sub'
         ; 2024/10/09 - Insertion d'un 'nop' entre les labels definis a la meme adresse
         ; 2024/10/20   => Retour en arriere (acceptation des labels definis a la meme adresse ;-)
         
         ; 2025/08/20   => Reprise du projet 'P6' avec les ajouts de 'P7' (commande <f, ...)
         ; 2025/09/25   => Passage a 19200 bauds pour une utilisation avec le projet
         ;                 '/home/administrateur/Documents/Technique/Projects/Dev/UNO/SerialMonitor'
         
         ; 2026/01    - Reprise du projet 'ATmega328P_monitor_P8A' + reorganisation
         ;            - Suppression de l'appel a 'uos_print_blocking_string'
         ;            - Accueil du test leds en fond de tache
         ;              => TODO: Programmation de la flash pertubee a cause de la relance du code
         ;                       entrainant des erreurs d'ecriture ;-((
         
          .include		"m328Pdef.inc"              ; Labels and identifiers for ATmega328p
         ;***** THIS IS A MACHINE GENERATED FILE - DO NOT EDIT ********************
         ;***** Created: 2011-02-09 12:03 ******* Source: ATmega328P.xml **********
         ;*************************************************************************
         ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
         ;* 
         ;* Number            : AVR000
         ;* File Name         : "m328Pdef.inc"
         ;* Title             : Register/Bit Definitions for the ATmega328P
         ;* Date              : 2011-02-09
         ;* Version           : 2.35
         ;* Support E-mail    : avr@atmel.com
         ;* Target MCU        : ATmega328P
         ;* 
         ;* DESCRIPTION
         ;* When including this file in the assembly program file, all I/O register 
         ;* names and I/O register bit names appearing in the data book can be used.
         ;* In addition, the six registers forming the three data pointers X, Y and 
         ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
         ;* SRAM is also defined 
         ;* 
         ;* The Register names are represented by their hexadecimal address.
         ;* 
         ;* The Register Bit names are represented by their bit number (0-7).
         ;* 
         ;* Please observe the difference in using the bit names with instructions
         ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
         ;* (skip if bit in register set/cleared). The following example illustrates
         ;* this:
         ;* 
         ;* in    r16,PORTB             ;read PORTB latch
         ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
         ;* out   PORTB,r16             ;output to PORTB
         ;* 
         ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
         ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
         ;* rjmp  TOV0_is_set           ;jump if set
         ;* ...                         ;otherwise do something else
         ;*************************************************************************
         
          #ifndef _M328PDEF_INC_
          #define _M328PDEF_INC_
         
         
          #pragma partinc 0
         
         ; ***** SPECIFY DEVICE ***************************************************
          .device ATmega328P
          #pragma AVRPART ADMIN PART_NAME ATmega328P
          .equ	SIGNATURE_000	= 0x1e
          .equ	SIGNATURE_001	= 0x95
          .equ	SIGNATURE_002	= 0x0f
         
          #pragma AVRPART CORE CORE_VERSION V2E
         
         
         ; ***** I/O REGISTER DEFINITIONS *****************************************
         ; NOTE:
         ; Definitions marked "MEMORY MAPPED"are extended I/O ports
         ; and cannot be used with IN/OUT instructions
          .equ	UDR0	= 0xc6	; MEMORY MAPPED
          .equ	UBRR0L	= 0xc4	; MEMORY MAPPED
          .equ	UBRR0H	= 0xc5	; MEMORY MAPPED
          .equ	UCSR0C	= 0xc2	; MEMORY MAPPED
          .equ	UCSR0B	= 0xc1	; MEMORY MAPPED
          .equ	UCSR0A	= 0xc0	; MEMORY MAPPED
          .equ	TWAMR	= 0xbd	; MEMORY MAPPED
          .equ	TWCR	= 0xbc	; MEMORY MAPPED
          .equ	TWDR	= 0xbb	; MEMORY MAPPED
          .equ	TWAR	= 0xba	; MEMORY MAPPED
          .equ	TWSR	= 0xb9	; MEMORY MAPPED
          .equ	TWBR	= 0xb8	; MEMORY MAPPED
          .equ	ASSR	= 0xb6	; MEMORY MAPPED
          .equ	OCR2B	= 0xb4	; MEMORY MAPPED
          .equ	OCR2A	= 0xb3	; MEMORY MAPPED
          .equ	TCNT2	= 0xb2	; MEMORY MAPPED
          .equ	TCCR2B	= 0xb1	; MEMORY MAPPED
          .equ	TCCR2A	= 0xb0	; MEMORY MAPPED
          .equ	OCR1BL	= 0x8a	; MEMORY MAPPED
          .equ	OCR1BH	= 0x8b	; MEMORY MAPPED
          .equ	OCR1AL	= 0x88	; MEMORY MAPPED
          .equ	OCR1AH	= 0x89	; MEMORY MAPPED
          .equ	ICR1L	= 0x86	; MEMORY MAPPED
          .equ	ICR1H	= 0x87	; MEMORY MAPPED
          .equ	TCNT1L	= 0x84	; MEMORY MAPPED
          .equ	TCNT1H	= 0x85	; MEMORY MAPPED
          .equ	TCCR1C	= 0x82	; MEMORY MAPPED
          .equ	TCCR1B	= 0x81	; MEMORY MAPPED
          .equ	TCCR1A	= 0x80	; MEMORY MAPPED
          .equ	DIDR1	= 0x7f	; MEMORY MAPPED
          .equ	DIDR0	= 0x7e	; MEMORY MAPPED
          .equ	ADMUX	= 0x7c	; MEMORY MAPPED
          .equ	ADCSRB	= 0x7b	; MEMORY MAPPED
          .equ	ADCSRA	= 0x7a	; MEMORY MAPPED
          .equ	ADCH	= 0x79	; MEMORY MAPPED
          .equ	ADCL	= 0x78	; MEMORY MAPPED
          .equ	TIMSK2	= 0x70	; MEMORY MAPPED
          .equ	TIMSK1	= 0x6f	; MEMORY MAPPED
          .equ	TIMSK0	= 0x6e	; MEMORY MAPPED
          .equ	PCMSK1	= 0x6c	; MEMORY MAPPED
          .equ	PCMSK2	= 0x6d	; MEMORY MAPPED
          .equ	PCMSK0	= 0x6b	; MEMORY MAPPED
          .equ	EICRA	= 0x69	; MEMORY MAPPED
          .equ	PCICR	= 0x68	; MEMORY MAPPED
          .equ	OSCCAL	= 0x66	; MEMORY MAPPED
          .equ	PRR	= 0x64	; MEMORY MAPPED
          .equ	CLKPR	= 0x61	; MEMORY MAPPED
          .equ	WDTCSR	= 0x60	; MEMORY MAPPED
          .equ	SREG	= 0x3f
          .equ	SPL	= 0x3d
          .equ	SPH	= 0x3e
          .equ	SPMCSR	= 0x37
          .equ	MCUCR	= 0x35
          .equ	MCUSR	= 0x34
          .equ	SMCR	= 0x33
          .equ	ACSR	= 0x30
          .equ	SPDR	= 0x2e
          .equ	SPSR	= 0x2d
          .equ	SPCR	= 0x2c
          .equ	GPIOR2	= 0x2b
          .equ	GPIOR1	= 0x2a
          .equ	OCR0B	= 0x28
          .equ	OCR0A	= 0x27
          .equ	TCNT0	= 0x26
          .equ	TCCR0B	= 0x25
          .equ	TCCR0A	= 0x24
          .equ	GTCCR	= 0x23
          .equ	EEARH	= 0x22
          .equ	EEARL	= 0x21
          .equ	EEDR	= 0x20
          .equ	EECR	= 0x1f
          .equ	GPIOR0	= 0x1e
          .equ	EIMSK	= 0x1d
          .equ	EIFR	= 0x1c
          .equ	PCIFR	= 0x1b
          .equ	TIFR2	= 0x17
          .equ	TIFR1	= 0x16
          .equ	TIFR0	= 0x15
          .equ	PORTD	= 0x0b
          .equ	DDRD	= 0x0a
          .equ	PIND	= 0x09
          .equ	PORTC	= 0x08
          .equ	DDRC	= 0x07
          .equ	PINC	= 0x06
          .equ	PORTB	= 0x05
          .equ	DDRB	= 0x04
          .equ	PINB	= 0x03
         
         
         ; ***** BIT DEFINITIONS **************************************************
         
         ; ***** USART0 ***********************
         ; UDR0 - USART I/O Data Register
          .equ	UDR0_0	= 0	; USART I/O Data Register bit 0
          .equ	UDR0_1	= 1	; USART I/O Data Register bit 1
          .equ	UDR0_2	= 2	; USART I/O Data Register bit 2
          .equ	UDR0_3	= 3	; USART I/O Data Register bit 3
          .equ	UDR0_4	= 4	; USART I/O Data Register bit 4
          .equ	UDR0_5	= 5	; USART I/O Data Register bit 5
          .equ	UDR0_6	= 6	; USART I/O Data Register bit 6
          .equ	UDR0_7	= 7	; USART I/O Data Register bit 7
         
         ; UCSR0A - USART Control and Status Register A
          .equ	MPCM0	= 0	; Multi-processor Communication Mode
          .equ	U2X0	= 1	; Double the USART transmission speed
          .equ	UPE0	= 2	; Parity Error
          .equ	DOR0	= 3	; Data overRun
          .equ	FE0	= 4	; Framing Error
          .equ	UDRE0	= 5	; USART Data Register Empty
          .equ	TXC0	= 6	; USART Transmitt Complete
          .equ	RXC0	= 7	; USART Receive Complete
         
         ; UCSR0B - USART Control and Status Register B
          .equ	TXB80	= 0	; Transmit Data Bit 8
          .equ	RXB80	= 1	; Receive Data Bit 8
          .equ	UCSZ02	= 2	; Character Size
          .equ	TXEN0	= 3	; Transmitter Enable
          .equ	RXEN0	= 4	; Receiver Enable
          .equ	UDRIE0	= 5	; USART Data register Empty Interrupt Enable
          .equ	TXCIE0	= 6	; TX Complete Interrupt Enable
          .equ	RXCIE0	= 7	; RX Complete Interrupt Enable
         
         ; UCSR0C - USART Control and Status Register C
          .equ	UCPOL0	= 0	; Clock Polarity
          .equ	UCSZ00	= 1	; Character Size
          .equ	UCPHA0	= UCSZ00	; For compatibility
          .equ	UCSZ01	= 2	; Character Size
          .equ	UDORD0	= UCSZ01	; For compatibility
          .equ	USBS0	= 3	; Stop Bit Select
          .equ	UPM00	= 4	; Parity Mode Bit 0
          .equ	UPM01	= 5	; Parity Mode Bit 1
          .equ	UMSEL00	= 6	; USART Mode Select
          .equ	UMSEL0	= UMSEL00	; For compatibility
          .equ	UMSEL01	= 7	; USART Mode Select
          .equ	UMSEL1	= UMSEL01	; For compatibility
         
         ; UBRR0H - USART Baud Rate Register High Byte
          .equ	UBRR8	= 0	; USART Baud Rate Register bit 8
          .equ	UBRR9	= 1	; USART Baud Rate Register bit 9
          .equ	UBRR10	= 2	; USART Baud Rate Register bit 10
          .equ	UBRR11	= 3	; USART Baud Rate Register bit 11
         
         ; UBRR0L - USART Baud Rate Register Low Byte
          .equ	_UBRR0	= 0	; USART Baud Rate Register bit 0
          .equ	_UBRR1	= 1	; USART Baud Rate Register bit 1
          .equ	UBRR2	= 2	; USART Baud Rate Register bit 2
          .equ	UBRR3	= 3	; USART Baud Rate Register bit 3
          .equ	UBRR4	= 4	; USART Baud Rate Register bit 4
          .equ	UBRR5	= 5	; USART Baud Rate Register bit 5
          .equ	UBRR6	= 6	; USART Baud Rate Register bit 6
          .equ	UBRR7	= 7	; USART Baud Rate Register bit 7
         
         
         ; ***** TWI **************************
         ; TWAMR - TWI (Slave) Address Mask Register
          .equ	TWAM0	= 1	; 
          .equ	TWAMR0	= TWAM0	; For compatibility
          .equ	TWAM1	= 2	; 
          .equ	TWAMR1	= TWAM1	; For compatibility
          .equ	TWAM2	= 3	; 
          .equ	TWAMR2	= TWAM2	; For compatibility
          .equ	TWAM3	= 4	; 
          .equ	TWAMR3	= TWAM3	; For compatibility
          .equ	TWAM4	= 5	; 
          .equ	TWAMR4	= TWAM4	; For compatibility
          .equ	TWAM5	= 6	; 
          .equ	TWAMR5	= TWAM5	; For compatibility
          .equ	TWAM6	= 7	; 
          .equ	TWAMR6	= TWAM6	; For compatibility
         
         ; TWBR - TWI Bit Rate register
          .equ	TWBR0	= 0	; 
          .equ	TWBR1	= 1	; 
          .equ	TWBR2	= 2	; 
          .equ	TWBR3	= 3	; 
          .equ	TWBR4	= 4	; 
          .equ	TWBR5	= 5	; 
          .equ	TWBR6	= 6	; 
          .equ	TWBR7	= 7	; 
         
         ; TWCR - TWI Control Register
          .equ	TWIE	= 0	; TWI Interrupt Enable
          .equ	TWEN	= 2	; TWI Enable Bit
          .equ	TWWC	= 3	; TWI Write Collition Flag
          .equ	TWSTO	= 4	; TWI Stop Condition Bit
          .equ	TWSTA	= 5	; TWI Start Condition Bit
          .equ	TWEA	= 6	; TWI Enable Acknowledge Bit
          .equ	TWINT	= 7	; TWI Interrupt Flag
         
         ; TWSR - TWI Status Register
          .equ	TWPS0	= 0	; TWI Prescaler
          .equ	TWPS1	= 1	; TWI Prescaler
          .equ	TWS3	= 3	; TWI Status
          .equ	TWS4	= 4	; TWI Status
          .equ	TWS5	= 5	; TWI Status
          .equ	TWS6	= 6	; TWI Status
          .equ	TWS7	= 7	; TWI Status
         
         ; TWDR - TWI Data register
          .equ	TWD0	= 0	; TWI Data Register Bit 0
          .equ	TWD1	= 1	; TWI Data Register Bit 1
          .equ	TWD2	= 2	; TWI Data Register Bit 2
          .equ	TWD3	= 3	; TWI Data Register Bit 3
          .equ	TWD4	= 4	; TWI Data Register Bit 4
          .equ	TWD5	= 5	; TWI Data Register Bit 5
          .equ	TWD6	= 6	; TWI Data Register Bit 6
          .equ	TWD7	= 7	; TWI Data Register Bit 7
         
         ; TWAR - TWI (Slave) Address register
          .equ	TWGCE	= 0	; TWI General Call Recognition Enable Bit
          .equ	TWA0	= 1	; TWI (Slave) Address register Bit 0
          .equ	TWA1	= 2	; TWI (Slave) Address register Bit 1
          .equ	TWA2	= 3	; TWI (Slave) Address register Bit 2
          .equ	TWA3	= 4	; TWI (Slave) Address register Bit 3
          .equ	TWA4	= 5	; TWI (Slave) Address register Bit 4
          .equ	TWA5	= 6	; TWI (Slave) Address register Bit 5
          .equ	TWA6	= 7	; TWI (Slave) Address register Bit 6
         
         
         ; ***** TIMER_COUNTER_1 **************
         ; TIMSK1 - Timer/Counter Interrupt Mask Register
          .equ	TOIE1	= 0	; Timer/Counter1 Overflow Interrupt Enable
          .equ	OCIE1A	= 1	; Timer/Counter1 Output CompareA Match Interrupt Enable
          .equ	OCIE1B	= 2	; Timer/Counter1 Output CompareB Match Interrupt Enable
          .equ	ICIE1	= 5	; Timer/Counter1 Input Capture Interrupt Enable
         
         ; TIFR1 - Timer/Counter Interrupt Flag register
          .equ	TOV1	= 0	; Timer/Counter1 Overflow Flag
          .equ	OCF1A	= 1	; Output Compare Flag 1A
          .equ	OCF1B	= 2	; Output Compare Flag 1B
          .equ	ICF1	= 5	; Input Capture Flag 1
         
         ; TCCR1A - Timer/Counter1 Control Register A
          .equ	WGM10	= 0	; Waveform Generation Mode
          .equ	WGM11	= 1	; Waveform Generation Mode
          .equ	COM1B0	= 4	; Compare Output Mode 1B, bit 0
          .equ	COM1B1	= 5	; Compare Output Mode 1B, bit 1
          .equ	COM1A0	= 6	; Comparet Ouput Mode 1A, bit 0
          .equ	COM1A1	= 7	; Compare Output Mode 1A, bit 1
         
         ; TCCR1B - Timer/Counter1 Control Register B
          .equ	CS10	= 0	; Prescaler source of Timer/Counter 1
          .equ	CS11	= 1	; Prescaler source of Timer/Counter 1
          .equ	CS12	= 2	; Prescaler source of Timer/Counter 1
          .equ	WGM12	= 3	; Waveform Generation Mode
          .equ	WGM13	= 4	; Waveform Generation Mode
          .equ	ICES1	= 6	; Input Capture 1 Edge Select
          .equ	ICNC1	= 7	; Input Capture 1 Noise Canceler
         
         ; TCCR1C - Timer/Counter1 Control Register C
          .equ	FOC1B	= 6	; 
          .equ	FOC1A	= 7	; 
         
         ; GTCCR - General Timer/Counter Control Register
          .equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
          .equ	TSM	= 7	; Timer/Counter Synchronization Mode
         
         
         ; ***** TIMER_COUNTER_2 **************
         ; TIMSK2 - Timer/Counter Interrupt Mask register
          .equ	TOIE2	= 0	; Timer/Counter2 Overflow Interrupt Enable
          .equ	TOIE2A	= TOIE2	; For compatibility
          .equ	OCIE2A	= 1	; Timer/Counter2 Output Compare Match A Interrupt Enable
          .equ	OCIE2B	= 2	; Timer/Counter2 Output Compare Match B Interrupt Enable
         
         ; TIFR2 - Timer/Counter Interrupt Flag Register
          .equ	TOV2	= 0	; Timer/Counter2 Overflow Flag
          .equ	OCF2A	= 1	; Output Compare Flag 2A
          .equ	OCF2B	= 2	; Output Compare Flag 2B
         
         ; TCCR2A - Timer/Counter2 Control Register A
          .equ	WGM20	= 0	; Waveform Genration Mode
          .equ	WGM21	= 1	; Waveform Genration Mode
          .equ	COM2B0	= 4	; Compare Output Mode bit 0
          .equ	COM2B1	= 5	; Compare Output Mode bit 1
          .equ	COM2A0	= 6	; Compare Output Mode bit 1
          .equ	COM2A1	= 7	; Compare Output Mode bit 1
         
         ; TCCR2B - Timer/Counter2 Control Register B
          .equ	CS20	= 0	; Clock Select bit 0
          .equ	CS21	= 1	; Clock Select bit 1
          .equ	CS22	= 2	; Clock Select bit 2
          .equ	WGM22	= 3	; Waveform Generation Mode
          .equ	FOC2B	= 6	; Force Output Compare B
          .equ	FOC2A	= 7	; Force Output Compare A
         
         ; TCNT2 - Timer/Counter2
          .equ	TCNT2_0	= 0	; Timer/Counter 2 bit 0
          .equ	TCNT2_1	= 1	; Timer/Counter 2 bit 1
          .equ	TCNT2_2	= 2	; Timer/Counter 2 bit 2
          .equ	TCNT2_3	= 3	; Timer/Counter 2 bit 3
          .equ	TCNT2_4	= 4	; Timer/Counter 2 bit 4
          .equ	TCNT2_5	= 5	; Timer/Counter 2 bit 5
          .equ	TCNT2_6	= 6	; Timer/Counter 2 bit 6
          .equ	TCNT2_7	= 7	; Timer/Counter 2 bit 7
         
         ; OCR2A - Timer/Counter2 Output Compare Register A
          .equ	OCR2A_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
          .equ	OCR2A_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
          .equ	OCR2A_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
          .equ	OCR2A_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
          .equ	OCR2A_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
          .equ	OCR2A_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
          .equ	OCR2A_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
          .equ	OCR2A_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
         
         ; OCR2B - Timer/Counter2 Output Compare Register B
          .equ	OCR2B_0	= 0	; Timer/Counter2 Output Compare Register Bit 0
          .equ	OCR2B_1	= 1	; Timer/Counter2 Output Compare Register Bit 1
          .equ	OCR2B_2	= 2	; Timer/Counter2 Output Compare Register Bit 2
          .equ	OCR2B_3	= 3	; Timer/Counter2 Output Compare Register Bit 3
          .equ	OCR2B_4	= 4	; Timer/Counter2 Output Compare Register Bit 4
          .equ	OCR2B_5	= 5	; Timer/Counter2 Output Compare Register Bit 5
          .equ	OCR2B_6	= 6	; Timer/Counter2 Output Compare Register Bit 6
          .equ	OCR2B_7	= 7	; Timer/Counter2 Output Compare Register Bit 7
         
         ; ASSR - Asynchronous Status Register
          .equ	TCR2BUB	= 0	; Timer/Counter Control Register2 Update Busy
          .equ	TCR2AUB	= 1	; Timer/Counter Control Register2 Update Busy
          .equ	OCR2BUB	= 2	; Output Compare Register 2 Update Busy
          .equ	OCR2AUB	= 3	; Output Compare Register2 Update Busy
          .equ	TCN2UB	= 4	; Timer/Counter2 Update Busy
          .equ	AS2	= 5	; Asynchronous Timer/Counter2
          .equ	EXCLK	= 6	; Enable External Clock Input
         
         ; GTCCR - General Timer Counter Control register
          .equ	PSRASY	= 1	; Prescaler Reset Timer/Counter2
          .equ	PSR2	= PSRASY	; For compatibility
         ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
         
         
         ; ***** AD_CONVERTER *****************
         ; ADMUX - The ADC multiplexer Selection Register
          .equ	MUX0	= 0	; Analog Channel and Gain Selection Bits
          .equ	MUX1	= 1	; Analog Channel and Gain Selection Bits
          .equ	MUX2	= 2	; Analog Channel and Gain Selection Bits
          .equ	MUX3	= 3	; Analog Channel and Gain Selection Bits
          .equ	ADLAR	= 5	; Left Adjust Result
          .equ	REFS0	= 6	; Reference Selection Bit 0
          .equ	REFS1	= 7	; Reference Selection Bit 1
         
         ; ADCSRA - The ADC Control and Status register A
          .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
          .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
          .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
          .equ	ADIE	= 3	; ADC Interrupt Enable
          .equ	ADIF	= 4	; ADC Interrupt Flag
          .equ	ADATE	= 5	; ADC  Auto Trigger Enable
          .equ	ADSC	= 6	; ADC Start Conversion
          .equ	ADEN	= 7	; ADC Enable
         
         ; ADCSRB - The ADC Control and Status register B
          .equ	ADTS0	= 0	; ADC Auto Trigger Source bit 0
          .equ	ADTS1	= 1	; ADC Auto Trigger Source bit 1
          .equ	ADTS2	= 2	; ADC Auto Trigger Source bit 2
          .equ	ACME	= 6	; 
         
         ; ADCH - ADC Data Register High Byte
          .equ	ADCH0	= 0	; ADC Data Register High Byte Bit 0
          .equ	ADCH1	= 1	; ADC Data Register High Byte Bit 1
          .equ	ADCH2	= 2	; ADC Data Register High Byte Bit 2
          .equ	ADCH3	= 3	; ADC Data Register High Byte Bit 3
          .equ	ADCH4	= 4	; ADC Data Register High Byte Bit 4
          .equ	ADCH5	= 5	; ADC Data Register High Byte Bit 5
          .equ	ADCH6	= 6	; ADC Data Register High Byte Bit 6
          .equ	ADCH7	= 7	; ADC Data Register High Byte Bit 7
         
         ; ADCL - ADC Data Register Low Byte
          .equ	ADCL0	= 0	; ADC Data Register Low Byte Bit 0
          .equ	ADCL1	= 1	; ADC Data Register Low Byte Bit 1
          .equ	ADCL2	= 2	; ADC Data Register Low Byte Bit 2
          .equ	ADCL3	= 3	; ADC Data Register Low Byte Bit 3
          .equ	ADCL4	= 4	; ADC Data Register Low Byte Bit 4
          .equ	ADCL5	= 5	; ADC Data Register Low Byte Bit 5
          .equ	ADCL6	= 6	; ADC Data Register Low Byte Bit 6
          .equ	ADCL7	= 7	; ADC Data Register Low Byte Bit 7
         
         ; DIDR0 - Digital Input Disable Register
          .equ	ADC0D	= 0	; 
          .equ	ADC1D	= 1	; 
          .equ	ADC2D	= 2	; 
          .equ	ADC3D	= 3	; 
          .equ	ADC4D	= 4	; 
          .equ	ADC5D	= 5	; 
         
         
         ; ***** ANALOG_COMPARATOR ************
         ; ACSR - Analog Comparator Control And Status Register
          .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
          .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
          .equ	ACIC	= 2	; Analog Comparator Input Capture Enable
          .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
          .equ	ACI	= 4	; Analog Comparator Interrupt Flag
          .equ	ACO	= 5	; Analog Compare Output
          .equ	ACBG	= 6	; Analog Comparator Bandgap Select
          .equ	ACD	= 7	; Analog Comparator Disable
         
         ; DIDR1 - Digital Input Disable Register 1
          .equ	AIN0D	= 0	; AIN0 Digital Input Disable
          .equ	AIN1D	= 1	; AIN1 Digital Input Disable
         
         
         ; ***** PORTB ************************
         ; PORTB - Port B Data Register
          .equ	PORTB0	= 0	; Port B Data Register bit 0
          .equ	PB0	= 0	; For compatibility
          .equ	PORTB1	= 1	; Port B Data Register bit 1
          .equ	PB1	= 1	; For compatibility
          .equ	PORTB2	= 2	; Port B Data Register bit 2
          .equ	PB2	= 2	; For compatibility
          .equ	PORTB3	= 3	; Port B Data Register bit 3
          .equ	PB3	= 3	; For compatibility
          .equ	PORTB4	= 4	; Port B Data Register bit 4
          .equ	PB4	= 4	; For compatibility
          .equ	PORTB5	= 5	; Port B Data Register bit 5
          .equ	PB5	= 5	; For compatibility
          .equ	PORTB6	= 6	; Port B Data Register bit 6
          .equ	PB6	= 6	; For compatibility
          .equ	PORTB7	= 7	; Port B Data Register bit 7
          .equ	PB7	= 7	; For compatibility
         
         ; DDRB - Port B Data Direction Register
          .equ	DDB0	= 0	; Port B Data Direction Register bit 0
          .equ	DDB1	= 1	; Port B Data Direction Register bit 1
          .equ	DDB2	= 2	; Port B Data Direction Register bit 2
          .equ	DDB3	= 3	; Port B Data Direction Register bit 3
          .equ	DDB4	= 4	; Port B Data Direction Register bit 4
          .equ	DDB5	= 5	; Port B Data Direction Register bit 5
          .equ	DDB6	= 6	; Port B Data Direction Register bit 6
          .equ	DDB7	= 7	; Port B Data Direction Register bit 7
         
         ; PINB - Port B Input Pins
          .equ	PINB0	= 0	; Port B Input Pins bit 0
          .equ	PINB1	= 1	; Port B Input Pins bit 1
          .equ	PINB2	= 2	; Port B Input Pins bit 2
          .equ	PINB3	= 3	; Port B Input Pins bit 3
          .equ	PINB4	= 4	; Port B Input Pins bit 4
          .equ	PINB5	= 5	; Port B Input Pins bit 5
          .equ	PINB6	= 6	; Port B Input Pins bit 6
          .equ	PINB7	= 7	; Port B Input Pins bit 7
         
         
         ; ***** PORTC ************************
         ; PORTC - Port C Data Register
          .equ	PORTC0	= 0	; Port C Data Register bit 0
          .equ	PC0	= 0	; For compatibility
          .equ	PORTC1	= 1	; Port C Data Register bit 1
          .equ	PC1	= 1	; For compatibility
          .equ	PORTC2	= 2	; Port C Data Register bit 2
          .equ	PC2	= 2	; For compatibility
          .equ	PORTC3	= 3	; Port C Data Register bit 3
          .equ	PC3	= 3	; For compatibility
          .equ	PORTC4	= 4	; Port C Data Register bit 4
          .equ	PC4	= 4	; For compatibility
          .equ	PORTC5	= 5	; Port C Data Register bit 5
          .equ	PC5	= 5	; For compatibility
          .equ	PORTC6	= 6	; Port C Data Register bit 6
          .equ	PC6	= 6	; For compatibility
         
         ; DDRC - Port C Data Direction Register
          .equ	DDC0	= 0	; Port C Data Direction Register bit 0
          .equ	DDC1	= 1	; Port C Data Direction Register bit 1
          .equ	DDC2	= 2	; Port C Data Direction Register bit 2
          .equ	DDC3	= 3	; Port C Data Direction Register bit 3
          .equ	DDC4	= 4	; Port C Data Direction Register bit 4
          .equ	DDC5	= 5	; Port C Data Direction Register bit 5
          .equ	DDC6	= 6	; Port C Data Direction Register bit 6
         
         ; PINC - Port C Input Pins
          .equ	PINC0	= 0	; Port C Input Pins bit 0
          .equ	PINC1	= 1	; Port C Input Pins bit 1
          .equ	PINC2	= 2	; Port C Input Pins bit 2
          .equ	PINC3	= 3	; Port C Input Pins bit 3
          .equ	PINC4	= 4	; Port C Input Pins bit 4
          .equ	PINC5	= 5	; Port C Input Pins bit 5
          .equ	PINC6	= 6	; Port C Input Pins bit 6
         
         
         ; ***** PORTD ************************
         ; PORTD - Port D Data Register
          .equ	PORTD0	= 0	; Port D Data Register bit 0
          .equ	PD0	= 0	; For compatibility
          .equ	PORTD1	= 1	; Port D Data Register bit 1
          .equ	PD1	= 1	; For compatibility
          .equ	PORTD2	= 2	; Port D Data Register bit 2
          .equ	PD2	= 2	; For compatibility
          .equ	PORTD3	= 3	; Port D Data Register bit 3
          .equ	PD3	= 3	; For compatibility
          .equ	PORTD4	= 4	; Port D Data Register bit 4
          .equ	PD4	= 4	; For compatibility
          .equ	PORTD5	= 5	; Port D Data Register bit 5
          .equ	PD5	= 5	; For compatibility
          .equ	PORTD6	= 6	; Port D Data Register bit 6
          .equ	PD6	= 6	; For compatibility
          .equ	PORTD7	= 7	; Port D Data Register bit 7
          .equ	PD7	= 7	; For compatibility
         
         ; DDRD - Port D Data Direction Register
          .equ	DDD0	= 0	; Port D Data Direction Register bit 0
          .equ	DDD1	= 1	; Port D Data Direction Register bit 1
          .equ	DDD2	= 2	; Port D Data Direction Register bit 2
          .equ	DDD3	= 3	; Port D Data Direction Register bit 3
          .equ	DDD4	= 4	; Port D Data Direction Register bit 4
          .equ	DDD5	= 5	; Port D Data Direction Register bit 5
          .equ	DDD6	= 6	; Port D Data Direction Register bit 6
          .equ	DDD7	= 7	; Port D Data Direction Register bit 7
         
         ; PIND - Port D Input Pins
          .equ	PIND0	= 0	; Port D Input Pins bit 0
          .equ	PIND1	= 1	; Port D Input Pins bit 1
          .equ	PIND2	= 2	; Port D Input Pins bit 2
          .equ	PIND3	= 3	; Port D Input Pins bit 3
          .equ	PIND4	= 4	; Port D Input Pins bit 4
          .equ	PIND5	= 5	; Port D Input Pins bit 5
          .equ	PIND6	= 6	; Port D Input Pins bit 6
          .equ	PIND7	= 7	; Port D Input Pins bit 7
         
         
         ; ***** TIMER_COUNTER_0 **************
         ; TIMSK0 - Timer/Counter0 Interrupt Mask Register
          .equ	TOIE0	= 0	; Timer/Counter0 Overflow Interrupt Enable
          .equ	OCIE0A	= 1	; Timer/Counter0 Output Compare Match A Interrupt Enable
          .equ	OCIE0B	= 2	; Timer/Counter0 Output Compare Match B Interrupt Enable
         
         ; TIFR0 - Timer/Counter0 Interrupt Flag register
          .equ	TOV0	= 0	; Timer/Counter0 Overflow Flag
          .equ	OCF0A	= 1	; Timer/Counter0 Output Compare Flag 0A
          .equ	OCF0B	= 2	; Timer/Counter0 Output Compare Flag 0B
         
         ; TCCR0A - Timer/Counter  Control Register A
          .equ	WGM00	= 0	; Waveform Generation Mode
          .equ	WGM01	= 1	; Waveform Generation Mode
          .equ	COM0B0	= 4	; Compare Output Mode, Fast PWm
          .equ	COM0B1	= 5	; Compare Output Mode, Fast PWm
          .equ	COM0A0	= 6	; Compare Output Mode, Phase Correct PWM Mode
          .equ	COM0A1	= 7	; Compare Output Mode, Phase Correct PWM Mode
         
         ; TCCR0B - Timer/Counter Control Register B
          .equ	CS00	= 0	; Clock Select
          .equ	CS01	= 1	; Clock Select
          .equ	CS02	= 2	; Clock Select
          .equ	WGM02	= 3	; 
          .equ	FOC0B	= 6	; Force Output Compare B
          .equ	FOC0A	= 7	; Force Output Compare A
         
         ; TCNT0 - Timer/Counter0
          .equ	TCNT0_0	= 0	; 
          .equ	TCNT0_1	= 1	; 
          .equ	TCNT0_2	= 2	; 
          .equ	TCNT0_3	= 3	; 
          .equ	TCNT0_4	= 4	; 
          .equ	TCNT0_5	= 5	; 
          .equ	TCNT0_6	= 6	; 
          .equ	TCNT0_7	= 7	; 
         
         ; OCR0A - Timer/Counter0 Output Compare Register
          .equ	OCR0A_0	= 0	; 
          .equ	OCR0A_1	= 1	; 
          .equ	OCR0A_2	= 2	; 
          .equ	OCR0A_3	= 3	; 
          .equ	OCR0A_4	= 4	; 
          .equ	OCR0A_5	= 5	; 
          .equ	OCR0A_6	= 6	; 
          .equ	OCR0A_7	= 7	; 
         
         ; OCR0B - Timer/Counter0 Output Compare Register
          .equ	OCR0B_0	= 0	; 
          .equ	OCR0B_1	= 1	; 
          .equ	OCR0B_2	= 2	; 
          .equ	OCR0B_3	= 3	; 
          .equ	OCR0B_4	= 4	; 
          .equ	OCR0B_5	= 5	; 
          .equ	OCR0B_6	= 6	; 
          .equ	OCR0B_7	= 7	; 
         
         ; GTCCR - General Timer/Counter Control Register
         ;.equ	PSRSYNC	= 0	; Prescaler Reset Timer/Counter1 and Timer/Counter0
          .equ	PSR10	= PSRSYNC	; For compatibility
         ;.equ	TSM	= 7	; Timer/Counter Synchronization Mode
         
         
         ; ***** EXTERNAL_INTERRUPT ***********
         ; EICRA - External Interrupt Control Register
          .equ	ISC00	= 0	; External Interrupt Sense Control 0 Bit 0
          .equ	ISC01	= 1	; External Interrupt Sense Control 0 Bit 1
          .equ	ISC10	= 2	; External Interrupt Sense Control 1 Bit 0
          .equ	ISC11	= 3	; External Interrupt Sense Control 1 Bit 1
         
         ; EIMSK - External Interrupt Mask Register
          .equ	INT0	= 0	; External Interrupt Request 0 Enable
          .equ	INT1	= 1	; External Interrupt Request 1 Enable
         
         ; EIFR - External Interrupt Flag Register
          .equ	INTF0	= 0	; External Interrupt Flag 0
          .equ	INTF1	= 1	; External Interrupt Flag 1
         
         ; PCICR - Pin Change Interrupt Control Register
          .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
          .equ	PCIE1	= 1	; Pin Change Interrupt Enable 1
          .equ	PCIE2	= 2	; Pin Change Interrupt Enable 2
         
         ; PCMSK2 - Pin Change Mask Register 2
          .equ	PCINT16	= 0	; Pin Change Enable Mask 16
          .equ	PCINT17	= 1	; Pin Change Enable Mask 17
          .equ	PCINT18	= 2	; Pin Change Enable Mask 18
          .equ	PCINT19	= 3	; Pin Change Enable Mask 19
          .equ	PCINT20	= 4	; Pin Change Enable Mask 20
          .equ	PCINT21	= 5	; Pin Change Enable Mask 21
          .equ	PCINT22	= 6	; Pin Change Enable Mask 22
          .equ	PCINT23	= 7	; Pin Change Enable Mask 23
         
         ; PCMSK1 - Pin Change Mask Register 1
          .equ	PCINT8	= 0	; Pin Change Enable Mask 8
          .equ	PCINT9	= 1	; Pin Change Enable Mask 9
          .equ	PCINT10	= 2	; Pin Change Enable Mask 10
          .equ	PCINT11	= 3	; Pin Change Enable Mask 11
          .equ	PCINT12	= 4	; Pin Change Enable Mask 12
          .equ	PCINT13	= 5	; Pin Change Enable Mask 13
          .equ	PCINT14	= 6	; Pin Change Enable Mask 14
         
         ; PCMSK0 - Pin Change Mask Register 0
          .equ	PCINT0	= 0	; Pin Change Enable Mask 0
          .equ	PCINT1	= 1	; Pin Change Enable Mask 1
          .equ	PCINT2	= 2	; Pin Change Enable Mask 2
          .equ	PCINT3	= 3	; Pin Change Enable Mask 3
          .equ	PCINT4	= 4	; Pin Change Enable Mask 4
          .equ	PCINT5	= 5	; Pin Change Enable Mask 5
          .equ	PCINT6	= 6	; Pin Change Enable Mask 6
          .equ	PCINT7	= 7	; Pin Change Enable Mask 7
         
         ; PCIFR - Pin Change Interrupt Flag Register
          .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
          .equ	PCIF1	= 1	; Pin Change Interrupt Flag 1
          .equ	PCIF2	= 2	; Pin Change Interrupt Flag 2
         
         
         ; ***** SPI **************************
         ; SPDR - SPI Data Register
          .equ	SPDR0	= 0	; SPI Data Register bit 0
          .equ	SPDR1	= 1	; SPI Data Register bit 1
          .equ	SPDR2	= 2	; SPI Data Register bit 2
          .equ	SPDR3	= 3	; SPI Data Register bit 3
          .equ	SPDR4	= 4	; SPI Data Register bit 4
          .equ	SPDR5	= 5	; SPI Data Register bit 5
          .equ	SPDR6	= 6	; SPI Data Register bit 6
          .equ	SPDR7	= 7	; SPI Data Register bit 7
         
         ; SPSR - SPI Status Register
          .equ	SPI2X	= 0	; Double SPI Speed Bit
          .equ	WCOL	= 6	; Write Collision Flag
          .equ	SPIF	= 7	; SPI Interrupt Flag
         
         ; SPCR - SPI Control Register
          .equ	SPR0	= 0	; SPI Clock Rate Select 0
          .equ	SPR1	= 1	; SPI Clock Rate Select 1
          .equ	CPHA	= 2	; Clock Phase
          .equ	CPOL	= 3	; Clock polarity
          .equ	MSTR	= 4	; Master/Slave Select
          .equ	DORD	= 5	; Data Order
          .equ	SPE	= 6	; SPI Enable
          .equ	SPIE	= 7	; SPI Interrupt Enable
         
         
         ; ***** WATCHDOG *********************
         ; WDTCSR - Watchdog Timer Control Register
          .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
          .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
          .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
          .equ	WDE	= 3	; Watch Dog Enable
          .equ	WDCE	= 4	; Watchdog Change Enable
          .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
          .equ	WDIE	= 6	; Watchdog Timeout Interrupt Enable
          .equ	WDIF	= 7	; Watchdog Timeout Interrupt Flag
         
         
         ; ***** CPU **************************
         ; SREG - Status Register
          .equ	SREG_C	= 0	; Carry Flag
          .equ	SREG_Z	= 1	; Zero Flag
          .equ	SREG_N	= 2	; Negative Flag
          .equ	SREG_V	= 3	; Two's Complement Overflow Flag
          .equ	SREG_S	= 4	; Sign Bit
          .equ	SREG_H	= 5	; Half Carry Flag
          .equ	SREG_T	= 6	; Bit Copy Storage
          .equ	SREG_I	= 7	; Global Interrupt Enable
         
         ; OSCCAL - Oscillator Calibration Value
          .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
          .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
          .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
          .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
          .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
          .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
          .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
          .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
         
         ; CLKPR - Clock Prescale Register
          .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
          .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
          .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
          .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
          .equ	CLKPCE	= 7	; Clock Prescaler Change Enable
         
         ; SPMCSR - Store Program Memory Control and Status Register
          .equ	SELFPRGEN = 0	; Added for backwards compatibility
          .equ	SPMEN	= 0	; Store Program Memory
          .equ	PGERS	= 1	; Page Erase
          .equ	PGWRT	= 2	; Page Write
          .equ	BLBSET	= 3	; Boot Lock Bit Set
          .equ	RWWSRE	= 4	; Read-While-Write section read enable
          .equ	SIGRD	= 5	; Signature Row Read
          .equ	RWWSB	= 6	; Read-While-Write Section Busy
          .equ	SPMIE	= 7	; SPM Interrupt Enable
         
         ; MCUCR - MCU Control Register
          .equ	IVCE	= 0	; 
          .equ	IVSEL	= 1	; 
          .equ	PUD	= 4	; 
          .equ	BODSE	= 5	; BOD Sleep Enable
          .equ	BODS	= 6	; BOD Sleep
         
         ; MCUSR - MCU Status Register
          .equ	PORF	= 0	; Power-on reset flag
          .equ	EXTRF	= 1	; External Reset Flag
          .equ	EXTREF	= EXTRF	; For compatibility
          .equ	BORF	= 2	; Brown-out Reset Flag
          .equ	WDRF	= 3	; Watchdog Reset Flag
         
         ; SMCR - Sleep Mode Control Register
          .equ	SE	= 0	; Sleep Enable
          .equ	SM0	= 1	; Sleep Mode Select Bit 0
          .equ	SM1	= 2	; Sleep Mode Select Bit 1
          .equ	SM2	= 3	; Sleep Mode Select Bit 2
         
         ; GPIOR2 - General Purpose I/O Register 2
          .equ	GPIOR20	= 0	; 
          .equ	GPIOR21	= 1	; 
          .equ	GPIOR22	= 2	; 
          .equ	GPIOR23	= 3	; 
          .equ	GPIOR24	= 4	; 
          .equ	GPIOR25	= 5	; 
          .equ	GPIOR26	= 6	; 
          .equ	GPIOR27	= 7	; 
         
         ; GPIOR1 - General Purpose I/O Register 1
          .equ	GPIOR10	= 0	; 
          .equ	GPIOR11	= 1	; 
          .equ	GPIOR12	= 2	; 
          .equ	GPIOR13	= 3	; 
          .equ	GPIOR14	= 4	; 
          .equ	GPIOR15	= 5	; 
          .equ	GPIOR16	= 6	; 
          .equ	GPIOR17	= 7	; 
         
         ; GPIOR0 - General Purpose I/O Register 0
          .equ	GPIOR00	= 0	; 
          .equ	GPIOR01	= 1	; 
          .equ	GPIOR02	= 2	; 
          .equ	GPIOR03	= 3	; 
          .equ	GPIOR04	= 4	; 
          .equ	GPIOR05	= 5	; 
          .equ	GPIOR06	= 6	; 
          .equ	GPIOR07	= 7	; 
         
         ; PRR - Power Reduction Register
          .equ	PRADC	= 0	; Power Reduction ADC
          .equ	PRUSART0	= 1	; Power Reduction USART
          .equ	PRSPI	= 2	; Power Reduction Serial Peripheral Interface
          .equ	PRTIM1	= 3	; Power Reduction Timer/Counter1
          .equ	PRTIM0	= 5	; Power Reduction Timer/Counter0
          .equ	PRTIM2	= 6	; Power Reduction Timer/Counter2
          .equ	PRTWI	= 7	; Power Reduction TWI
         
         
         ; ***** EEPROM ***********************
         ; EEARL - EEPROM Address Register Low Byte
          .equ	EEAR0	= 0	; EEPROM Read/Write Access Bit 0
          .equ	EEAR1	= 1	; EEPROM Read/Write Access Bit 1
          .equ	EEAR2	= 2	; EEPROM Read/Write Access Bit 2
          .equ	EEAR3	= 3	; EEPROM Read/Write Access Bit 3
          .equ	EEAR4	= 4	; EEPROM Read/Write Access Bit 4
          .equ	EEAR5	= 5	; EEPROM Read/Write Access Bit 5
          .equ	EEAR6	= 6	; EEPROM Read/Write Access Bit 6
          .equ	EEAR7	= 7	; EEPROM Read/Write Access Bit 7
         
         ; EEARH - EEPROM Address Register High Byte
          .equ	EEAR8	= 0	; EEPROM Read/Write Access Bit 8
          .equ	EEAR9	= 1	; EEPROM Read/Write Access Bit 9
         
         ; EEDR - EEPROM Data Register
          .equ	EEDR0	= 0	; EEPROM Data Register bit 0
          .equ	EEDR1	= 1	; EEPROM Data Register bit 1
          .equ	EEDR2	= 2	; EEPROM Data Register bit 2
          .equ	EEDR3	= 3	; EEPROM Data Register bit 3
          .equ	EEDR4	= 4	; EEPROM Data Register bit 4
          .equ	EEDR5	= 5	; EEPROM Data Register bit 5
          .equ	EEDR6	= 6	; EEPROM Data Register bit 6
          .equ	EEDR7	= 7	; EEPROM Data Register bit 7
         
         ; EECR - EEPROM Control Register
          .equ	EERE	= 0	; EEPROM Read Enable
          .equ	EEPE	= 1	; EEPROM Write Enable
          .equ	EEMPE	= 2	; EEPROM Master Write Enable
          .equ	EERIE	= 3	; EEPROM Ready Interrupt Enable
          .equ	EEPM0	= 4	; EEPROM Programming Mode Bit 0
          .equ	EEPM1	= 5	; EEPROM Programming Mode Bit 1
         
         
         
         ; ***** LOCKSBITS ********************************************************
          .equ	LB1	= 0	; Lock bit
          .equ	LB2	= 1	; Lock bit
          .equ	BLB01	= 2	; Boot Lock bit
          .equ	BLB02	= 3	; Boot Lock bit
          .equ	BLB11	= 4	; Boot lock bit
          .equ	BLB12	= 5	; Boot lock bit
         
         
         ; ***** FUSES ************************************************************
         ; LOW fuse bits
          .equ	CKSEL0	= 0	; Select Clock Source
          .equ	CKSEL1	= 1	; Select Clock Source
          .equ	CKSEL2	= 2	; Select Clock Source
          .equ	CKSEL3	= 3	; Select Clock Source
          .equ	SUT0	= 4	; Select start-up time
          .equ	SUT1	= 5	; Select start-up time
          .equ	CKOUT	= 6	; Clock output
          .equ	CKDIV8	= 7	; Divide clock by 8
         
         ; HIGH fuse bits
          .equ	BOOTRST	= 0	; Select reset vector
          .equ	BOOTSZ0	= 1	; Select boot size
          .equ	BOOTSZ1	= 2	; Select boot size
          .equ	EESAVE	= 3	; EEPROM memory is preserved through chip erase
          .equ	WDTON	= 4	; Watchdog Timer Always On
          .equ	SPIEN	= 5	; Enable Serial programming and Data Downloading
          .equ	DWEN	= 6	; debugWIRE Enable
          .equ	RSTDISBL	= 7	; External reset disable
         
         ; EXTENDED fuse bits
          .equ	BODLEVEL0	= 0	; Brown-out Detector trigger level
          .equ	BODLEVEL1	= 1	; Brown-out Detector trigger level
          .equ	BODLEVEL2	= 2	; Brown-out Detector trigger level
         
         
         
         ; ***** CPU REGISTER DEFINITIONS *****************************************
          .def	XH	= r27
          .def	XL	= r26
          .def	YH	= r29
          .def	YL	= r28
          .def	ZH	= r31
          .def	ZL	= r30
         
         
         
         ; ***** DATA MEMORY DECLARATIONS *****************************************
          .equ	FLASHEND	= 0x3fff	; Note: Word address
          .equ	IOEND	= 0x00ff
          .equ	SRAM_START	= 0x0100
          .equ	SRAM_SIZE	= 2048
          .equ	RAMEND	= 0x08ff
          .equ	XRAMEND	= 0x0000
          .equ	E2END	= 0x03ff
          .equ	EEPROMEND	= 0x03ff
          .equ	EEADRBITS	= 10
          #pragma AVRPART MEMORY PROG_FLASH 32768
          #pragma AVRPART MEMORY EEPROM 1024
          #pragma AVRPART MEMORY INT_SRAM SIZE 2048
          #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x100
         
         
         
         ; ***** BOOTLOADER DECLARATIONS ******************************************
          .equ	NRWW_START_ADDR	= 0x3800
          .equ	NRWW_STOP_ADDR	= 0x3fff
          .equ	RWW_START_ADDR	= 0x0
          .equ	RWW_STOP_ADDR	= 0x37ff
          .equ	PAGESIZE	= 64
          .equ	FIRSTBOOTSTART	= 0x3f00
          .equ	SECONDBOOTSTART	= 0x3e00
          .equ	THIRDBOOTSTART	= 0x3c00
          .equ	FOURTHBOOTSTART	= 0x3800
          .equ	SMALLBOOTSTART	= FIRSTBOOTSTART
          .equ	LARGEBOOTSTART	= FOURTHBOOTSTART
         
         
         
         ; ***** INTERRUPT VECTORS ************************************************
          .equ	INT0addr	= 0x0002	; External Interrupt Request 0
          .equ	INT1addr	= 0x0004	; External Interrupt Request 1
          .equ	PCI0addr	= 0x0006	; Pin Change Interrupt Request 0
          .equ	PCI1addr	= 0x0008	; Pin Change Interrupt Request 0
          .equ	PCI2addr	= 0x000a	; Pin Change Interrupt Request 1
          .equ	WDTaddr	= 0x000c	; Watchdog Time-out Interrupt
          .equ	OC2Aaddr	= 0x000e	; Timer/Counter2 Compare Match A
          .equ	OC2Baddr	= 0x0010	; Timer/Counter2 Compare Match A
          .equ	OVF2addr	= 0x0012	; Timer/Counter2 Overflow
          .equ	ICP1addr	= 0x0014	; Timer/Counter1 Capture Event
          .equ	OC1Aaddr	= 0x0016	; Timer/Counter1 Compare Match A
          .equ	OC1Baddr	= 0x0018	; Timer/Counter1 Compare Match B
          .equ	OVF1addr	= 0x001a	; Timer/Counter1 Overflow
          .equ	OC0Aaddr	= 0x001c	; TimerCounter0 Compare Match A
          .equ	OC0Baddr	= 0x001e	; TimerCounter0 Compare Match B
          .equ	OVF0addr	= 0x0020	; Timer/Couner0 Overflow
          .equ	SPIaddr	= 0x0022	; SPI Serial Transfer Complete
          .equ	URXCaddr	= 0x0024	; USART Rx Complete
          .equ	UDREaddr	= 0x0026	; USART, Data Register Empty
          .equ	UTXCaddr	= 0x0028	; USART Tx Complete
          .equ	ADCCaddr	= 0x002a	; ADC Conversion Complete
          .equ	ERDYaddr	= 0x002c	; EEPROM Ready
          .equ	ACIaddr	= 0x002e	; Analog Comparator
          .equ	TWIaddr	= 0x0030	; Two-wire Serial Interface
          .equ	SPMRaddr	= 0x0032	; Store Program Memory Read
         
          .equ	INT_VECTORS_SIZE	= 52	; size in words
         
          #endif  /* _M328PDEF_INC_ */
         
         ; ***** END OF FILE ******************************************************
          ; ***** END OF FILE ******************************************************
          .include		"ATmega328P_uOS.h"
         ; "$Id: ATmega328P_uOS.h,v 1.17 2026/02/21 13:46:51 administrateur Exp $"
         
          #define	USE_END_ADDRESS		0		; Retour en 'forever_2' a la derniere adresse de la flash
          #define	USE_PRG_ALL_CODE		0		; Restriction du code pour un develeoppement progressif
         
          #define	USE_TRACE_BUTTON				0
          #define	USE_TRACE_BUTTON_ERROR		0
         
          #define	USE_COMMAND_B_MAJ				1
         
          #define	USE_MARK_IN_TIM1_COMPA		1
         
          #define	PAGESIZE_BYTES			(2 * PAGESIZE)
         
         ; Presentation de la Led GREEN @ emplacement des vecteurs d'interruption
          #define	CHENILLARD_PROGRAM		0x01	; 1 creneau de 125mS _/--\_______ toutes les 1 Sec (mode non connecte)
          #define	CHENILLARD_BOOTLOADER	0x55	; 1 creneau de 125mS _/--\_______ toutes les 250mS (mode non connecte)
          #define	CHENILLARD_UNKNOWN		0x0F	; 1 creneau de 500mS _/--\_______ toutes les 1 Sec (mode non connecte)
          #define	CHENILLARD_CONNECTED		0xFE	; 1 creneau de 125mS -\__/------- toutes les 1 Sec (mode connecte)
         
          #define	EEPROM_ADDR_VERSION		0
          #define	EEPROM_ADDR_TYPE			8
          #define	EEPROM_ADDR_ID				9
          #define	EEPROM_ADDR_BAUDS_IDX	10
          #define	EEPROM_ADDR_PRIMES		16		; Reserve @ gestion des capteurs DS18B20
         
          #define	CHAR_NULL				0x00		; '\0'
          #define	CHAR_TAB					0x09		; Tabulation ('\t')
          #define	CHAR_LF					0x0A		; Line Feed ('\n')
          #define	CHAR_CR					0x0D		; Carriage Return ('\r')
          #define	CHAR_SPACE				0x20		; Space (' ')
         
          #define	CHAR_SEPARATOR			0xFFFF	; Separateur section datas (0xffff opcode invalide ;-)
         
         ; Definition des masques de bits [0x00, 0x01, ..., 0xff] pour les opcodes suivants:
         ; - ori  -> Logical OR with Immediate
         ; - andi -> Logical AND with Immediate (Faire le complement a 1 ou (0xFF - MSK_BITX))
         ; - cbr  -> Clear Bits in Register (= andi avec constante complementee a (0xFF - K))
         ; - sbr  -> Set Bits in Register (= ori)
         ;
          #define	MSK_BIT7				(1 << 7)
          #define	MSK_BIT6				(1 << 6)
          #define	MSK_BIT5				(1 << 5)
          #define	MSK_BIT4				(1 << 4)
          #define	MSK_BIT3				(1 << 3)
          #define	MSK_BIT2				(1 << 2)
          #define	MSK_BIT1				(1 << 1)
          #define	MSK_BIT0				(1 << 0)
         
         ; Definition des index de bits [0, 1, ..., 7] pour les opcodes suivants:
         ; - bld       -> Bit Load from the T Flag in SREG to a Bit in Register
         ; - bst       -> Bit Store from Bit in Register to T Flag in SREG
         ; - cbi/sbi   -> Clear Bit in I/O Register / Set Bit in I/O Register
         ; - sbic/sbis -> Skip if Bit in I/O Register is Cleared / Skip if Bit in I/O Register is Set
         ; - sbrc/sbrs -> Skip if Bit in Register is Cleared / Skip if Bit in Register is Set
         ; - bclr/bset -> Bit Clear / Bit Set in SREG
         ; - brbc/brbs -> Branch if Bit in SREG is Cleared / Set
         ;
          #define	IDX_BIT7				7
          #define	IDX_BIT6				6
          #define	IDX_BIT5				5
          #define	IDX_BIT4				4
          #define	IDX_BIT3				3
          #define	IDX_BIT2				2
          #define	IDX_BIT1				1
          #define	IDX_BIT0				0
         
         ; Definitions @ l'espace d'execution (Bootloader eor Programme)
         ; Constat:
         ; - Si le fuse 'BOOTRST' est programme a 0 (Select reset vector)
         ;   => 'G_STATES_AT_RESET' est "vu" a 0x86
         ;      => Vecteur RESET dans l'espace BOOTLOADER
         ;      => Execution des autres vecteurs d'interruption dans l'espace PROGRAM
         ;         => Si sequence d'ecriture dans 'MCUCR' (bits 'IVCE' et 'IVSEL')
         ;            => 'G_STATES_AT_RESET' est "vu" a 0x60 apres raz de 'G_STATES_AT_RESET'
         ;               => Execution des autres vecteurs d'interruption dans l'espace PROGRAM
         ;
         ; - Si le fuse 'BOOTRST' est programme a 1 (unprogramming)
         ;   => 'G_STATES_AT_RESET' est "vu" a 0x0e
         ;      => Vecteur RESET dans l'espace PROGRAM
         ;      => Execution des autres vecteurs d'interruption dans l'espace PROGRAM
         ;
         ; Marquage de l'etat au reset @ BOOTRST
          #define	FLG_STATE_AT_RESET_BOOTLOADER_MSK					MSK_BIT7
          #define	FLG_STATE_AT_RESET_BOOTLOADER_IDX					IDX_BIT7
         
          #define	FLG_STATE_AT_RESET_PROGRAM_MSK						MSK_BIT3
          #define	FLG_STATE_AT_RESET_PROGRAM_IDX						IDX_BIT3
         
         ; Marquage de l'etat d'execution de l'It 'tim1_compa_isr'
          #define	FLG_STATE_AT_IT_TIM1_COMPA_BOOTLOADER_MSK			MSK_BIT6
          #define	FLG_STATE_AT_IT_TIM1_COMPA_BOOTLOADER_IDX			IDX_BIT6
         
          #define	FLG_STATE_AT_IT_TIM1_COMPA_PROGRAM_MSK				MSK_BIT2
          #define	FLG_STATE_AT_IT_TIM1_COMPA_PROGRAM_IDX				IDX_BIT2
         
         ; Marquage de l'etat d'execution de l'It 'usart_rx_complete_isr'
          #define	FLG_STATE_AT_IT_UART_COMPLETE_BOOTLOADER_MSK		MSK_BIT5
          #define	FLG_STATE_AT_IT_UART_COMPLETE_BOOTLOADER_IDX		IDX_BIT5
         
          #define	FLG_STATE_AT_IT_UART_COMPLETE_PROGRAM_MSK			MSK_BIT1
          #define	FLG_STATE_AT_IT_UART_COMPLETE_PROGRAM_IDX			IDX_BIT1
         
         ; Marquage de l'etat d'execution de l'It 'pcint2_isr'
          #define	FLG_STATE_AT_IT_PCINT2_BOOTLOADER_MSK				MSK_BIT4
          #define	FLG_STATE_AT_IT_PCINT2_BOOTLOADER_IDX				IDX_BIT4
         
          #define	FLG_STATE_AT_IT_PCINT2_PROGRAM_MSK					MSK_BIT0
          #define	FLG_STATE_AT_IT_PCINT2_PROGRAM_IDX					IDX_BIT0
         ; Fin: Definitions @ l'espace d'execution (Bootloader eor Programme)
         
         ; Flags generaux FLG_0 (masques et index)
          #define	FLG_0_PERIODE_1MS_MSK				MSK_BIT0
         
          #define	FLG_0_SPARE_1_MSK						MSK_BIT1
          #define	FLG_0_SPARE_2_MSK						MSK_BIT2
          #define	FLG_0_SPARE_3_MSK						MSK_BIT3
          #define	FLG_0_UART_TX_TO_SEND_MSK			MSK_BIT4		; Donnees Data/Tx a emettre
          #define	UOS_FLG_0_PRINT_SKIP_MSK			MSK_BIT5		; Saut des methodes 'print_xxx' si affirme
          #define	FLG_0_SPARE_6_MSK						MSK_BIT6
         
         ; Synthese du fusible 'LOW' (CKSEL3..0)
         ; - 1 pour CKSEL3..0 a 0010 (Oscillateur RC interne a 8 MHz)
         ; - 0 pour CKSEL3..0 programme differement (notamment oscillateur externe a 16 MHz)
          #define	FLG_0_RC_OSC_8MHZ_MSK					MSK_BIT7
         
          #define	FLG_0_PERIODE_1MS_IDX					IDX_BIT0
          #define	FLG_0_SPARE_1_IDX							IDX_BIT1
          #define	FLG_0_SPARE_2_IDX							IDX_BIT2
          #define	FLG_0_SPARE_3_IDX							IDX_BIT3
          #define	FLG_0_UART_TX_TO_SEND_IDX				IDX_BIT4		; Donnees Data/Tx a emettre
          #define	UOS_FLG_0_PRINT_SKIP_IDX				IDX_BIT5		; Saut des methodes 'print_xxx' si affirme
          #define	FLG_0_SPARE_6_IDX							IDX_BIT6
          #define	FLG_0_RC_OSC_8MHZ_IDX					IDX_BIT7
         
         ; Flags generaux FLG_1 (masques et index)
         ; Etats des FIFO/UART/Rx et Tx + Donnees Rx recues et Tx a emettre
          #define	FLG_1_UART_FIFO_RX_NOT_EMPTY_MSK		MSK_BIT0
          #define	FLG_1_UART_FIFO_RX_FULL_MSK			MSK_BIT1
          #define	FLG_1_UART_RX_RECEIVE_MSK				MSK_BIT2		; Donnees Data/Rx recues
          #define	FLG_1_SPARE_3_MSK							MSK_BIT3
          #define	FLG_1_UART_FIFO_TX_NOT_EMPTY_MSK		MSK_BIT4
          #define	FLG_1_UART_FIFO_TX_FULL_MSK			MSK_BIT5
          #define	FLG_1_UART_FIFO_TX_TO_SEND_MSK		MSK_BIT6
          #define	UOS_FLG_1_LED_RED_ON_MSK				MSK_BIT7
         
          #define	FLG_1_UART_FIFO_RX_NOT_EMPTY_IDX		IDX_BIT0
          #define	FLG_1_UART_FIFO_RX_FULL_IDX			IDX_BIT1
          #define	FLG_1_UART_RX_RECEIVE_IDX				IDX_BIT2		; Donnees Data/Rx recues
          #define	FLG_1_SPARE_3_IDX							IDX_BIT3	
          #define	FLG_1_UART_FIFO_TX_NOT_EMPTY_IDX		IDX_BIT4
          #define	FLG_1_UART_FIFO_TX_FULL_IDX			IDX_BIT5
          #define	FLG_1_UART_FIFO_TX_TO_SEND_IDX		IDX_BIT6
          #define	UOS_FLG_1_LED_RED_ON_IDX				IDX_BIT7
         
         ; Flags generaux G_FLAGS_2 (masques et index)
          #define	FLG_2_CONNECTED_MSK						MSK_BIT0		; Passage en mode connecte sur reception d'une donnee Rx
          #define	FLG_2_BLINKING_LED_RED_MSK				MSK_BIT1
          #define	FLG_2_BLINKING_LED_YELLOW_MSK			MSK_BIT2
          #define	FLG_2_SPARE_3_MSK							MSK_BIT3
          #define	FLG_2_SPARE_4_MSK							MSK_BIT4
          #define	FLG_2_SPARE_5_MSK							MSK_BIT5
          #define	FLG_2_SPARE_6_MSK							MSK_BIT6
          #define	UOS_FLG_2_ENABLE_DERIVATION_MSK		MSK_BIT7		; Autorisation d'ecriture dans le programme
         
          #define	FLG_2_CONNECTED_IDX						IDX_BIT0		; Passage en mode connecte sur reception d'une donnee Rx
          #define	FLG_2_BLINKING_LED_RED_IDX				IDX_BIT1
          #define	FLG_2_BLINKING_LED_YELLOW_IDX			IDX_BIT2
          #define	FLG_2_SPARE_3_IDX							IDX_BIT3
          #define	FLG_2_SPARE_4_IDX							IDX_BIT4
          #define	FLG_2_SPARE_5_IDX							IDX_BIT5
          #define	FLG_2_SPARE_6_IDX							IDX_BIT6
          #define	UOS_FLG_2_ENABLE_DERIVATION_IDX		IDX_BIT7		; Autorisation d'ecriture dans le programme
         
          .def		REG_SAVE_SREG		= r0		; Sauvegarde temporaire de SREG dans les methodes ISR
         
         ;.def		REG_R0				= r0		; Warning: Used by program C
         ;.def		REG_R1				= r1		; Warning: Used by program C
          .def		REG_R2				= r2
          .def		REG_R3				= r3
          .def		REG_R4				= r4
          .def		REG_R5				= r4
          .def		REG_R6				= r6
          .def		REG_R7				= r7
          .def		REG_R8				= r8
          .def		REG_R9				= r9
          .def		REG_R10				= r10
          .def		REG_R11				= r11
          .def		REG_R12				= r12
          .def		REG_R13				= r13
          .def		REG_R14				= r14
          .def		REG_R15				= r15
         
         ; Registres de travail temporaires (dedies et banalises)
          .def		REG_TEMP_R16		= r16
          .def		REG_TEMP_R17		= r17
          .def		REG_TEMP_R18		= r18
          .def		REG_TEMP_R19		= r19
          .def		REG_TEMP_R20		= r20
          .def		REG_TEMP_R21		= r21
          .def		REG_TEMP_R22		= r22
          .def		REG_TEMP_R23		= r23		; Registre de travail en remplacement de 'REG_PORTB_OUT', 'REG_FLAGS_0' et 'REG_FLAGS_1'
          .def		REG_TEMP_R24		= r24		; Warning: Used by program C
          .def		REG_TEMP_R25		= r25		; Warning: Used by program C
          .def		REG_X_LSB			= r26		; XL
          .def		REG_X_MSB			= r27		; XH
          .def		REG_Y_LSB			= r28		; YL
          .def		REG_Y_MSB			= r29		; YH
          .def		REG_Z_LSB			= r30		; ZL
          .def		REG_Z_MSB			= r31		; ZH
         
          .dseg
         
         ; Zones de travail en SRAM
         ; Debut de la partie [0x100...] de la SRAM (possibilite d'optimisation des indexations par X, Y et Z )
          #define	UOS_FLG_WRONG_IT_BOOLOADER_MSK		MSK_BIT7
          #define	UOS_FLG_WRONG_IT_PROGRAM_MSK			MSK_BIT6
         
         ; Variables dediees au BOOTLOADER
         ; ---------
         ; Reservation pour la section '.bss' des programmes C et C++ avec par exemple
         ; => Adresses SRAM [0x100...0x4FF] (4 * 256 bytes)
         ;    Cette zone de [0x100...0x4FF] n'est pas initialisee par l'uOS
         ;    => Permet de connaitre son contenu au moyen de 'ATmega328P_monitor' ;-)
D:000100    G_BSS_SPARE:					.byte		(4 * 256)	; 1st adresse de la SRAM + reservation de 4 * 256 = 1280 bytes
         
D:000500    G_STATES_AT_RESET:			.byte		1		; Etats au reset @ au fusible BOOTRST a l'adresse 0x600
D:000501    UOS_G_STATES_POST_MORTEM:	.byte		1		; Byte indiquant des etats pour l'analyse post mortem
         
D:000502    G_TICK_1MS:						.byte		1		; Compatbilisation des mS a partir du tick de 100uS
D:000503    G_TICK_1MS_INIT:				.byte		1
         
D:000504    G_COUNTER_1MS_MSB:			.byte		1		; Compatbilisation des mS a concurence de 1 Sec
D:000505    G_COUNTER_1MS_LSB:			.byte		1		; pour la synchronisation timer d'erreur
         
D:000506    G_COUNTER_CHENILLARD:		.byte		1		; Compteur de progression du chenillard
         
D:000507    G_CHENILLARD_MSB:				.byte		1		; Chenillard d'allumage/extinction Led GREEN
D:000508    G_CHENILLARD_LSB:				.byte		1		; au travers d'un mot de 16 bits (16 x 125mS = 2 Sec)
         
D:000509    G_NBR_VALUE_TRACE:			.byte		1
D:00050a    G_NBR_ERRORS:					.byte		1
         
D:00050b    UOS_G_HEADER_TYPE_PLATINE:		.byte		1	; Type de la platine lu de l'EEPROM
D:00050c    UOS_G_HEADER_INDEX_PLATINE:	.byte		1	; Index de la platine lu de l'EEPROM
D:00050d    UOS_G_HEADER_BAUDS_VALUE:		.byte		1	; Valeur de la vitesse lue de l'EEPROM [0, 1, ...]
         
         ; Erreur maj depuis l'exterieur de 'uOS' (ie. Language C)
          #define	FLG_TEST_ERR_EXTERNAL_MSK				MSK_BIT7
          #define	FLG_TEST_ERR_EXTERNAL_IDX				IDX_BIT7
         
D:00050e    G_TEST_ERROR:					.byte		1
         ; Fin: Definition des erreurs permanentes necessitant un effacement avec le Bouton #2 (appui "court")
         
         ; ---------
         ; Fin: Variables dediees au BOOTLOADER
         
D:00050f    UOS_G_PORTB_IMAGE:			.byte		1
         
D:000510    UOS_G_FLAGS_0:					.byte		1
D:000511    UOS_G_FLAGS_1:					.byte		1
D:000512    UOS_G_FLAGS_2:					.byte		1
         
          #define DURATION_TIMER_TEST_LEDS		500
         
          #define FLG_GESTION_TEST_LEDS_MSK	MSK_BIT7
          #define FLG_GESTION_TEST_LEDS_IDX	IDX_BIT7
         
D:000513    UOS_G_GESTION_TEST_LEDS:	.byte    1
         
         ; Variables dediees aux extensions (espace programme)
          #define	UOS_FLG_EXTENSIONS_INIT_MSK					MSK_BIT7		; Contexte initialise (Variable, traitements specifiques, ...)
          #define	UOS_FLG_EXTENSIONS_EXEC_BACKGROUND_MSK		MSK_BIT3		; Passage dans 'callback_background'
          #define	UOS_FLG_EXTENSIONS_EXEC_TICK_MSK				MSK_BIT2		; Passage dans 'callback_tick'
          #define	UOS_FLG_EXTENSIONS_EXEC_1_MS_MSK				MSK_BIT1		; Passage dans 'callback_1_ms'
          #define	UOS_FLG_EXTENSIONS_EXEC_COMMAND_MSK			MSK_BIT0		; Passage dans 'callback_command'
         
          #define	UOS_FLG_EXTENSIONS_INIT_IDX					IDX_BIT7		; Contexte initialise (Variable, traitements specifiques, ...)
          #define	UOS_FLG_EXTENSIONS_EXEC_BACKGROUND_IDX		IDX_BIT3		; Passage dans 'callback_background'
          #define	UOS_FLG_EXTENSIONS_EXEC_TICK_IDX				IDX_BIT2		; Passage dans 'callback_tick'
          #define	UOS_FLG_EXTENSIONS_EXEC_1_MS_IDX				IDX_BIT1		; Passage dans 'callback_1_ms'
          #define	UOS_FLG_EXTENSIONS_EXEC_COMMAND_IDX			IDX_BIT0		; Passage dans 'callback_command'
         
D:000514    UOS_G_SAVE_R0:								.byte		1
D:000515    UOS_G_SAVE_R1:								.byte		1
D:000516    UOS_G_SAVE_R2:								.byte		1
D:000517    UOS_G_SAVE_R3:								.byte		1
D:000518    UOS_G_SAVE_R4:								.byte		1
D:000519    UOS_G_SAVE_R5:								.byte		1
D:00051a    UOS_G_SAVE_R6:								.byte		1
D:00051b    UOS_G_SAVE_R7:								.byte		1
D:00051c    UOS_G_SAVE_R8:								.byte		1
D:00051d    UOS_G_SAVE_R9:								.byte		1
D:00051e    UOS_G_SAVE_R10:							.byte		1
D:00051f    UOS_G_SAVE_R11:							.byte		1
D:000520    UOS_G_SAVE_R12:							.byte		1
D:000521    UOS_G_SAVE_R13:							.byte		1
D:000522    UOS_G_SAVE_R14:							.byte		1
D:000523    UOS_G_SAVE_R15:							.byte		1
D:000524    UOS_G_SAVE_R16:							.byte		1
D:000525    UOS_G_SAVE_R17:							.byte		1
D:000526    UOS_G_SAVE_R18:							.byte		1
D:000527    UOS_G_SAVE_R19:							.byte		1
D:000528    UOS_G_SAVE_R20:							.byte		1
D:000529    UOS_G_SAVE_R21:							.byte		1
D:00052a    UOS_G_SAVE_R22:							.byte		1
D:00052b    UOS_G_SAVE_R23:							.byte		1
D:00052c    UOS_G_SAVE_R24:							.byte		1
D:00052d    UOS_G_SAVE_R25:							.byte		1
D:00052e    UOS_G_SAVE_R26:							.byte		1
D:00052f    UOS_G_SAVE_R27:							.byte		1
D:000530    UOS_G_SAVE_R28:							.byte		1
D:000531    UOS_G_SAVE_R29:							.byte		1
D:000532    UOS_G_SAVE_R30:							.byte		1
D:000533    UOS_G_SAVE_R31:							.byte		1
         
D:000534    UOS_G_FLAGS_EXTENSIONS:					.byte		1				; Progression de l'execution des extensions
         ; ---------
         
         ; Fin: Zones de travail en SRAM
         
         ; Definitions pour le pilotage avec ori/and/cbr/sbr
         ; - PORTB<0>: Non utilise (Reserve pour la sortie CLKOUT @ fusible 'LOW')
         ; - PORTB<1>: Led RED				0/1: Eteinte/Allumee
         ; - PORTB<2>: Led GREEN				0/1: Eteinte/Allumee
         ; - PORTB<3>: Pulse IT				0: IT in progress 1: IT not in progress
         ; - PORTB<4>: Led BUE				0/1: Eteinte/Allumee
         ; - PORTB<5>: Led YELLOW			0/1: Eteinte/Allumee
         
          #define	MSK_BIT_PULSE_IT			MSK_BIT3
         
          #define	UOS_MSK_BIT_LED_RED		MSK_BIT1
          #define	UOS_MSK_BIT_LED_GREEN	MSK_BIT2
          #define	UOS_MSK_BIT_LED_BLUE		MSK_BIT4
          #define	UOS_MSK_BIT_LED_YELLOW	MSK_BIT5
         
          #define	IDX_BIT_PULSE_IT			IDX_BIT3
         
          #define	UOS_IDX_BIT_LED_RED		IDX_BIT1
          #define	UOS_IDX_BIT_LED_GREEN	IDX_BIT2
          #define	UOS_IDX_BIT_LED_BLUE		IDX_BIT4
          #define	UOS_IDX_BIT_LED_YELLOW	IDX_BIT5
         
         ; --------
         ; Macros de pilotage du PORTB en sortie 
          .macro setLedsOff				; 0/1: On/Off
          	ldi		REG_TEMP_R23, (UOS_MSK_BIT_LED_RED | UOS_MSK_BIT_LED_GREEN | UOS_MSK_BIT_LED_YELLOW | UOS_MSK_BIT_LED_BLUE)
          	sts		UOS_G_PORTB_IMAGE, REG_TEMP_R23
          	out		PORTB, REG_TEMP_R23					; Raffraichissement du PORTB
          .endm
         
          .macro setLedRedOff			; 0/1: On/Off
          	lds		REG_TEMP_R23, UOS_G_FLAGS_1
          	cbr		REG_TEMP_R23, UOS_FLG_1_LED_RED_ON_MSK	; Led RED eteinte (Pulse --\_/--- possible)
          	sts		UOS_G_FLAGS_1, REG_TEMP_R23
          
          	lds		REG_TEMP_R23, UOS_G_PORTB_IMAGE
          	sbr		REG_TEMP_R23, UOS_MSK_BIT_LED_RED	
          	sts		UOS_G_PORTB_IMAGE, REG_TEMP_R23
          	out		PORTB, REG_TEMP_R23					; Raffraichissement du PORTB
          .endm
         
          .macro setLedRedOn			; 0/1: On/Off
          	lds		REG_TEMP_R23, UOS_G_FLAGS_1
          	sbr		REG_TEMP_R23, UOS_FLG_1_LED_RED_ON_MSK	; Led RED allumee (Pulse --\_/--- inhibee)
          	sts		UOS_G_FLAGS_1, REG_TEMP_R23
          
          	lds		REG_TEMP_R23, UOS_G_PORTB_IMAGE
          	cbr		REG_TEMP_R23, UOS_MSK_BIT_LED_RED	
          	sts		UOS_G_PORTB_IMAGE, REG_TEMP_R23
          	out		PORTB, REG_TEMP_R23					; Raffraichissement du PORTB
          .endm
         
          .macro setLedYellowOff		; 0/1: On/Off
          	lds		REG_TEMP_R23, UOS_G_PORTB_IMAGE
          	sbr		REG_TEMP_R23, UOS_MSK_BIT_LED_YELLOW
          	sts		UOS_G_PORTB_IMAGE, REG_TEMP_R23
          	out		PORTB, REG_TEMP_R23					; Raffraichissement du PORTB
          .endm
         
          .macro setLedYellowOn		; 0/1: On/Off
          	lds		REG_TEMP_R23, UOS_G_PORTB_IMAGE
          	cbr		REG_TEMP_R23, UOS_MSK_BIT_LED_YELLOW	
          	sts		UOS_G_PORTB_IMAGE, REG_TEMP_R23
          	out		PORTB, REG_TEMP_R23					; Raffraichissement du PORTB
          .endm
         
          .macro setLedGreenOff		; 0/1: On/Off
          	lds		REG_TEMP_R23, UOS_G_PORTB_IMAGE
          	sbr		REG_TEMP_R23, UOS_MSK_BIT_LED_GREEN	
          	sts		UOS_G_PORTB_IMAGE, REG_TEMP_R23
          	out		PORTB, REG_TEMP_R23					; Raffraichissement du PORTB
          .endm
         
          .macro setLedGreenOn			; 0/1: On/Off
          	lds		REG_TEMP_R23, UOS_G_PORTB_IMAGE
          	cbr		REG_TEMP_R23, UOS_MSK_BIT_LED_GREEN
          	sts		UOS_G_PORTB_IMAGE, REG_TEMP_R23
          	out		PORTB, REG_TEMP_R23					; Raffraichissement du PORTB
          .endm
         
          .macro setLedBlueOn			; 0/1: On/Off
          	lds		REG_TEMP_R23, UOS_G_PORTB_IMAGE
          	cbr		REG_TEMP_R23, UOS_MSK_BIT_LED_BLUE
          	sts		UOS_G_PORTB_IMAGE, REG_TEMP_R23
          	out		PORTB, REG_TEMP_R23					; Raffraichissement du PORTB
          .endm
         
          .macro setLedBlueOff			; 0/1: On/Off
          	lds		REG_TEMP_R23, UOS_G_PORTB_IMAGE
          	sbr		REG_TEMP_R23, UOS_MSK_BIT_LED_BLUE	
          	sts		UOS_G_PORTB_IMAGE, REG_TEMP_R23
          	out		PORTB, REG_TEMP_R23					; Raffraichissement du PORTB
          .endm
         
          .macro setPulseItUp			; Sortie au niveau haut de la pulse It
          	lds		REG_TEMP_R23, UOS_G_PORTB_IMAGE
          	sbr		REG_TEMP_R23, MSK_BIT_PULSE_IT	
          	sts		UOS_G_PORTB_IMAGE, REG_TEMP_R23
          	out		PORTB, REG_TEMP_R23					; Raffraichissement du PORTB
          .endm
         
          .macro setPulseItDown		; Sortie au niveau bas de la pulse It
          	lds		REG_TEMP_R23, UOS_G_PORTB_IMAGE
          	cbr		REG_TEMP_R23, MSK_BIT_PULSE_IT	
          	sts		UOS_G_PORTB_IMAGE, REG_TEMP_R23
          	out		PORTB, REG_TEMP_R23					; Raffraichissement du PORTB
          .endm
         ; Fin: Macros de pilotage du PORTB en sortie
         
         ; End of file
          ; End of file
         
          .cseg
         
         ; Vecteurs d'interruption dans le cas du fusible BOOTRST = 0
         ; + padding a 64 opcodes pour preparer une reprogrammation
         
          .org	0x0000 
         
          reset_addr_0x0:
C:000000 940c 3580 	jmp		uos_main_program							; # 1 RESET
C:000002 940c 35fb 	jmp		_uos_invalid_it_slow						; # 2 INT0
C:000004 940c 35fb 	jmp		_uos_invalid_it_slow						; # 3 INT1
C:000006 940c 35fb 	jmp		_uos_invalid_it_slow						; # 4 PCINT0
C:000008 940c 35fb 	jmp		_uos_invalid_it_slow						; # 5 PCINT1
C:00000a 940c 35fb 	jmp		_uos_invalid_it_slow						; # 6 PCINT2	; Pas de vecteur 'pcint2_isr_program' defini
C:00000c 940c 35fb 	jmp		_uos_invalid_it_slow						; # 7 WDT
C:00000e 940c 35fb 	jmp		_uos_invalid_it_slow						; # 8 TIMER2 COMPA
C:000010 940c 35fb 	jmp		_uos_invalid_it_slow						; # 9 TIMER2 COMPB
C:000012 940c 35fb 	jmp		_uos_invalid_it_slow						; #10 TIMER2 OVF
C:000014 940c 35fb 	jmp		_uos_invalid_it_slow						; #11 TIMER1 CAPT
C:000016 940c 3711 	jmp		uos_tim1_compa_isr_program				; #12 TIMER1 COMPA
C:000018 940c 35fb 	jmp		_uos_invalid_it_slow						; #13 TIMER1 COMPB
C:00001a 940c 35fb 	jmp		_uos_invalid_it_slow						; #14 TIMER1 OVF
C:00001c 940c 35fb 	jmp		_uos_invalid_it_slow						; #15 TIMER0 COMPA
C:00001e 940c 35fb 	jmp		_uos_invalid_it_slow						; #16 TIMER0 COMPB
C:000020 940c 35fb 	jmp		_uos_invalid_it_slow						; #17 TIMER0 OVF
C:000022 940c 35fb 	jmp		_uos_invalid_it_slow						; #18 SPI, SPC
C:000024 940c 376b 	jmp		uos_usart_rx_complete_isr_program	; #19 USART, RX
C:000026 940c 35fb 	jmp		_uos_invalid_it_slow						; #20 USART, UDRE
C:000028 940c 35fb 	jmp		_uos_invalid_it_slow						; #21 USART, TX
C:00002a 940c 35fb 	jmp		_uos_invalid_it_slow						; #22 ADC
C:00002c 940c 35fb 	jmp		_uos_invalid_it_slow						; #23 EE READY
C:00002e 940c 35fb 	jmp		_uos_invalid_it_slow						; #24 ANALOG COMP
C:000030 940c 35fb 	jmp		_uos_invalid_it_slow						; #25 TWI
C:000032 940c 35fb 	jmp		_uos_invalid_it_slow						; #26 SPM READY
         
         ; Reservation 2 bytes pour s'aligner sur le 'main' du Langage C
C:000034 940c 35e8 	jmp		_uos_forever	; Ne sera jamais execute (adresse du 'main()' d'un programme C)
         
          _uos_vector_timer_0_bootloader:
         ; ---------
         ; Table des 16 vecteurs d'execution non initialisee des taches timer codees dans l'espace PROGRAM
         ; ---------
C:000036 0000      	nop		; Adresse de la tache du Timer #0  ('_uos_callback_exec_timer_0')
C:000037 0000      	nop
C:000038 0000      	nop		; Adresse de la tache du Timer #1  ('_uos_callback_exec_timer_1')
C:000039 0000      	nop
C:00003a 0000      	nop		; Adresse de la tache du Timer #2  ('_uos_callback_exec_timer_2')
C:00003b 0000      	nop
C:00003c 0000      	nop		; Adresse de la tache du Timer #3  ('_uos_callback_exec_timer_3')
C:00003d 0000      	nop
C:00003e 0000      	nop		; Adresse de la tache du Timer #4  ('_uos_callback_exec_timer_4')
C:00003f 0000      	nop
C:000040 0000      	nop		; Adresse de la tache du Timer #5  ('_uos_callback_exec_timer_5')
C:000041 0000      	nop
C:000042 0000      	nop		; Adresse de la tache du Timer #6  ('_uos_callback_exec_timer_6')
C:000043 0000      	nop
C:000044 0000      	nop		; Adresse de la tache du Timer #7  ('_uos_callback_exec_timer_7')
C:000045 0000      	nop
C:000046 0000      	nop		; Adresse de la tache du Timer #8  ('_uos_callback_exec_timer_8')
C:000047 0000      	nop
C:000048 0000      	nop		; Adresse de la tache du Timer #9  ('_uos_callback_exec_timer_9')
C:000049 0000      	nop
C:00004a 0000      	nop		; Adresse de la tache du Timer #10 ('_uos_callback_exec_timer_10')
C:00004b 0000      	nop
C:00004c 0000      	nop		; Adresse de la tache du Timer #11 ('_uos_callback_exec_timer_11')
C:00004d 0000      	nop
C:00004e 0000      	nop		; Adresse de la tache du Timer #12 ('_uos_callback_exec_timer_12')
C:00004f 0000      	nop
C:000050 0000      	nop		; Adresse de la tache du Timer #13 ('_uos_callback_exec_timer_13')
C:000051 0000      	nop
C:000052 0000      	nop		; Adresse de la tache du Timer #14 ('_uos_callback_exec_timer_14')
C:000053 0000      	nop
C:000054 0000      	nop		; Adresse de la tache du Timer #15 ('_uos_callback_exec_timer_15')
C:000055 0000      	nop
         ; ---------
         
         ; ---------
         ; Table des 6 vecteurs d'execution non initialisee des "callback" du BOOTLOADER
         ; ---------
C:000056 0000      	nop		; Adresse '_uos_callback_init'
C:000057 0000      	nop
C:000058 0000      	nop		; Adresse '_uos_callback_background'
C:000059 0000      	nop
C:00005a 0000      	nop		; Adresse '_uos_callback_tick'
C:00005b 0000      	nop
C:00005c 0000      	nop		; Adresse '_uos_callback_1_ms'
C:00005d 0000      	nop
C:00005e 0000      	nop		; Adresse '_uos_callback_gest_buttons'
C:00005f 0000      	nop
C:000060 0000      	nop		; Adresse '_uos_callback_command'
C:000061 0000      	nop
         
         ; ---------
         ; Padding a 128 mots pour la programmation des 1st et 2nd pages...
         ; ---------
         	; 8 mots
C:000062 0000      	nop
C:000063 0000      	nop
C:000064 0000      	nop
C:000065 0000      	nop
C:000066 0000      	nop
C:000067 0000      	nop
C:000068 0000      	nop
C:000069 0000      	nop
C:00006a 0000      	nop
C:00006b 0000      	nop
C:00006c 0000      	nop
C:00006d 0000      	nop
C:00006e 0000      	nop
C:00006f 0000      	nop
C:000070 0000      	nop
C:000071 0000      	nop
         
         	; 7 mots
C:000072 0000      	nop
C:000073 0000      	nop
C:000074 0000      	nop
C:000075 0000      	nop
C:000076 0000      	nop
C:000077 0000      	nop
C:000078 0000      	nop
C:000079 0000      	nop
C:00007a 0000      	nop
C:00007b 0000      	nop
C:00007c 0000      	nop
C:00007d 0000      	nop
C:00007e 0000      	nop
C:00007f 0000      	nop
         
          .org	0x3580 
         
         ; ---------
         ; Adresse de programmation possible d'une page de 64 instructions
         ; dans l'implementation de 'ATmega328P.ext' qui sera supprime a terme
         ; ou de 'ATmega328P.addons' qui precise les vecteurs d'interruptions
         ; et les vecteur de prolongation...
         ;
         ; => WARNING: '_uos_valid_address_range_1_to' devra etre defini dans 'ATmega328P_uOS_P1.addons'
         ;             pour un bon fonctionnement de la commande "<dAAAA-BBBB" qui permet de
         ;             de reprogrammer une page de 64 opcodes de derivation ;-)
         ; ---------
         
         ; ---------
          uos_main_program:
         	; Marquage de l'origine du RESET (Espace PROGRAM)
C:003580 2700      	clr		REG_TEMP_R16
C:003581 6008      	sbr		REG_TEMP_R16, FLG_STATE_AT_RESET_PROGRAM_MSK		
C:003582 9300 0500 	sts		G_STATES_AT_RESET, REG_TEMP_R16
         
         	; Vecteurs d'interruption dans la section PROGRAM
         	; Enable change of Interrupts Vectors
C:003584 e001      	ldi	REG_TEMP_R16, (1 << IVCE)
C:003585 bf05      	out	MCUCR, REG_TEMP_R16
         
         	; Move interrupts to Program section
C:003586 2700      	clr	REG_TEMP_R16
C:003587 bf05      	out	MCUCR, REG_TEMP_R16
         	; End: Enable change of Interrupts Vectors
         
C:003588 c008      	rjmp		_uos_main
         
          _uos_main_bootloader:
         	; Marquage de l'origine du RESET (Espace BOOTLOADER)
C:003589 2700      	clr		REG_TEMP_R16
C:00358a 6800      	sbr		REG_TEMP_R16, FLG_STATE_AT_RESET_BOOTLOADER_MSK		
C:00358b 9300 0500 	sts		G_STATES_AT_RESET, REG_TEMP_R16
         
         	; Vecteurs d'interruption dans la section BOOTLOADER
         	; Enable change of Interrupts Vectors
C:00358d e001      	ldi	REG_TEMP_R16, (1 << IVCE)
C:00358e bf05      	out	MCUCR, REG_TEMP_R16
         
         	; Move interrupts to Boot Flash section
C:00358f e002      	ldi	REG_TEMP_R16, (1 << IVSEL)
C:003590 bf05      	out	MCUCR, REG_TEMP_R16
         	; Fin: Vecteurs d'interruption dans la section BOOTLOADER
         
         	;rjmp		main
         
          _uos_main:
C:003591 d2d0      	rcall		_uos_init_sram_fill		; Initialisation de la SRAM	
C:003592 d2e0      	rcall		_uos_init_sram_values	; Initialisation de valeurs particulieres
         
         	; Test Leds avant l'initialisation hard
         	; Sortie Leds et de la Pulse IT
         	; => Warning: La Led BLUE est partagee avec le TX
         	;             => Le port correspondant sera remis en Input pour ne pas "ecrase" la signal d'emission ;-)
C:003593 e30e      	ldi		REG_TEMP_R16, (1 << UOS_IDX_BIT_LED_RED) | (1 << UOS_IDX_BIT_LED_GREEN) | (1 << UOS_IDX_BIT_LED_YELLOW) | (1 << UOS_IDX_BIT_LED_BLUE) | (1 << IDX_BIT_PULSE_IT)
C:003594 b904      	out		DDRB, REG_TEMP_R16
         
         	; Extinction des 4 Leds BLUE, RED, GREEN et YELLOW et de leur image
C:003595 e376      	ldi		REG_TEMP_R23, (UOS_MSK_BIT_LED_RED | UOS_MSK_BIT_LED_GREEN | UOS_MSK_BIT_LED_YELLOW | UOS_MSK_BIT_LED_BLUE)
C:003596 9370 050f 	sts		UOS_G_PORTB_IMAGE, REG_TEMP_R23
C:003598 b975      	out		PORTB, REG_TEMP_R23					; Raffraichissement du PORTB
         
C:003599 d2e4      	rcall		_uos_init_hard			; Initialisation du materiel
C:00359a d15d      	rcall		read_and_test_magic_const
C:00359b d13c      	rcall		init_test_leds			; Lancement du test led en fond de tache
         
         	; Initialisation timer 'TIMER_LED_GREEN' pour le chenillard Led GREEN 
C:00359c e01e      	ldi		REG_TEMP_R17, TIMER_LED_GREEN
C:00359d e72d      	ldi		REG_TEMP_R18, (125 % 256)
C:00359e e030      	ldi		REG_TEMP_R19, (125 / 256)
C:00359f d3b5      	rcall		uos_start_timer
         
C:0035a0 9100 0500 	lds		REG_TEMP_R16, G_STATES_AT_RESET
C:0035a2 ff03      	sbrs		REG_TEMP_R16, FLG_STATE_AT_RESET_PROGRAM_IDX
C:0035a3 c003      	rjmp		_uos_main_prompt_more
         
          _uos_main_prompt_program:
         	; Preparation du "Hello World"
C:0035a4 e7fe      	ldi		REG_Z_MSB, high(_uos_text_program << 1)
C:0035a5 eae8      	ldi		REG_Z_LSB, low(_uos_text_program << 1)
C:0035a6 c006      	rjmp		_uos_main_more
         
          _uos_main_prompt_more:
C:0035a7 9100 0500 	lds		REG_TEMP_R16, G_STATES_AT_RESET
C:0035a9 ff07      	sbrs		REG_TEMP_R16, FLG_STATE_AT_RESET_BOOTLOADER_IDX
C:0035aa c002      	rjmp		_uos_main_more
         
          _uos_main_prompt_bootloader:
         	; Preparation du prompt "Bootloader"
C:0035ab e7fe      	ldi		REG_Z_MSB, high(_uos_text_bootloader << 1)
C:0035ac ebee      	ldi		REG_Z_LSB, low(_uos_text_bootloader << 1)
         
          _uos_main_more:
         	; Initialisation du CHENILLARD @ emplacement des vecteurs d'interruption a l'expiration de 'TIMER_CONNECT'
C:0035ad e01f         ldi      REG_TEMP_R17, TIMER_CONNECT
C:0035ae e624         ldi      REG_TEMP_R18, (100 % 256)
C:0035af e030         ldi      REG_TEMP_R19, (100 / 256)
C:0035b0 d3a4         rcall    uos_start_timer
         
         	; Set all interruptions car emission sur l'It de cadencement ;-)
C:0035b1 9478      	sei
         
         	; Print du prompt "Bootloader" eor "Hello World"
C:0035b2 d73a      	rcall		uos_push_text_in_fifo_tx
         
         	; Print de '_uos_text_prompt'
C:0035b3 e7fe      	ldi		REG_Z_MSB, high(_uos_text_prompt << 1)
C:0035b4 e8e6      	ldi		REG_Z_LSB, low(_uos_text_prompt << 1)
C:0035b5 d737      	rcall		uos_push_text_in_fifo_tx
         
         	; Print de la frequence 8/16 MHz @ FLG_0_RC_OSC_8MHZ
C:0035b6 d10c      	rcall		uos_print_frequency
         
         	; Print des informations de l'EEPROM
C:0035b7 d6fa      	rcall		uos_set_infos_from_eeprom
         
         	; Forcage de l'emission...
C:0035b8 d539      	rcall		uos_fifo_tx_to_send_sync
         
         	; ---------
         	; Prolongement de l'initialisation si le code est execute au RESET depuis
         	; l'espace PROGRAM et si le vecteur commence par l'instruction 'rjmp'
         	; ---------
C:0035b9 e3f8      	ldi		REG_Z_MSB, high(_uos_callback_init)	; Execution si possible de l'extension
C:0035ba e5e6      	ldi		REG_Z_LSB, low(_uos_callback_init)	; dans l'espace PROGRAM
C:0035bb d066      	rcall		_uos_exec_extension_into_program
         	; ---------
         
          _uos_main_loop:
         	; Gestion de l'attente expiration des 1ms
C:0035bc 9170 0510 	lds		REG_TEMP_R23, UOS_G_FLAGS_0
C:0035be ff70      	sbrs		REG_TEMP_R23, FLG_0_PERIODE_1MS_IDX		; 1mS expiree ?
         
C:0035bf c022      	rjmp		_uos_main_loop_more									; Non
         
         	; --- Traitements toutes les 1mS
         	; => Expiration de 1mS => Nouvelle periode de 1mS
         	; => call 'gestion_timer' (execution du traitement associe a chaque timer qui expire)
         	; => reinitialisation 'G_TICK_1MS' (copie atomique ;-)
         	; => Effacement 'FLG_0_PERIODE_1MS' -> Relance de la comptabilisation des 1mS
         	; => Comptabilisation des mS a concurence de 1 Sec pour la synchronisation du timer
         	;    d'erreur sur celui de 'TIMER_LED_GREEN'
         
C:0035c0 9110 0503 	lds		REG_TEMP_R17, G_TICK_1MS_INIT
C:0035c2 9310 0502 	sts		G_TICK_1MS, REG_TEMP_R17
         
C:0035c4 9170 0510 	lds		REG_TEMP_R23, UOS_G_FLAGS_0
C:0035c6 7f7e      	cbr		REG_TEMP_R23, FLG_0_PERIODE_1MS_MSK
C:0035c7 9370 0510 	sts		UOS_G_FLAGS_0, REG_TEMP_R23
         
C:0035c9 91b0 0504 	lds		REG_X_MSB, G_COUNTER_1MS_MSB
C:0035cb 91a0 0505 	lds		REG_X_LSB, G_COUNTER_1MS_LSB
C:0035cd 9611      	adiw		REG_X_LSB, 1
C:0035ce 93b0 0504 	sts		G_COUNTER_1MS_MSB, REG_X_MSB
C:0035d0 93a0 0505 	sts		G_COUNTER_1MS_LSB, REG_X_LSB
C:0035d2 3ea8      	cpi		REG_X_LSB, (1000 % 256)
C:0035d3 f439      	brne		_uos_main_loop_cont_d
C:0035d4 30b3      	cpi		REG_X_MSB, (1000 / 256)
C:0035d5 f429      	brne		_uos_main_loop_cont_d
         
C:0035d6 2700      	clr		REG_TEMP_R16
C:0035d7 9300 0504 	sts		G_COUNTER_1MS_MSB, REG_TEMP_R16
C:0035d9 9300 0505 	sts		G_COUNTER_1MS_LSB, REG_TEMP_R16
         
          _uos_main_loop_cont_d:
         
C:0035db d335      	rcall		_uos_gestion_timer		; Gestion des timers
         
         	; Presentation sur Led GREEN mode "Connecte/Non Connecte"
C:0035dc d2ee      	rcall		_uos_presentation_connexion
         
         	; Gestion des 4 boutons par PROGRAM (en 1st lieu) et par BOOTLOADER (si pas acquite)
C:0035dd d536      	rcall		_uos_gest_buttons
         
         	; ---------
         	; Prolongement des traitements 1mS si le code est execute au RESET depuis
         	; l'espace PROGRAM et si le vecteur commence par l'instruction 'rjmp'
         	; ---------
C:0035de e3f8      	ldi		REG_Z_MSB, high(_uos_callback_1_ms)	; Execution si possible de l'extension
C:0035df e5ec      	ldi		REG_Z_LSB, low(_uos_callback_1_ms)	; dans l'espace PROGRAM
C:0035e0 d041      	rcall		_uos_exec_extension_into_program
         	; ---------
         
         	; Interpretation de la commande recue
C:0035e1 d7ab      	rcall		_uos_interpret_command
         
         	; Fin: --- Traitements toutes les 1mS
         
          _uos_main_loop_more:
         	; Test et emission eventuelle d'un caractere de la FIFO/Tx
         	; => Effectue des que possible des lors que 'FLG_1_UART_FIFO_TX_TO_SEND'
         	;    est a 1 et que 'FLG_0_UART_TX_TO_SEND' est a 0
         	;    => Traitement en fond de tache pour cadencer l'emission au max des 9600 bauds
C:0035e2 d4fc      	rcall		_uos_fifo_tx_to_send_async
         
         	; Presentation erreurs sur Led RED Externe
C:0035e3 d2fc      	rcall		_uos_presentation_error
         
         	; ---------
         	; Prolongement si le code est execute au RESET depuis l'espace PROGRAM et
         	; si le vecteur commence par l'instruction 'rjmp'
         	; ---------
C:0035e4 e3f8      	ldi		REG_Z_MSB, high(_uos_callback_background)	; Execution si possible de l'extension
C:0035e5 e5e8      	ldi		REG_Z_LSB, low(_uos_callback_background)	; dans l'espace PROGRAM
C:0035e6 d03b      	rcall		_uos_exec_extension_into_program
         	; ---------
         
C:0035e7 cfd4      	rjmp		_uos_main_loop
         
          _uos_forever:
C:0035e8 94f8      	cli
C:0035e9   +  	setLedRedOn
C:0035e9 9170 0511 lds		REG_TEMP_R23, UOS_G_FLAGS_1
C:0035eb 6870      sbr		REG_TEMP_R23, UOS_FLG_1_LED_RED_ON_MSK	

C:0035ec 9370 0511 sts		UOS_G_FLAGS_1, REG_TEMP_R23
         
C:0035ee 9170 050f lds		REG_TEMP_R23, UOS_G_PORTB_IMAGE
C:0035f0 7f7d      cbr		REG_TEMP_R23, UOS_MSK_BIT_LED_RED	
C:0035f1 9370 050f sts		UOS_G_PORTB_IMAGE, REG_TEMP_R23
C:0035f3 b975      out		PORTB, REG_TEMP_R23					

         
          _uos_forever_loop:	
C:0035f4 cfff      	rjmp		_uos_forever_loop
         
         ; ---------
         ; Mise sur voie de garage avec clignotement "lent" ou "rapide" de la Led RED
         ; ---------
          _uos_awaiting_prog:
C:0035f5 94f8      	cli
C:0035f6 e005      	ldi		REG_TEMP_R16, 5
C:0035f7 c009      	rjmp		_uos_invalid_it_leds_off
         
          _uos_invalid_it_speed:
C:0035f8 94f8      	cli
C:0035f9 e104      	ldi		REG_TEMP_R16, 20
C:0035fa c002      	rjmp		_uos_invalid_it_more
         
          _uos_invalid_it_slow:
C:0035fb 94f8      	cli
C:0035fc e500      	ldi		REG_TEMP_R16, 80
         
          _uos_invalid_it_more:
         	; Memorisation du numero de l'It non attendue dans l'espace bootloader
C:0035fd 6810      	sbr		REG_TEMP_R17, UOS_FLG_WRONG_IT_BOOLOADER_MSK
C:0035fe 7b1f      	cbr		REG_TEMP_R17, UOS_FLG_WRONG_IT_PROGRAM_MSK
C:0035ff 9310 0501 	sts		UOS_G_STATES_POST_MORTEM, REG_TEMP_R17
         
          _uos_invalid_it_leds_off:
         	; Extinction de toutes les Leds
C:003601   +  	setLedsOff
C:003601 e376      ldi		REG_TEMP_R23, (UOS_MSK_BIT_LED_RED | UOS_MSK_BIT_LED_GREEN | UOS_MSK_BIT_LED_YELLOW | UOS_MSK_BIT_LED_BLUE)
C:003602 9370 050f sts		UOS_G_PORTB_IMAGE, REG_TEMP_R23
C:003604 b975      out		PORTB, REG_TEMP_R23					

         
          _uos_invalid_it_loop:
C:003605 930f      	push		REG_TEMP_R16			; Save/Restore temporisation dans REG_TEMP_R16
C:003606   +  	setLedRedOn
C:003606 9170 0511 lds		REG_TEMP_R23, UOS_G_FLAGS_1
C:003608 6870      sbr		REG_TEMP_R23, UOS_FLG_1_LED_RED_ON_MSK	

C:003609 9370 0511 sts		UOS_G_FLAGS_1, REG_TEMP_R23
         
C:00360b 9170 050f lds		REG_TEMP_R23, UOS_G_PORTB_IMAGE
C:00360d 7f7d      cbr		REG_TEMP_R23, UOS_MSK_BIT_LED_RED	
C:00360e 9370 050f sts		UOS_G_PORTB_IMAGE, REG_TEMP_R23
C:003610 b975      out		PORTB, REG_TEMP_R23					

C:003611 d0bc      	rcall		uos_delay_big_2
C:003612 910f      	pop		REG_TEMP_R16
C:003613 930f      	push		REG_TEMP_R16
C:003614   +  	setLedRedOff
C:003614 9170 0511 lds		REG_TEMP_R23, UOS_G_FLAGS_1
C:003616 777f      cbr		REG_TEMP_R23, UOS_FLG_1_LED_RED_ON_MSK	

C:003617 9370 0511 sts		UOS_G_FLAGS_1, REG_TEMP_R23
         
C:003619 9170 050f lds		REG_TEMP_R23, UOS_G_PORTB_IMAGE
C:00361b 6072      sbr		REG_TEMP_R23, UOS_MSK_BIT_LED_RED	
C:00361c 9370 050f sts		UOS_G_PORTB_IMAGE, REG_TEMP_R23
C:00361e b975      out		PORTB, REG_TEMP_R23					

C:00361f d0ae      	rcall		uos_delay_big_2
C:003620 910f      	pop		REG_TEMP_R16
C:003621 cfe3      	rjmp		_uos_invalid_it_loop
         ; ---------
         
         ; ---------
         ; Execution du prolongement dans l'espace PROGRAM si
         ; - RESET depuis l'espace PROGRAM
         ; - Opcode 'rjmp' trouve en 1st instruction du code a executer en prolongement
         ;
         ; Input: 'Z': Adresse du vecteur d'execution du prolongement
         ; ---------
          _uos_exec_extension_into_program:
         	; Code execute depuis l'espace PROGRAM ?
C:003622 d29a      	rcall		_uos_if_execution_into_zone_program
C:003623 f089      	breq		_uos_exec_extension_into_program_end		; Saut si "pas dans l'espace PROGRAM"
         
         	; Determination de l'addresse du vecteur correspondant dans l'espace PROGRAM
C:003624 e3b8      	ldi		REG_X_MSB, high(_uos_reset_bootloader)
C:003625 e0a0      	ldi		REG_X_LSB, low(_uos_reset_bootloader)
C:003626 1bea      	sub		REG_Z_LSB, REG_X_LSB
C:003627 0bfb      	sbc		REG_Z_MSB, REG_X_MSB		; 'Z' contient l'adresse de l'extension
         
C:003628 01df      	movw		REG_X_LSB, REG_Z_LSB		; Sauvegarde de l'adresse du vecteur dans l'espace PROGRAM
         
         	; Lecture de l'opcode @ 'Z' pour savoir si le chainage est valide
         	; => Presence d'un 'rjmp' a un traitement (teste) se terminant par un 'ret' (non teste)
         	;    car appele avec 'icall'
C:003629 0fee      	lsl		REG_Z_LSB
C:00362a 1fff      	rol		REG_Z_MSB
C:00362b 9105      	lpm		REG_TEMP_R16, Z+
C:00362c 9114      	lpm		REG_TEMP_R17, Z
         
         	; Test si 'jmp' (1001 010k kkkk 110k -> 0x940C apres masque des 'k'))
C:00362d 7914      	andi		REG_TEMP_R17, 0x94
C:00362e 3914      	cpi		REG_TEMP_R17, 0x94
C:00362f f429      	brne		_uos_exec_extension_into_program_end
         
C:003630 700c      	andi		REG_TEMP_R16, 0x0C
C:003631 300c      	cpi		REG_TEMP_R16, 0x0C
C:003632 f411      	brne		_uos_exec_extension_into_program_end
         
         	; Execution de l'extension dans l'espace PROGRAM
C:003633 01fd      	movw		REG_Z_LSB, REG_X_LSB		; Reprise de l'adresse du vecteur dans l'espace PROGRAM
C:003634 9509      	icall
         
          _uos_exec_extension_into_program_end:
C:003635 9508      	ret
         ; ---------
         
         ; ---------
         ; delay de 5uS ou 10uS environ avec un ATmega328p 16MHz (62 nS)
         ; => Mesure a l'oscilloscope:  8uS au lieu de   5S
         ; => Mesure a l'oscilloscope: 13uS au lieu de 10uS
         ;
          derivation_delay_5uS:
          _uos_delay_5uS:
C:003636 e00a      	ldi		REG_TEMP_R16, 10
C:003637 c001      	rjmp		_uos_delay_loop
         
          _uos_delay_10uS:
C:003638 e104      	ldi		REG_TEMP_R16, 20
         	;rjmp		_uos_delay_loop
         
          uos_derivation_delay_5uS_cont_d:
          _uos_delay_loop:
C:003639 0000      	nop								;   1
C:00363a 0000      	nop								; + 1
C:00363b 0000      	nop								; + 1
C:00363c 0000      	nop								; + 1
C:00363d 0000      	nop								; + 1
         
C:00363e 950a      	dec		REG_TEMP_R16		; + 1
C:00363f f7c9      	brne		_uos_delay_loop			; + 2 = 8 => 160 cycles => 9.92 uS
         
C:003640 9508      	ret
         ; ---------
         
         ; ---------
         ; uos_save_reg_r0_r31
         ; => Ecriture dans la SRAM des 32 registres 'r0' a 'r32'
         ;    pour une utilisation depuis un programme C
         ; ---------
          uos_save_reg_r0_r31:
C:003641 9200 0514 	sts		UOS_G_SAVE_R0, r0
C:003643 9210 0515 	sts		UOS_G_SAVE_R1, r1
C:003645 9220 0516 	sts		UOS_G_SAVE_R2, r2
C:003647 9230 0517 	sts		UOS_G_SAVE_R3, r3
C:003649 9240 0518 	sts		UOS_G_SAVE_R4, r4
C:00364b 9250 0519 	sts		UOS_G_SAVE_R5, r5
C:00364d 9260 051a 	sts		UOS_G_SAVE_R6, r6
C:00364f 9270 051b 	sts		UOS_G_SAVE_R7, r7
C:003651 9280 051c 	sts		UOS_G_SAVE_R8, r8
C:003653 9290 051d 	sts		UOS_G_SAVE_R9, r9
C:003655 92a0 051e 	sts		UOS_G_SAVE_R10, r10
C:003657 92b0 051f 	sts		UOS_G_SAVE_R11, r11
C:003659 92c0 0520 	sts		UOS_G_SAVE_R12, r12
C:00365b 92d0 0521 	sts		UOS_G_SAVE_R13, r13
C:00365d 92e0 0522 	sts		UOS_G_SAVE_R14, r14
C:00365f 92f0 0523 	sts		UOS_G_SAVE_R15, r15
C:003661 9300 0524 	sts		UOS_G_SAVE_R16, r16
C:003663 9310 0525 	sts		UOS_G_SAVE_R17, r17
C:003665 9320 0526 	sts		UOS_G_SAVE_R18, r18
C:003667 9330 0527 	sts		UOS_G_SAVE_R19, r19
C:003669 9340 0528 	sts		UOS_G_SAVE_R20, r20
C:00366b 9350 0529 	sts		UOS_G_SAVE_R21, r21
C:00366d 9360 052a 	sts		UOS_G_SAVE_R22, r22
C:00366f 9370 052b 	sts		UOS_G_SAVE_R23, r23
C:003671 9380 052c 	sts		UOS_G_SAVE_R24, r24
C:003673 9390 052d 	sts		UOS_G_SAVE_R25, r25
C:003675 93a0 052e 	sts		UOS_G_SAVE_R26, r26
C:003677 93b0 052f 	sts		UOS_G_SAVE_R27, r27
C:003679 93c0 0530 	sts		UOS_G_SAVE_R28, r28
C:00367b 93d0 0531 	sts		UOS_G_SAVE_R29, r29
C:00367d 93e0 0532 	sts		UOS_G_SAVE_R30, r30
C:00367f 93f0 0533 	sts		UOS_G_SAVE_R31, r31
         
C:003681 9508      	ret
         ; ---------
         
         ; --------r0, -
         ; uos_restore_reg_r0_r31
         ; => Restauration depuis la pile des 32 registres
         ;    pour une utilisation depuis un programme C
         ; ---------
          uos_restore_reg_r0_r31:
C:003682 9000 0514 	lds		r0, UOS_G_SAVE_R0
C:003684 9010 0515 	lds		r1, UOS_G_SAVE_R1
C:003686 9020 0516 	lds		r2, UOS_G_SAVE_R2
C:003688 9030 0517 	lds		r3, UOS_G_SAVE_R3
C:00368a 9040 0518 	lds		r4, UOS_G_SAVE_R4
C:00368c 9050 0519 	lds		r5, UOS_G_SAVE_R5
C:00368e 9060 051a 	lds		r6, UOS_G_SAVE_R6
C:003690 9070 051b 	lds		r7, UOS_G_SAVE_R7
C:003692 9080 051c 	lds		r8, UOS_G_SAVE_R8
C:003694 9090 051d 	lds		r9, UOS_G_SAVE_R9
C:003696 90a0 051e 	lds		r10, UOS_G_SAVE_R10
C:003698 90b0 051f 	lds		r11, UOS_G_SAVE_R11
C:00369a 90c0 0520 	lds		r12, UOS_G_SAVE_R12
C:00369c 90d0 0521 	lds		r13, UOS_G_SAVE_R13
C:00369e 90e0 0522 	lds		r14, UOS_G_SAVE_R14
C:0036a0 90f0 0523 	lds		r15, UOS_G_SAVE_R15
C:0036a2 9100 0524 	lds		r16, UOS_G_SAVE_R16
C:0036a4 9110 0525 	lds		r17, UOS_G_SAVE_R17
C:0036a6 9120 0526 	lds		r18, UOS_G_SAVE_R18
C:0036a8 9130 0527 	lds		r19, UOS_G_SAVE_R19
C:0036aa 9140 0528 	lds		r20, UOS_G_SAVE_R20
C:0036ac 9150 0529 	lds		r21, UOS_G_SAVE_R21
C:0036ae 9160 052a 	lds		r22, UOS_G_SAVE_R22
C:0036b0 9170 052b 	lds		r23, UOS_G_SAVE_R23
C:0036b2 9180 052c 	lds		r24, UOS_G_SAVE_R24
C:0036b4 9190 052d 	lds		r25, UOS_G_SAVE_R25
C:0036b6 91a0 052e 	lds		r26, UOS_G_SAVE_R26
C:0036b8 91b0 052f 	lds		r27, UOS_G_SAVE_R27
C:0036ba 91c0 0530 	lds		r28, UOS_G_SAVE_R28
C:0036bc 91d0 0531 	lds		r29, UOS_G_SAVE_R29
C:0036be 91e0 0532 	lds		r30, UOS_G_SAVE_R30
C:0036c0 91f0 0533 	lds		r31, UOS_G_SAVE_R31
         
C:0036c2 9508      	ret
         ; ---------
         
         ; ---------
         ; Print de la frequence 8/16 MHz @ FLG_0_RC_OSC_8MHZ
         ; ---------
          uos_print_frequency:
         	; A priori 16 MHz
C:0036c3 e7fe      	ldi		REG_Z_MSB, high(_uos_text_frequency_16_mhz << 1)
C:0036c4 edec      	ldi		REG_Z_LSB, low(_uos_text_frequency_16_mhz << 1)
         
C:0036c5 9170 0510 	lds		REG_TEMP_R23, UOS_G_FLAGS_0
C:0036c7 ff77      	sbrs		REG_TEMP_R23, FLG_0_RC_OSC_8MHZ_IDX
         
C:0036c8 c002      	rjmp		uos_print_frequency_end
         
C:0036c9 e7fe      	ldi		REG_Z_MSB, high(_uos_text_frequency_8_mhz << 1)
C:0036ca ede0      	ldi		REG_Z_LSB, low(_uos_text_frequency_8_mhz << 1)
         
          uos_print_frequency_end:
C:0036cb d621      	rcall		uos_push_text_in_fifo_tx
         
C:0036cc 9508      	ret
         ; ---------
         
         ; ---------
         ; uos_delay_big
         ; => Delay "long" de duree fixe @ REG_TEMP_R16, REG_TEMP_R17 et REG_TEMP_R18
         ;
         ; uos_delay_big_2(REG_TEMP_R16)
         ; => Ne doit pas etre appelee sous It
         ;
          uos_delay_big:
C:0036cd e208      	ldi		REG_TEMP_R16, 40
         
          uos_delay_big_2:
C:0036ce e71d      	ldi		REG_TEMP_R17, 125
         
          _uos_delay_big_more:
          #if 0			; USE_AVRSIMU
          #else
C:0036cf ef2a      	ldi		REG_TEMP_R18, 250
          #endif
         
          _uos_delay_big_more_1:
C:0036d0 952a      	dec		REG_TEMP_R18
C:0036d1 0000      	nop									; Wait 1 cycle
C:0036d2 f7e9      	brne		_uos_delay_big_more_1
C:0036d3 951a      	dec		REG_TEMP_R17
C:0036d4 f7d1      	brne		_uos_delay_big_more
C:0036d5 950a      	dec		REG_TEMP_R16
C:0036d6 f7b9      	brne		uos_delay_big_2
C:0036d7 9508      	ret
         ; ---------
         
         ; ---------
         ; Test Leds suivant la sequence definie par 'text_test_leds'
         ;
         ; - 'init_test_leds': Armorce du test
         ; - 'exec_test_leds': Progression du test a l'expiration du timer dedie
         ;   => 'exec_test_leds' doit imperativement etre implemente apres 'init_test_leds'
         ; ---------
          init_test_leds:
         ; ---------
C:0036d8 e800      	ldi		REG_TEMP_R16, FLG_GESTION_TEST_LEDS_MSK
C:0036d9 9300 0513 	sts		UOS_G_GESTION_TEST_LEDS, REG_TEMP_R16
         ; ---------
         
         ; ---------
         ; Cadencement des allumages/extinctions des Leds
         ; ---------
          exec_test_leds:
         ; ---------
C:0036db e7ff      	ldi		REG_Z_MSB, high(mask_for_test_leds << 1)
C:0036dc e9e6      	ldi		REG_Z_LSB, low(mask_for_test_leds << 1)
C:0036dd 9100 0513 	lds		REG_TEMP_R16, UOS_G_GESTION_TEST_LEDS
C:0036df 770f      	andi		REG_TEMP_R16, ~FLG_GESTION_TEST_LEDS_MSK & 0xFF		; '& 0xFF' pour eviter un warning ;-)
C:0036e0 0fe0      	add		REG_Z_LSB, REG_TEMP_R16
C:0036e1 2711      	clr		REG_TEMP_R17
C:0036e2 1ff1      	adc		REG_Z_MSB, REG_TEMP_R17
C:0036e3 9114      	lpm      REG_TEMP_R17, Z					; 'REG_TEMP_R17' = Etat et masques d'affichage
         
C:0036e4 ff17      	sbrs		REG_TEMP_R17, FLG_GESTION_TEST_LEDS_IDX
C:0036e5 c008      	rjmp		exec_test_leds_end
         
          exec_test_leds_refresh:
C:0036e6 9310 050f 	sts		UOS_G_PORTB_IMAGE, REG_TEMP_R17		; Update Leds...
         
C:0036e8 9100 0513 	lds		REG_TEMP_R16, UOS_G_GESTION_TEST_LEDS	; Update progression...
C:0036ea 9503      	inc		REG_TEMP_R16								; Next test
C:0036eb 9300 0513 	sts		UOS_G_GESTION_TEST_LEDS, REG_TEMP_R16
         
C:0036ed c004      	rjmp		exec_test_leds_more
         
          exec_test_leds_end:
         	; End of the test
C:0036ee 2700      	clr		REG_TEMP_R16
C:0036ef 9300 0513 	sts		UOS_G_GESTION_TEST_LEDS, REG_TEMP_R16
C:0036f1 c005      	rjmp		exec_test_leds_rtn
         
          exec_test_leds_more:
         	; Continue the test
         	; Reinitialisation timer 'TIMER_TEST_LEDS'
C:0036f2 e019      	ldi		REG_TEMP_R17, TIMER_TEST_LEDS
         
C:0036f3 ef24      	ldi		REG_TEMP_R18, (DURATION_TIMER_TEST_LEDS % 256)
C:0036f4 e031      	ldi		REG_TEMP_R19, (DURATION_TIMER_TEST_LEDS / 256)
C:0036f5 940e 3955 	call		uos_start_timer
         
          exec_test_leds_rtn:
C:0036f7 9508      	ret
         ; ---------
         ; Fin: Test Leds suivant la sequence definie par 'text_test_leds'
         ; ---------
         
         ; ---------
         ; Lecture des 2 bytes a l'adresse '_uos_magic_const'...
         ; ---------
          read_and_test_magic_const:
C:0036f8 e7ff      	ldi		REG_Z_MSB, high(_uos_magic_const << 1)
C:0036f9 eee2      	ldi		REG_Z_LSB, low(_uos_magic_const << 1)
C:0036fa 9105      	lpm		REG_TEMP_R16, Z+
C:0036fb 3f0f      	cpi		REG_TEMP_R16, 0xFF
C:0036fc f411      	brne		read_and_test_magic_const_more
C:0036fd 940c 35f5 	jmp		_uos_awaiting_prog
         
          read_and_test_magic_const_more:
C:0036ff 9104      	lpm		REG_TEMP_R16, Z
C:003700 3f0f      	cpi		REG_TEMP_R16, 0xFF
C:003701 f411      	brne		read_and_test_magic_const_rtn
C:003702 940c 35f5 	jmp		_uos_awaiting_prog
         
          read_and_test_magic_const_rtn:
C:003704 9508      	ret
         ; ---------
         
         ; ---------
         ; Ecriture d'un byte contenu dans 'REG_TEMP_R16' a l'adresse 'REG_X_MSB:REG_X_LSB' de l'EEPROM
         ; ---------
          uos_eeprom_write_byte:
         	; Set address
C:003705 bda1      	out		EEARL, REG_X_LSB
C:003706 bdb2      	out		EEARH, REG_X_MSB
         
         	; Set data
C:003707 bd00      	out		EEDR, REG_TEMP_R16
         
         	; Ecriture a l'adresse 'REG_X_MSB:REG_X_LSB' d'un byte
C:003708 98fd      	cbi		EECR, EEPM1
C:003709 98fc      	cbi		EECR, EEPM0
         
         	; Sequence interruptible
C:00370a 94f8      	cli
C:00370b 9afa      	sbi		EECR, EEMPE		; Start EEPROM write
C:00370c 9af9      	sbi		EECR, EEPE
C:00370d 9478      	sei
         	; Fin: Sequence interruptible
         	; Fin: Ecriture a l'adresse 'REG_X_MSB:REG_X_LSB' d'un byte
         
          uos_eeprom_write_byte_wait:
C:00370e 99f9      	sbic		EECR, EEPE
C:00370f cffe      	rjmp		uos_eeprom_write_byte_wait
         
C:003710 9508      	ret
         ; ---------
         
         ; ---------
         ; _uos_tim1_compa_isr
         ;
         ; Methode appele a chaque expiration du timer #1 interne (100 uS)
         ;
         ; => TODO: Traitements (Nbr de cycles maximal):
         ;    0 - Entree dans l'It + gestion de la pulse         -> 33 cycles max
         ;    1 - tim1_compa_isr_acq_rxd:     Acquisition de RXD pour detection ligne IDLE   -> 18 cycles max
         ;    2 - tim1_compa_isr_tx_send_bit: Emission d'un bit sur TXD + uart_fifo_rx_write -> 39 + 30 cycles max
         ;    3 - tim1_compa_isr_rx_rec_bit:  Reception d'un bit sur RXD                     -> 67 cycles max
         ;    4 - tim1_compa_isr_cpt_1ms:     Comptabilisation de 1 mS                       -> 15 cycles max
         ;
         ;      - Sortie de l'It + gestion de la pulse           -> 28 cycles max
         ;
         ;    => Total si les 4 traitements sont executes dans le meme tick: 28 + 169 + 33 = 230 cycles max
         ;
         ; Registres utilises:
         ;    REG_X_LSB:REG_X_MSB -> Comptabilisation des ticks dans 'G_TICK_1MS'
         ;    REG_TEMP_R16        -> Travail
         ;    REG_TEMP_R17        -> Travail
         ;    REG_PORTB_OUT       -> Image du PORTB
         ;    REG_SAVE_SREG       -> Sauvegarde temporaire de SREG
         ; ---------
          uos_tim1_compa_isr_program:
C:003711 920f      	push		REG_SAVE_SREG
C:003712 b60f      	in			REG_SAVE_SREG, SREG
         
         	; Marquage de l'origine de l'It (Espace PROGRAM)
C:003713 930f      	push		REG_TEMP_R16
C:003714 9100 0500 	lds		REG_TEMP_R16, G_STATES_AT_RESET
C:003716 6004      	sbr		REG_TEMP_R16, FLG_STATE_AT_IT_TIM1_COMPA_PROGRAM_MSK		
C:003717 9300 0500 	sts		G_STATES_AT_RESET, REG_TEMP_R16
C:003719 910f      	pop		REG_TEMP_R16
C:00371a c009      	rjmp		_uos_tim1_compa_isr
         
          _uos_tim1_compa_isr_bootloader:
C:00371b 920f      	push		REG_SAVE_SREG
C:00371c b60f      	in			REG_SAVE_SREG, SREG
         
         	; Marquage de l'origine de l'It (Espace BOOTLOADER)
C:00371d 930f      	push		REG_TEMP_R16
C:00371e 9100 0500 	lds		REG_TEMP_R16, G_STATES_AT_RESET
C:003720 6400      	sbr		REG_TEMP_R16, FLG_STATE_AT_IT_TIM1_COMPA_BOOTLOADER_MSK		
C:003721 9300 0500 	sts		G_STATES_AT_RESET, REG_TEMP_R16
C:003723 910f      	pop		REG_TEMP_R16
         	;rjmp		_uos_tim1_compa_isr
         
          _uos_tim1_compa_isr:
C:003724 937f      	push		REG_TEMP_R23
         
          #if USE_MARK_IN_TIM1_COMPA
         	; Creneau --\_/--- pour indiquer la charge de travail dans l'It
C:003725 9170 050f 	lds		REG_TEMP_R23, UOS_G_PORTB_IMAGE
C:003727 7f77      	cbr		REG_TEMP_R23, MSK_BIT_PULSE_IT
C:003728 9370 050f 	sts		UOS_G_PORTB_IMAGE, REG_TEMP_R23
          #endif
         
C:00372a 9170 050f 	lds		REG_TEMP_R23, UOS_G_PORTB_IMAGE
C:00372c b975      	out		PORTB, REG_TEMP_R23
         
C:00372d 93af      	push		REG_X_LSB
C:00372e 93bf      	push		REG_X_MSB
C:00372f 93ef      	push		REG_Z_LSB
C:003730 93ff      	push		REG_Z_MSB
C:003731 930f      	push		REG_TEMP_R16
C:003732 931f      	push		REG_TEMP_R17
C:003733 932f      	push		REG_TEMP_R18
         
C:003734 df01      	rcall		_uos_delay_5uS		; Travail fictif de 5uS quel que soit l'espace BOOTLOADER ou PROGRAM
         
         	; ---------
         	; Prolongement si le code est execute au RESET depuis l'espace PROGRAM et
         	; si le vecteur commence par l'instruction 'rjmp'
         	; ---------
C:003735 e3f8      	ldi		REG_Z_MSB, high(_uos_callback_tick)	; Execution si possible de l'extension '_uos_tim1_compa_isr'
C:003736 e5ea      	ldi		REG_Z_LSB, low(_uos_callback_tick)	; dans l'espace PROGRAM
C:003737 deea      	rcall		_uos_exec_extension_into_program
         	; ---------
         
         	; ---------
         	; Comptabilisation de 1 mS
         	; ---------
          _uos_tim1_compa_isr_cpt_1ms:
         	; => Si 'FLG_0_PERIODE_1MS' est a 1 (1mS atteinte a la precedente It) => Ne rien faire en attendant
         	;       que 'FLG_0_PERIODE_1MS' passe a 0
         	; => Sinon; si 'G_TICK_1MS' passe a 0 (1mS atteinte) => 'FLG_0_PERIODE_1MS' = 1 => Non maj 'G_TICK_1MS'
         	;    Sinon decrementation et maj 'G_TICK_1MS'
         	;
C:003738 9170 0510 	lds		REG_TEMP_R23, UOS_G_FLAGS_0
C:00373a fd70      	sbrc		REG_TEMP_R23, FLG_0_PERIODE_1MS_IDX
         
C:00373b c00d      	rjmp		_uos_tim1_compa_isr_cpt_1ms_end
         
C:00373c 91a0 0502 	lds		REG_X_LSB, G_TICK_1MS
C:00373e 23aa      	tst		REG_X_LSB										; X ?= 0
C:00373f f431      	brne		_uos_tim1_compa_isr_cpt_1ms_dec
         
C:003740 9170 0510 	lds		REG_TEMP_R23, UOS_G_FLAGS_0
C:003742 6071      	sbr		REG_TEMP_R23, FLG_0_PERIODE_1MS_MSK		; Oui: Set 'FLG_0_PERIODE_1MS'
C:003743 9370 0510 	sts		UOS_G_FLAGS_0, REG_TEMP_R23
         
C:003745 c003      	rjmp		_uos_tim1_compa_isr_cpt_1ms_end			; Fin sans maj de 'G_TICK_1MS'
         
          _uos_tim1_compa_isr_cpt_1ms_dec:
C:003746 50a1      	subi		REG_X_LSB, 1			
C:003747 93a0 0502 	sts		G_TICK_1MS, REG_X_LSB
         
          _uos_tim1_compa_isr_cpt_1ms_end:
         	; Fin: Comptabilisation de 1 mS
         	; ---------
         
         	; Emission d'un byte sur TX
C:003749 9170 0510 	lds		REG_TEMP_R23, UOS_G_FLAGS_0
C:00374b ff74      	sbrs		REG_TEMP_R23, FLG_0_UART_TX_TO_SEND_IDX		; Byte a emettre TXD ?
         
C:00374c c00d      	rjmp		_uos_tim1_compa_isr_end								; Non
         
C:00374d 9110 00c0 	lds		REG_TEMP_R17, UCSR0A								; Caractere en cours d'emission ?
C:00374f ff15      	sbrs		REG_TEMP_R17, UDRE0
C:003750 c009      	rjmp		_uos_tim1_compa_isr_end							; Oui
         
C:003751 9100 0577 	lds		REG_TEMP_R16, G_UART_BYTE_TX
C:003753 9300 00c6 	sts		UDR0, REG_TEMP_R16
         
C:003755 9170 0510 	lds		REG_TEMP_R23, UOS_G_FLAGS_0
C:003757 7e7f      	cbr		REG_TEMP_R23, FLG_0_UART_TX_TO_SEND_MSK		; Pret a lire le FIFO/Tx
C:003758 9370 0510 	sts		UOS_G_FLAGS_0, REG_TEMP_R23
         	; Fin: Emission d'un byte sur TX
         
          _uos_tim1_compa_isr_end:
C:00375a 912f      	pop		REG_TEMP_R18
C:00375b 911f      	pop		REG_TEMP_R17
C:00375c 910f      	pop		REG_TEMP_R16
C:00375d 91ff      	pop		REG_Z_MSB
C:00375e 91ef      	pop		REG_Z_LSB
C:00375f 91bf      	pop		REG_X_MSB
C:003760 91af      	pop		REG_X_LSB
         
          #if USE_MARK_IN_TIM1_COMPA
         	; Fin: Creneau --\_/---
C:003761 9170 050f 	lds		REG_TEMP_R23, UOS_G_PORTB_IMAGE 
C:003763 6078      	sbr		REG_TEMP_R23, MSK_BIT_PULSE_IT
C:003764 9370 050f 	sts		UOS_G_PORTB_IMAGE, REG_TEMP_R23
C:003766 b975      	out		PORTB, REG_TEMP_R23
          #endif
         
C:003767 917f      	pop		REG_TEMP_R23
         
C:003768 be0f      	out		SREG, REG_SAVE_SREG
C:003769 900f      	pop		REG_SAVE_SREG
         
C:00376a 9518      	reti
         ; ---------
         
         ; ---------
         ; Reception d'un byte sur RX
         ; ---------
          uos_usart_rx_complete_isr_program:
C:00376b 920f      	push		REG_SAVE_SREG
C:00376c b60f      	in			REG_SAVE_SREG, SREG
         
         	; Marquage de l'origine de l'It (Espace PROGRAM)
C:00376d 930f      	push		REG_TEMP_R16
C:00376e 9100 0500 	lds		REG_TEMP_R16, G_STATES_AT_RESET
C:003770 6002      	sbr		REG_TEMP_R16, FLG_STATE_AT_IT_UART_COMPLETE_PROGRAM_MSK		
C:003771 9300 0500 	sts		G_STATES_AT_RESET, REG_TEMP_R16
C:003773 910f      	pop		REG_TEMP_R16
C:003774 c009      	rjmp		_uos_usart_rx_complete_isr
         
          _uos_usart_rx_complete_isr_bootloader:
C:003775 920f      	push		REG_SAVE_SREG
C:003776 b60f      	in			REG_SAVE_SREG, SREG
         
         	; Marquage de l'origine de l'It (Espace BOOTLOADER)
C:003777 930f      	push		REG_TEMP_R16
C:003778 9100 0500 	lds		REG_TEMP_R16, G_STATES_AT_RESET
C:00377a 6200      	sbr		REG_TEMP_R16, FLG_STATE_AT_IT_UART_COMPLETE_BOOTLOADER_MSK		
C:00377b 9300 0500 	sts		G_STATES_AT_RESET, REG_TEMP_R16
C:00377d 910f      	pop		REG_TEMP_R16
         	;rjmp		_uos_usart_rx_complete_isr
         
          _uos_usart_rx_complete_isr:
C:00377e 93bf      	push		REG_X_MSB
C:00377f 93af      	push		REG_X_LSB
C:003780 930f      	push		REG_TEMP_R16
C:003781 931f      	push		REG_TEMP_R17
C:003782 932f      	push		REG_TEMP_R18
         
C:003783 9040 00c6 	lds		REG_R5, UDR0		
C:003785 d2b9      	rcall		_uos_uart_fifo_rx_write
         
C:003786 912f      	pop		REG_TEMP_R18
C:003787 911f      	pop		REG_TEMP_R17
C:003788 910f      	pop		REG_TEMP_R16
C:003789 91af      	pop		REG_X_LSB
C:00378a 91bf      	pop		REG_X_MSB
         
C:00378b be0f      	out		SREG, REG_SAVE_SREG
C:00378c 900f      	pop		REG_SAVE_SREG
         
C:00378d 9518      	reti
         ; ---------
         
         ; ---------
         ; Changement d'etat sur PIND<7:4>
         ; ---------
          uos_pcint2_isr_program:
C:00378e 920f      	push		REG_SAVE_SREG
C:00378f b60f      	in			REG_SAVE_SREG, SREG
         
         	; Marquage de l'origine de l'It (Espace PROGRAM)
C:003790 930f      	push		REG_TEMP_R16
C:003791 9100 0500 	lds		REG_TEMP_R16, G_STATES_AT_RESET
C:003793 6001      	sbr		REG_TEMP_R16, FLG_STATE_AT_IT_PCINT2_PROGRAM_MSK		
C:003794 9300 0500 	sts		G_STATES_AT_RESET, REG_TEMP_R16
C:003796 910f      	pop		REG_TEMP_R16
C:003797 c009      	rjmp		_uos_pcint2_isr
         
          _uos_pcint2_isr_bootloader:
C:003798 920f      	push		REG_SAVE_SREG
C:003799 b60f      	in			REG_SAVE_SREG, SREG
         
         	; Marquage de l'origine de l'It (Espace BOOTLOADER)
C:00379a 930f      	push		REG_TEMP_R16
C:00379b 9100 0500 	lds		REG_TEMP_R16, G_STATES_AT_RESET
C:00379d 6100      	sbr		REG_TEMP_R16, FLG_STATE_AT_IT_PCINT2_BOOTLOADER_MSK		
C:00379e 9300 0500 	sts		G_STATES_AT_RESET, REG_TEMP_R16
C:0037a0 910f      	pop		REG_TEMP_R16
         	;rjmp		_uos_pcint2_isr
         
          _uos_pcint2_isr:
C:0037a1 930f      	push		REG_TEMP_R16
C:0037a2 931f      	push		REG_TEMP_R17
C:0037a3 932f      	push		REG_TEMP_R18
C:0037a4 933f      	push		REG_TEMP_R19
C:0037a5 93df      	push		REG_Y_MSB
C:0037a6 93cf      	push		REG_Y_LSB
         
C:0037a7 9100 06be 	lds		REG_TEMP_R16, G_FLAGS_BUTTON
C:0037a9 6001      	sbr		REG_TEMP_R16, FLG_BUTTON_WAIT_DONE_MSK
C:0037aa 9300 06be 	sts		G_FLAGS_BUTTON, REG_TEMP_R16
         
         	; Rearmement a 'DURATION_WAIT_STABILITY' pour effacer les rebonds a l'appui et au relacher
C:0037ac e01b      	ldi		REG_TEMP_R17, TIMER_GEST_BUTTON
C:0037ad e02a      	ldi		REG_TEMP_R18, (DURATION_WAIT_STABILITY % 256)
C:0037ae e030      	ldi		REG_TEMP_R19, (DURATION_WAIT_STABILITY / 256)
C:0037af d1ba      	rcall		uos_restart_timer
         
          _uos_pcint2_isr_end:
C:0037b0 91cf      	pop		REG_Y_LSB
C:0037b1 91df      	pop		REG_Y_MSB
C:0037b2 913f      	pop		REG_TEMP_R19
C:0037b3 912f      	pop		REG_TEMP_R18
C:0037b4 911f      	pop		REG_TEMP_R17
C:0037b5 910f      	pop		REG_TEMP_R16
         
C:0037b6 be0f      	out		SREG, REG_SAVE_SREG
C:0037b7 900f      	pop		REG_SAVE_SREG
         
C:0037b8 9518      	reti
         ; ---------
         
         ; [Padding jusqu'a l'adresse 0x37FF
          .include		"PaddingWith16Bytes.h"
         ; "$Id: PaddingWith16Bytes.h,v 1.5 2026/02/18 18:01:34 administrateur Exp $"
         ; Padding avec 16 bytes...
         
C:0037b9 0000      	nop
C:0037ba 0000      	nop
C:0037bb 0000      	nop
C:0037bc 0000      	nop
C:0037bd 0000      	nop
C:0037be 0000      	nop
C:0037bf 0000      	nop
C:0037c0 0000      	nop
C:0037c1 0000      	nop
C:0037c2 0000      	nop
C:0037c3 0000      	nop
C:0037c4 0000      	nop
C:0037c5 0000      	nop
C:0037c6 0000      	nop
C:0037c7 0000      	nop
C:0037c8 ce1f      	rjmp	_uos_forever
         
         ; End of file
          ; End of file
          .include		"PaddingWith16Bytes.h"
         ; "$Id: PaddingWith16Bytes.h,v 1.5 2026/02/18 18:01:34 administrateur Exp $"
         ; Padding avec 16 bytes...
         
C:0037c9 0000      	nop
C:0037ca 0000      	nop
C:0037cb 0000      	nop
C:0037cc 0000      	nop
C:0037cd 0000      	nop
C:0037ce 0000      	nop
C:0037cf 0000      	nop
C:0037d0 0000      	nop
C:0037d1 0000      	nop
C:0037d2 0000      	nop
C:0037d3 0000      	nop
C:0037d4 0000      	nop
C:0037d5 0000      	nop
C:0037d6 0000      	nop
C:0037d7 0000      	nop
C:0037d8 ce0f      	rjmp	_uos_forever
         
         ; End of file
          ; End of file
          .include		"PaddingWith16Bytes.h"
         ; "$Id: PaddingWith16Bytes.h,v 1.5 2026/02/18 18:01:34 administrateur Exp $"
         ; Padding avec 16 bytes...
         
C:0037d9 0000      	nop
C:0037da 0000      	nop
C:0037db 0000      	nop
C:0037dc 0000      	nop
C:0037dd 0000      	nop
C:0037de 0000      	nop
C:0037df 0000      	nop
C:0037e0 0000      	nop
C:0037e1 0000      	nop
C:0037e2 0000      	nop
C:0037e3 0000      	nop
C:0037e4 0000      	nop
C:0037e5 0000      	nop
C:0037e6 0000      	nop
C:0037e7 0000      	nop
C:0037e8 cdff      	rjmp	_uos_forever
         
         ; End of file
          ; End of file
          .include		"PaddingWith16Bytes.h"
         ; "$Id: PaddingWith16Bytes.h,v 1.5 2026/02/18 18:01:34 administrateur Exp $"
         ; Padding avec 16 bytes...
         
C:0037e9 0000      	nop
C:0037ea 0000      	nop
C:0037eb 0000      	nop
C:0037ec 0000      	nop
C:0037ed 0000      	nop
C:0037ee 0000      	nop
C:0037ef 0000      	nop
C:0037f0 0000      	nop
C:0037f1 0000      	nop
C:0037f2 0000      	nop
C:0037f3 0000      	nop
C:0037f4 0000      	nop
C:0037f5 0000      	nop
C:0037f6 0000      	nop
C:0037f7 0000      	nop
C:0037f8 cdef      	rjmp	_uos_forever
         
         ; End of file
          ; End of file
         
         ; Complement...
C:0037f9 0000      	nop
C:0037fa 0000      	nop
C:0037fb 0000      	nop
C:0037fc 0000      	nop
C:0037fd 0000      	nop
C:0037fe 0000      	nop
         
C:0037ff cde8      	rjmp		_uos_forever		; Mise sur voie de garage ;-)
         ; Fin: Padding jusqu'a l'adresse 0x37FF]
         
         ; Adresses de base des vecteurs d'interruptions avec 'fuses_high' = bxxxxx000
          .org	0x3800 
         
         ; Vecteurs d'interruption dans le cas du fusible BOOTRST = 1
          _uos_reset_bootloader:
         	; => Marquage du numero de l'It en hexadecimal pour faciliter
         	;    la lecture de 'UOS_G_STATES_POST_MORTEM'
         	;    => Origine: 'FLG_WRONG_IT_BOOTLOADER' (Bit<7>)
         	;       Num It:  Bits<0-5>
C:003800 0000      	nop
C:003801 cd87      	rjmp		_uos_main_bootloader								; # 1 RESET
         
C:003802 e012      	ldi		REG_TEMP_R17, 0x02
C:003803 cdf4      	rjmp		_uos_invalid_it_speed							; # 2 INT0
         
C:003804 e013      	ldi		REG_TEMP_R17, 0x03
C:003805 cdf2      	rjmp		_uos_invalid_it_speed							; # 3 INT1
         
C:003806 e014      	ldi		REG_TEMP_R17, 0x04
C:003807 cdf0      	rjmp		_uos_invalid_it_speed							; # 4 PCINT0
         
C:003808 e015      	ldi		REG_TEMP_R17, 0x05
C:003809 cdee      	rjmp		_uos_invalid_it_speed							; # 5 PCINT1
         
C:00380a 0000      	nop
C:00380b cf8c      	rjmp		_uos_pcint2_isr_bootloader						; # 6 PCINT2
         
C:00380c e017      	ldi		REG_TEMP_R17, 0x07
C:00380d cdea      	rjmp		_uos_invalid_it_speed							; # 7 WDT
         
C:00380e e018      	ldi		REG_TEMP_R17, 0x08
C:00380f cde8      	rjmp		_uos_invalid_it_speed							; # 8 TIMER2 COMPA
         
C:003810 e019      	ldi		REG_TEMP_R17, 0x09
C:003811 cde6      	rjmp		_uos_invalid_it_speed							; # 9 TIMER2 COMPB
         
C:003812 e110      	ldi		REG_TEMP_R17, 0x10
C:003813 cde4      	rjmp		_uos_invalid_it_speed							; #10 TIMER2 OVF
         
C:003814 e111      	ldi		REG_TEMP_R17, 0x11
C:003815 cde2      	rjmp		_uos_invalid_it_speed							; #11 TIMER1 CAPT
         
C:003816 0000      	nop
C:003817 cf03      	rjmp		_uos_tim1_compa_isr_bootloader				; #12 TIMER1 COMPA
         
C:003818 e113      	ldi		REG_TEMP_R17, 0x13
C:003819 cdde      	rjmp		_uos_invalid_it_speed							; #13 TIMER1 COMPB
         
C:00381a e114      	ldi		REG_TEMP_R17, 0x14
C:00381b cddc      	rjmp		_uos_invalid_it_speed							; #14 TIMER1 OVF
         
C:00381c e115      	ldi		REG_TEMP_R17, 0x15
C:00381d cdda      	rjmp		_uos_invalid_it_speed							; #15 TIMER0 COMPA
         
C:00381e e116      	ldi		REG_TEMP_R17, 0x16
C:00381f cdd8      	rjmp		_uos_invalid_it_speed							; #16 TIMER0 COMPB
         
C:003820 e117      	ldi		REG_TEMP_R17, 0x17
C:003821 cdd6      	rjmp		_uos_invalid_it_speed							; #17 TIMER0 OVF
         
C:003822 e118      	ldi		REG_TEMP_R17, 0x18
C:003823 cdd4      	rjmp		_uos_invalid_it_speed							; #18 SPI, SPC
         
C:003824 0000      	nop
C:003825 cf4f      	rjmp		_uos_usart_rx_complete_isr_bootloader		; #19 USART, RX
         
C:003826 e210      	ldi		REG_TEMP_R17, 0x20
C:003827 cdd0      	rjmp		_uos_invalid_it_speed							; #20 USART, UDRE
         
C:003828 e211      	ldi		REG_TEMP_R17, 0x21
C:003829 cdce      	rjmp		_uos_invalid_it_speed							; #21 USART, TX
         
C:00382a e212      	ldi		REG_TEMP_R17, 0x22
C:00382b cdcc      	rjmp		_uos_invalid_it_speed							; #22 ADC
         
C:00382c e213      	ldi		REG_TEMP_R17, 0x23
C:00382d cdca      	rjmp		_uos_invalid_it_speed							; #23 EE READY
         
C:00382e e214      	ldi		REG_TEMP_R17, 0x24
C:00382f cdc8      	rjmp		_uos_invalid_it_speed							; #24 ANALOG COMP
         
C:003830 e215      	ldi		REG_TEMP_R17, 0x25
C:003831 cdc6      	rjmp		_uos_invalid_it_speed							; #25 TWI
         
C:003832 e216      	ldi		REG_TEMP_R17, 0x26
C:003833 cdc4      	rjmp		_uos_invalid_it_speed							; #26 SPM READY
         
         ; Reservation 2 bytes pour s'aligner sur le 'main' du Langage C
         ; => TODO: Saut vers '_uos_forever'
C:003834 0000      	nop
C:003835 cdb2      	rjmp      _uos_forever		; Ne sera jamais execute (adresse du 'main()' d'un programme C)
         
         ; ---------
         ; Table des vecteurs d'execution des taches timer codees dans l'espace BOOTLOADER
         ; => Vecteurs d'adesses "mappee" dans l'espace PROGRAM correspondant ;-)
         ; ---------
          _uos_vector_timer_0_program:
         	; Vecteurs des 9 expirations timer disponibles pour les addons
C:003836 940c 39c9 	jmp		_uos_callback_exec_timer_0
C:003838 940c 39ca 	jmp		_uos_callback_exec_timer_1
C:00383a 940c 39cb 	jmp		_uos_callback_exec_timer_2
C:00383c 940c 39cc 	jmp		_uos_callback_exec_timer_3
C:00383e 940c 39cd 	jmp		_uos_callback_exec_timer_4
C:003840 940c 39ce 	jmp		_uos_callback_exec_timer_5
C:003842 940c 39cf 	jmp		_uos_callback_exec_timer_6
C:003844 940c 39d0 	jmp		_uos_callback_exec_timer_7
C:003846 940c 39d1 	jmp		_uos_callback_exec_timer_8
         
         	; Vecteurs des 7 expirations timer utilises par BOOTLOADER
C:003848 940c 39d2 	jmp		_uos_callback_exec_timer_9				; 'TIMER_TEST_LEDS'
C:00384a 940c 39d4 	jmp		_uos_callback_exec_timer_10			; 'TIMER_GEST_BUTTON_LED'
C:00384c 940c 39d5 	jmp		_uos_callback_exec_timer_11			; 'TIMER_GEST_BUTTON'
C:00384e 940c 39d6 	jmp		_uos_callback_exec_timer_12			; 'TIMER_GEST_BUTTON_ACQ'
C:003850 940c 39d7 	jmp		_uos_callback_exec_timer_13			; 'TIMER_ERROR'
C:003852 940c 39e9 	jmp		_uos_callback_exec_timer_14			; 'TIMER_LED_GREEN'
C:003854 940c 3a29 	jmp		_uos_callback_exec_timer_15			; 'TIMER_CONNECT'
         
         ; ---------
         ; Table des 5 vecteurs d'execution defini sur 2 mots d'instructionen prolongement
         ; de celui de l'espace BOOTLOADER
         ; => Terminaison de la 1st page de 64 mots pour la programmation interne au moyen
         ;    l'instruction 'stm'
         ; ---------
          _uos_callback_init:
C:003856 0000      	nop
C:003857 cd90      	rjmp		_uos_forever	; Ne sera jamais execute (prolongement en 'callback_init')
         
          _uos_callback_background:
C:003858 0000      	nop
C:003859 cd8e      	rjmp		_uos_forever	; Ne sera jamais execute (prolongement en 'callback_background')
         
          _uos_callback_tick:
C:00385a 0000      	nop
C:00385b cd8c      	rjmp		_uos_forever	; Ne sera jamais execute (prolongement en 'callbackaddon_tick')
         
          _uos_callback_1_ms:
C:00385c 0000      	nop
C:00385d cd8a      	rjmp		_uos_forever	; Ne sera jamais execute (prolongement en 'callbackaddon_1_ms')
         
          _uos_callback_gest_buttons:
C:00385e 0000      	nop
C:00385f cd88      	rjmp		_uos_forever	; Ne sera jamais execute (prolongement en 'callbackaddon_gest_buttons')
         
          _uos_callback_command:
C:003860 0000      	nop
C:003861 cd86      	rjmp		_uos_forever	; Ne sera jamais execute (prolongement en 'callback_command')
         ; ---------
         
         ; ---------
         ; Fonctionnalites dans un fichier a part
         ; => Aucune contrainte sur l'ordre d'inclusion
         ;    => Si ordre different ou ajout de fonctionnalites,  certains branchements (rjump/jump) ou
         ;       appel aux subroutines (rcall/call) devront etre adaptes (suppression erreur ou warning)
         ;    => A noter que le fichier 'ATmega328P_uOS_Commands.asm' implemente les routines d'ecriture
         ;       dans la FLASH qui doivent etre definies dans l'espace de demarrage de uOS (0x3800-0x3FFF)
         ;       => En particulier la routine '_uos_do_spm' doit etre dans l'espace de demarrage
          .include		"ATmega328P_uOS_Misc.asm"
         ; "$Id: ATmega328P_uOS_Misc.asm,v 1.6 2026/02/18 18:01:34 administrateur Exp $"
         
         ; ---------
         ; Initialisation de la SRAM
         ; - Pas d'initialisation des 2 derniers bytes (retour de la fonction)
         ;
         ; Registres utilises (non sauvegardes/restaures):
         ;    REG_TEMP_R16 -> Valeur d'initialisation de la SRAM
         ; ---------
          _uos_init_sram_fill:
C:003862 ef0f      	ldi		REG_TEMP_R16, 0xff
C:003863 e0b8      	ldi		REG_X_MSB, high(RAMEND - 2)
C:003864 efad      	ldi		REG_X_LSB, low(RAMEND - 2)
         
          _uos_init_sram_fill_loop_a:
         	; Initialisation a 0xff de la STACK
         	; => Permet de connaitre la profondeur maximale de la pile d'appel
C:003865 930c      	st			X, REG_TEMP_R16
C:003866 9711      	sbiw		REG_X_LSB, 1
C:003867 30b7      	cpi		REG_X_MSB, high(UOS_G_SRAM_BOOTLOADER_END_OF_USE)
C:003868 f7e1      	brne		_uos_init_sram_fill_loop_a
C:003869 34ad      	cpi		REG_X_LSB, low(UOS_G_SRAM_BOOTLOADER_END_OF_USE - 1)	
C:00386a f7d1      	brne		_uos_init_sram_fill_loop_a
         
C:00386b 2700      	clr		REG_TEMP_R16
         
         	; Initialisation a 0x00 du reste de la SRAM
         	; => Permet de connaitre la profondeur de la pile d'appel
          _uos_init_sram_fill_loop_b:
C:00386c 930c      	st			X, REG_TEMP_R16
C:00386d 9711      	sbiw		REG_X_LSB, 1
         
         	; Non RAZ des positions 'G_STATES_AT_RESET' (0x100) et 'UOS_G_STATES_POST_MORTEM' (0x101)
         	; => Arret si la position ('UOS_G_STATES_POST_MORTEM' + 1) est atteinte
C:00386e 30b5      	cpi		REG_X_MSB, high(UOS_G_STATES_POST_MORTEM + 1)
C:00386f f7e1      	brne		_uos_init_sram_fill_loop_b
C:003870 30a2      	cpi		REG_X_LSB, low(UOS_G_STATES_POST_MORTEM + 1)
C:003871 f7d1      	brne		_uos_init_sram_fill_loop_b
         
         	; Fin initialisation [SRAM_START, ..., (RAMEND - 2)]
C:003872 9508      	ret
         ; ---------
         
         ; ---------
         ; Initialisation de valeurs particulieres dans la SRAM
         ;
         ; Variables initialisees:
         ; - G_TICK_1MS -> Periode pour 1mS du Cadencement It
         ;
         ; Registres utilises (non sauvegardes/restaures):
         ;    REG_TEMP_R16
         ; ---------
          _uos_init_sram_values:
         	; Raz des 2 bytes REG_FLAGS_0 et REG_FLAGS_1
C:003873 2777      	clr      REG_TEMP_R23
C:003874 9370 0510    sts      UOS_G_FLAGS_0, REG_TEMP_R23
C:003876 9370 0511    sts      UOS_G_FLAGS_1, REG_TEMP_R23
         
         	; Initialisation periode de 1mS @ Cadencement It
                 ; Ajustement a 100 uS exactement (Prise en compte de la mS a l'It suivante ;-)
                 ; => Constate par simulation avec 'avrsimu' ;-))
C:003878 e009      	ldi		REG_TEMP_R16, (PERIODE_1MS - 1)
C:003879 9300 0503 	sts		G_TICK_1MS_INIT, REG_TEMP_R16
C:00387b 9300 0502 	sts		G_TICK_1MS, REG_TEMP_R16
         
C:00387d 9508      	ret
         ; ---------
         
         ; ---------
          _uos_init_hard:
            ; Lecture du fusible 'LOW' pour determiner 8/16 MHz
C:00387e e009         ldi      REG_TEMP_R16, (1 << BLBSET) | (1 << SELFPRGEN)
C:00387f bf07         out      SPMCSR, REG_TEMP_R16
         
C:003880 e0f0         ldi      REG_Z_MSB, 0x00
C:003881 e0e0         ldi      REG_Z_LSB, 0x00
C:003882 9104         lpm      REG_TEMP_R16, Z
         
C:003883 700f         andi     REG_TEMP_R16, 0x0F
C:003884 3002         cpi      REG_TEMP_R16, (1 << CKSEL1)
C:003885 f429         brne     _uos_init_hard_no_rc_osc_8mhz
         
C:003886 9170 0510 	lds		REG_TEMP_R23, UOS_G_FLAGS_0
C:003888 6870      	sbr		REG_TEMP_R23, FLG_0_RC_OSC_8MHZ_MSK
C:003889 9370 0510 	sts		UOS_G_FLAGS_0, REG_TEMP_R23
         
          _uos_init_hard_no_rc_osc_8mhz:
            ; Fin: Lecture du fusible 'LOW' pour determiner 8/16 MHz
         
         	; Cadencement a xxx uS
         	; TCCR1A/B: Timer/Counter1 Control Register A/B
C:00388b 2700      	clr		REG_TEMP_R16
C:00388c 9300 0080 	sts		TCCR1A, REG_TEMP_R16
C:00388e 9300 0081 	sts		TCCR1B, REG_TEMP_R16
         
         	; TCNT1H/L: Timer/Counter1
C:003890 e000      	ldi		REG_TEMP_R16, 0	
C:003891 9300 0085 	sts		TCNT1H, REG_TEMP_R16
C:003893 9300 0084 	sts		TCNT1L, REG_TEMP_R16
         
         	; OCR1A: Avec un ATmega328p cadence a 16MHz (1 Cycle = 62 nS):
         	; o  1600 and (CLK_IO / 1):  (16000000 / 1600)       = 10000 (10 kHz) => 100 uS
         	; o 16000 and (CLK_IO / 1):  (16000000 / 16000)      =  1000 ( 1 kHz) =>   1 mS
         	; o 31250 and (CLK_IO / 64): (16000000 / 31250 / 64) =     8 ( 8  Hz) => 125 mS (TBC)
         
            ; A priori 16 MHz ...
C:003895 e006      	ldi		REG_TEMP_R16, (1600 / 256)
C:003896 e410      	ldi		REG_TEMP_R17, (1600 % 256)
         
C:003897 ff77         sbrs     REG_TEMP_R23, FLG_0_RC_OSC_8MHZ_IDX
C:003898 c002         rjmp     _uos_init_hard_ocr1a_init
         
            ; ... et non -> 8 MHz
C:003899 e003      	ldi		REG_TEMP_R16, (800 / 256)
C:00389a e210      	ldi		REG_TEMP_R17, (800 % 256)
         
          _uos_init_hard_ocr1a_init:
C:00389b 9300 0089 	sts		OCR1AH, REG_TEMP_R16
C:00389d 9310 0088 	sts		OCR1AL, REG_TEMP_R17
         
         	; TCCR1B: Timer/Counter1 Control Register B
         	; - WGM12: 1: CTC mode
         	; - CS12 CS11 CS10:
         	;      0    0    0: No clock source
         	;      0    0    1: CLK_IO / 1
         	;      0    1    0: CLK_IO / 8
         	;      0    1    1: CLK_IO / 64
         	;      1    0    0: CLK_IO / 256
         	;      1    0    1: CLK_IO / 1024
         	;      1    1    0: External clock source on T1 pin. Clock on falling edge.
         	;      1    1    1: External clock source on T1 pin. Clock on rising edge.
         
C:00389f e009      	ldi		REG_TEMP_R16, (1 << WGM12) | (1 << CS10)
C:0038a0 9300 0081 	sts		TCCR1B, REG_TEMP_R16
         
         	; TIMSK1: Timer/Counter Interrupt Mask Register
         	; - OCIE1A: Timer/Counter1 Output Compare Interrupt Enable
C:0038a2 e002      	ldi		REG_TEMP_R16, (1 << OCIE1A)
C:0038a3 9300 006f 	sts		TIMSK1, REG_TEMP_R16
         	; Fin: Cadencement a xxx uS
         
         	; Initialisation de l'UART
                 ; Valeurs de programmation pour:
                 ; - 4800 bauds: 208
                 ; - 9600 bauds: 104
                 ; - 19200 bauds: 52
         	; Set baud rate (9600 bauds by default)
C:0038a5 e000      	ldi		REG_TEMP_R16, 0
C:0038a6 e618      	ldi		REG_TEMP_R17, 104     ; Valeur a 16 MHz
         
C:0038a7 fd77         sbrc     REG_TEMP_R23, FLG_0_RC_OSC_8MHZ_IDX
C:0038a8 e314      	ldi		REG_TEMP_R17, 52     ; Valeur a 8 MHz
         
         	; Lecture de l'EEPROM @ TODO pour fixer la vitesse de l'UART...
         	; => 'UBRR0H:UBRR0L' maj dans 'read_bauds_rate_from_eeprom' en
         	;    remplacement des valeur ecrites si la valeur de l'index du
         	;    'bauds rate' est supportee ;-)
C:0038a9 9300 00c5 	sts		UBRR0H, REG_TEMP_R16
C:0038ab 9310 00c4 	sts		UBRR0L, REG_TEMP_R17
         
C:0038ad d5f1      	rcall		read_and_set_bauds_rate_from_eeprom
         
         	; Enable receiver and transmitter + Rx interrupt
C:0038ae e908      	ldi		REG_TEMP_R16, (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0)
         	;ldi		REG_TEMP_R16, (1 << RXEN0) | (1 << TXEN0)
C:0038af 9300 00c1 	sts		UCSR0B, REG_TEMP_R16
         
         	; Set frame format: Asynchronous, 8 bits data, 2 bits stop and no parity
C:0038b1 e00e      	ldi		REG_TEMP_R16, (1 << USBS0) | (1 << UCSZ01) | (1 << UCSZ00)
C:0038b2 9300 00c2 	sts		UCSR0C, REG_TEMP_R16
         	; Fin: Initialisation de l'UART
         
         	; Initialisation pour la gestion des 4 boutons sur PORTD<7:4>
C:0038b4 e004      	ldi		REG_TEMP_R16, (1 << PCIE2)
C:0038b5 9300 0068 	sts		PCICR, REG_TEMP_R16
         
C:0038b7 ef00      	ldi		REG_TEMP_R16, (1 << PCINT20) | (1 << PCINT21) | (1 << PCINT22) | (1 << PCINT23)
C:0038b8 9300 006d 	sts		PCMSK2, REG_TEMP_R16
         	; Fin: Initialisation pour la gestion des 4 boutons
         
            ; Configuration des PULLUP sur PORTD<7:4>
C:0038ba ef00      	ldi		REG_TEMP_R16, 0xF0
C:0038bb b90b      	out		PORTD, REG_TEMP_R16
         
C:0038bc 9508      	ret
         ; ---------
         
         ; ---------
         ; Test si execution dans l'espace PROGRAM
         ;
         ; Retour:
         ;   - Z = 1 (false): Non: Execution dans l'espace BOOTLOADER
         ;   - Z = 0 (true) : Oui: Execution dans l'espace PROGRAM
         ;
         ; Utilisation:
         ;   [r]call   _uos_if_execution_into_zone_program
         ;   breq      <execution_dans_l_espace_bootloader>
         ;
         ;   [r]call   _uos_if_execution_into_zone_program
         ;   brne      <execution_dans_l_espace_programme>
         ;
         ; ---------
          _uos_if_execution_into_zone_program:
C:0038bd 931f      	push		REG_TEMP_R17
C:0038be 9110 0500 	lds		REG_TEMP_R17, G_STATES_AT_RESET
C:0038c0 7414      	andi		REG_TEMP_R17, (FLG_STATE_AT_IT_TIM1_COMPA_BOOTLOADER_MSK | FLG_STATE_AT_IT_TIM1_COMPA_PROGRAM_MSK)
C:0038c1 3410      	cpi		REG_TEMP_R17, FLG_STATE_AT_IT_TIM1_COMPA_BOOTLOADER_MSK
C:0038c2 911f      	pop		REG_TEMP_R17
         
C:0038c3 9508      	ret
         ; ---------
         
         ; ---------
         ; Test si execution dans l'espace BOOTLOADER
         ;
         ; Retour:
         ;   - Z = 1 (false): Non: Execution dans l'espace PROGRAM
         ;   - Z = 0 (true) : Oui: Execution dans l'espace BOOTLOADER
         ;
         ; Utilisation:
         ;   [r]call   _uos_if_execution_into_zone_bootloader
         ;   breq      <execution_dans_l_espace_programme>
         ;
         ;   [r]call   _uos_if_execution_into_zone_program
         ;   brne      <execution_dans_l_espace_bootloader>
         ;
         ; ---------
          _uos_if_execution_into_zone_bootloader:
C:0038c4 931f      	push		REG_TEMP_R17
C:0038c5 9110 0500 	lds		REG_TEMP_R17, G_STATES_AT_RESET
C:0038c7 7414      	andi		REG_TEMP_R17, (FLG_STATE_AT_IT_TIM1_COMPA_BOOTLOADER_MSK | FLG_STATE_AT_IT_TIM1_COMPA_PROGRAM_MSK)
C:0038c8 3014      	cpi		REG_TEMP_R17, FLG_STATE_AT_IT_TIM1_COMPA_PROGRAM_MSK
C:0038c9 911f      	pop		REG_TEMP_R17
         
C:0038ca 9508      	ret
         ; ---------
         
         ; ---------
          _uos_presentation_connexion:
C:0038cb 9170 0511 	lds		REG_TEMP_R23, UOS_G_FLAGS_1
C:0038cd ff70      	sbrs		REG_TEMP_R23, FLG_1_UART_FIFO_RX_NOT_EMPTY_IDX
         
C:0038ce c010      	rjmp		_uos_presentation_connexion_rtn
         
          _uos_presentation_connexion_fifo_rx_not_empty:
         	; FIFO/Rx non vide
         	; Test si 'Non Connecte' ?
         	; => Si Oui: Changement chenillard
C:0038cf 9100 0512 	lds		REG_TEMP_R16, UOS_G_FLAGS_2
C:0038d1 fd00      	sbrc		REG_TEMP_R16, FLG_2_CONNECTED_IDX
C:0038d2 c005      	rjmp		_uos_presentation_connexion_reinit_timer
         
         	; Changement chenillard
C:0038d3 ef0e      	ldi		REG_TEMP_R16, CHENILLARD_CONNECTED
C:0038d4 9300 0507 	sts		G_CHENILLARD_MSB, REG_TEMP_R16
C:0038d6 9300 0508 	sts		G_CHENILLARD_LSB, REG_TEMP_R16
         
          _uos_presentation_connexion_reinit_timer:
         	; Reinitialisation timer 'TIMER_CONNECT'
C:0038d8 e01f      	ldi		REG_TEMP_R17, TIMER_CONNECT
C:0038d9 eb28      	ldi		REG_TEMP_R18, (3000 % 256)
C:0038da e03b      	ldi		REG_TEMP_R19, (3000 / 256)
C:0038db d08e      	rcall		uos_restart_timer
         
         	; Passage en mode 'Connecte' pour une presentation Led GREEN --\__/-----
C:0038dc 9100 0512 	lds		REG_TEMP_R16, UOS_G_FLAGS_2
C:0038de 6001      	sbr		REG_TEMP_R16, FLG_2_CONNECTED_MSK
         	;rjmp		_uos_presentation_connexion_rtn
         
         	; Fin: Passage en mode 'Non Connecte' a l'expiration du timer 'TIMER_CONNECT'
         
          _uos_presentation_connexion_rtn:
C:0038df 9508      	ret
         ; ---------
         
         ; ---------
         ; Allumage fugitif Led RED Externe si erreur
         ; => L'effacement des 2 'FLG_0_UART_RX_BYTE_START_ERROR' et 'FLG_0_UART_RX_BYTE_STOP_ERROR'
         ;    est effectue sur la reception d'un nouveau caratere sans erreur ;-)
         ;    => L'allumage peut durer au dela de la valeur d'initialisation du timer 'TIMER_ERROR'
         ;       et donc ne pas presenter d'autres erreurs a definir
         ;       => Choix: Effacement sur time-out de 'TIMER_CONNECT'
         ;
         ; => L'effacement des 2 'FLG_1_UART_FIFO_RX_FULL' et 'FLG_1_UART_FIFO_TX_FULL'
         ;    est effectue des lors que la FIFO/Rx ou Tx n'est plus "vue" comme pleine
         ;    => Des carateres peuvent avoir ete perdus dans l'empilement dans la FIFO
         ;
          _uos_presentation_error:
C:0038e0 9170 0511 	lds		REG_TEMP_R23, UOS_G_FLAGS_1
C:0038e2 fd71      	sbrc		REG_TEMP_R23, FLG_1_UART_FIFO_RX_FULL_IDX
C:0038e3 c00b      	rjmp		_uos_presentation_error_reinit
         
C:0038e4 9100 06c4 	lds		REG_TEMP_R16, UOS_G_TEST_FLAGS			; Prise des flags 'UOS_G_TEST_FLAGS'
         
C:0038e6 fd04      	sbrc		REG_TEMP_R16, FLG_TEST_COMMAND_ERROR_IDX
C:0038e7 c007      	rjmp		_uos_presentation_error_reinit
         
C:0038e8 fd07      	sbrc		REG_TEMP_R16, FLG_TEST_CONFIG_ERROR_IDX
C:0038e9 c005      	rjmp		_uos_presentation_error_reinit
         
C:0038ea fd05      	sbrc		REG_TEMP_R16, FLG_TEST_PROGRAMING_ERROR_IDX
C:0038eb c003      	rjmp		_uos_presentation_error_reinit
         
C:0038ec fd06      	sbrc		REG_TEMP_R16, FLG_TEST_EEPROM_ERROR_IDX
C:0038ed c001      	rjmp		_uos_presentation_error_reinit
         
C:0038ee c01b      	rjmp		_uos_presentation_error_rtn
         
          _uos_presentation_error_reinit:
         	; Reinitialisation timer 'TIMER_ERROR' tant que erreur(s) presente(s)
C:0038ef e01d      	ldi		REG_TEMP_R17, TIMER_ERROR
C:0038f0 ec28      	ldi		REG_TEMP_R18, (200 % 256)
C:0038f1 e030      	ldi		REG_TEMP_R19, (200 / 256)
C:0038f2 d077      	rcall		uos_restart_timer
         
         	; Effacement de certaines erreurs non fugitives
C:0038f3 9100 06c4 	lds		REG_TEMP_R16, UOS_G_TEST_FLAGS 
C:0038f5 7e0f      	cbr		REG_TEMP_R16, FLG_TEST_COMMAND_ERROR_MSK
C:0038f6 770f      	cbr		REG_TEMP_R16, FLG_TEST_CONFIG_ERROR_MSK
C:0038f7 9300 06c4 	sts		UOS_G_TEST_FLAGS, REG_TEMP_R16
         
C:0038f9 94f8      	cli
         
         	; Pas de changement de l'etat Led si "Test Leds en cours"
C:0038fa 9100 0513 	lds		REG_TEMP_R16, UOS_G_GESTION_TEST_LEDS
C:0038fc fd07      	sbrc		REG_TEMP_R16, FLG_GESTION_TEST_LEDS_IDX
C:0038fd c00b      	rjmp		_uos_presentation_error_more
         
C:0038fe   +  	setLedRedOn
C:0038fe 9170 0511 lds		REG_TEMP_R23, UOS_G_FLAGS_1
C:003900 6870      sbr		REG_TEMP_R23, UOS_FLG_1_LED_RED_ON_MSK	

C:003901 9370 0511 sts		UOS_G_FLAGS_1, REG_TEMP_R23
         
C:003903 9170 050f lds		REG_TEMP_R23, UOS_G_PORTB_IMAGE
C:003905 7f7d      cbr		REG_TEMP_R23, UOS_MSK_BIT_LED_RED	
C:003906 9370 050f sts		UOS_G_PORTB_IMAGE, REG_TEMP_R23
C:003908 b975      out		PORTB, REG_TEMP_R23					

         
          _uos_presentation_error_more:
C:003909 9478      	sei
         
          _uos_presentation_error_rtn:
C:00390a 9508      	ret
         ; ---------
         
         ; ---------
         ; Affirmation de l'erreur a acquiter maj depuis 'C' defini
         ;
         ; Usage:
         ;    call  uos_set_error
         ; ---------
          uos_set_error:
C:00390b 9180 050e 	lds		REG_TEMP_R24, G_TEST_ERROR	; Reprise de l'erreur
C:00390d 6880      	sbr		REG_TEMP_R24, FLG_TEST_ERR_EXTERNAL_MSK	; Caracteres mis en FIFO a emettre ;-)
         
C:00390e 9380 050e 	sts		G_TEST_ERROR, REG_TEMP_R24	; Update de l'erreur
C:003910 9508      	ret
         ; ---------
         
         ; End of file
          ; End of file
          .include		"ATmega328P_uOS_Timers.asm"
         ; "$Id: ATmega328P_uOS_Timers.asm,v 1.5 2026/02/18 18:01:34 administrateur Exp $"
         
          #include "ATmega328P_uOS_Timers.h"
         ; "$Id: ATmega328P_uOS_Timers.h,v 1.3 2026/02/18 18:01:34 administrateur Exp $"
         
         ; Attribution des 'NBR_TIMER' timers #0, #1, ..., #7
         ; => Le traitement associe a chaque timer est effectue dans l'ordre de son index
          #define	NBR_TIMER							16
         
         ; 10 Timers destines au PROGRAM
          #define	TIMER_SPARE_0						0		; Reserve
          #define	TIMER_SPARE_1						1		; Reserve
          #define	TIMER_SPARE_2						2		; Reserve
          #define	TIMER_SPARE_3						3		; Reserve
          #define	TIMER_SPARE_4						4		; Reserve
          #define	TIMER_SPARE_5						5		; Reserve
          #define	TIMER_SPARE_6						6		; Reserve
          #define	TIMER_SPARE_7						7		; Reserve
          #define	TIMER_SPARE_8						8		; Reserve
         
         ; 7 Timers utilises par le BOOTLOADER
          #define	TIMER_TEST_LEDS					9		; Timer pour le test Leds
          #define	TIMER_GEST_BUTTON_LED			10		; Timer pour la presentation des appuis valides des boutons
          #define	TIMER_GEST_BUTTON					11		; Timer pour la gestion des boutons (anti-rebonds et prise en compte)
          #define	TIMER_GEST_BUTTON_ACQ			12		; Timer pour la mise a disposition du bouton appuye
          #define	TIMER_ERROR							13		; Timer pour la presentation des erreurs (Led RED)
          #define	TIMER_LED_GREEN					14		; Timer pour la presentation de l'etat Connecte/Non connecte
          #define	TIMER_CONNECT						15		; Timer pour les connexions/deconnexions (reception sur RX)
         
          #define	PERIODE_1MS							10		; Comptabilisation de 1mS -> Gestion des timers
         
          .dseg
         
         ; Valeurs sur 16 bits des 'NBR_TIMER' accedees par indexation @ 'G_TIMER_0'
D:000535    G_TIMER_0:						.byte		2		; 2 bytes pour la duree
D:000537    G_TIMER_SPACE:					.byte		2 * (NBR_TIMER - 1)
         
         ; Contextes sur 16 bits des 'NBR_TIMER' accedees par indexation @ 'G_TIMER_CONTEXT_0'
D:000555    G_TIMER_CONTEXT_0:			.byte		2		; 2 bytes pour le contexte
D:000557    G_TIMER_CONTEXT_SPACE_0:	.byte		2 * (NBR_TIMER - 1)
         
         ; End of file
         
          
         
          .cseg
         
         ; ---------
         ; Gestion des timers
         ; ---------
          _uos_gestion_timer:
         	; Comptabilisation dans tous les timers armes
C:003911 2700      	clr		REG_TEMP_R16
         
C:003912 e3e6      	ldi		REG_Z_LSB, (_uos_vector_timer_0_program % 256)	; Table des vecteurs d'execution des taches timer
C:003913 e3f8      	ldi		REG_Z_MSB, (_uos_vector_timer_0_program / 256)
C:003914 e3c5      	ldi		REG_Y_LSB, (G_TIMER_0 % 256)				; Table des valeurs sur 16 bits des timers
C:003915 e0d5      	ldi		REG_Y_MSB, (G_TIMER_0 / 256)	
         
          _uos_gestion_timer_loop:
C:003916 81a8      	ldd		REG_X_LSB, Y+0					; X = Duree du Timer #N
C:003917 81b9      	ldd		REG_X_MSB, Y+1
C:003918 9610      	adiw		REG_X_LSB, 0					; Duree ?= 0
C:003919 f1a1      	breq		_uos_gestion_timer_next		; Passage au prochain timer si duree a 0
         
          _uos_gestion_timer_decrement:
         	; Le Timer #N est arme et non expire => Decrementation sur 16 bits et mise a jour duree
C:00391a 9711      	sbiw		REG_X_LSB, 1
         
C:00391b 83a8      	std		Y+0, REG_X_LSB
C:00391c 83b9      	std		Y+1, REG_X_MSB
         
C:00391d f581      	brne		_uos_gestion_timer_next
         
         	; Pas d'execution de la tache associee dans l'espace PROGRAM si RESET dans l'espace BOOTLOADER
         	; => Protection lors du telechargement d'un code dans l'espace PROGRAM
C:00391e df9e      	rcall		_uos_if_execution_into_zone_program
C:00391f f0f9      	breq		_uos_gestion_timer_in_bootloader_space_more		; Saut si "pas dans l'espace PROGRAM"
         
         	; Sauvegarde du contexte
C:003920 930f      	push		REG_TEMP_R16
C:003921 93ef      	push		REG_Z_LSB
C:003922 93ff      	push		REG_Z_MSB
C:003923 93cf      	push		REG_Y_LSB
C:003924 93df      	push		REG_Y_MSB
C:003925 93af      	push		REG_X_LSB
C:003926 93bf      	push		REG_X_MSB
         
         	; Timer #N expire => Execution de la tache associee dans l'espace PROGRAM
          _uos_gestion_timer_in_program_space:
         
         	; Determination de l'addresse du vecteur correspondant dans l'espace PROGRAM
C:003927 e3b8      	ldi		REG_X_MSB, high(_uos_reset_bootloader)
C:003928 e0a0      	ldi		REG_X_LSB, low(_uos_reset_bootloader)
C:003929 1bea      	sub		REG_Z_LSB, REG_X_LSB
C:00392a 0bfb      	sbc		REG_Z_MSB, REG_X_MSB
         
C:00392b 01df      	movw		REG_X_LSB, REG_Z_LSB		; Sauvegarde de l'adresse du vecteur dans l'espace PROGRAM
         
         	; Lecture de l'opcode @ 'Z' pour savoir si le chainage est valide
         	; => Presence d'un 'rjmp' a un traitement (attendu) se terminant par un 'ret' (non teste)
C:00392c 0fee      	lsl		REG_Z_LSB
C:00392d 1fff      	rol		REG_Z_MSB
C:00392e 9105      	lpm		REG_TEMP_R16, Z+
C:00392f 9114      	lpm		REG_TEMP_R17, Z
         
         	; Test si 'jmp' (1001 010k kkkk 110k -> 0x940C apres masque des 'k'))
C:003930 7914      	andi		REG_TEMP_R17, 0x94
C:003931 3914      	cpi		REG_TEMP_R17, 0x94
C:003932 f429      	brne		_uos_gestion_timer_in_bootloader_space
         
C:003933 700c      	andi		REG_TEMP_R16, 0x0C
C:003934 300c      	cpi		REG_TEMP_R16, 0x0C
C:003935 f411      	brne		_uos_gestion_timer_in_bootloader_space
         
          _uos_gestion_timer_exec_in_program_space:
         	; Execution de la tache timer dans l'espace PROGRAM (avant celle de BOOTLOADER)
C:003936 01fd      	movw		REG_Z_LSB, REG_X_LSB		; Reprise de l'adresse du vecteur dans l'espace PROGRAM
C:003937 9509      	icall
         
         	; Timer #N expire => Execution de la tache associee dans l'espace BOOTLOADER
          _uos_gestion_timer_in_bootloader_space:
         
         	; Restauration du contexte d'avant la determination de l'addresse du vecteur
         	; correspondant dans l'espace PROGRAM
C:003938 91bf      	pop		REG_X_MSB
C:003939 91af      	pop		REG_X_LSB
C:00393a 91df      	pop		REG_Y_MSB
C:00393b 91cf      	pop		REG_Y_LSB
C:00393c 91ff      	pop		REG_Z_MSB
C:00393d 91ef      	pop		REG_Z_LSB
C:00393e 910f      	pop		REG_TEMP_R16
         
          _uos_gestion_timer_in_bootloader_space_more:
         	; Sauvegarde du contexte
C:00393f 930f      	push		REG_TEMP_R16
C:003940 93ef      	push		REG_Z_LSB
C:003941 93ff      	push		REG_Z_MSB
C:003942 93cf      	push		REG_Y_LSB
C:003943 93df      	push		REG_Y_MSB
C:003944 93af      	push		REG_X_LSB
C:003945 93bf      	push		REG_X_MSB
         
         	; Execution de la tache timer dans l'espace BOOTLOADER (avant celle de PROGRAM)
          _uos_gestion_timer_exec_in_bootloader_space:
C:003946 9509      	icall
         
         	; Restauration du contexte
C:003947 91bf      	pop		REG_X_MSB
C:003948 91af      	pop		REG_X_LSB
C:003949 91df      	pop		REG_Y_MSB
C:00394a 91cf      	pop		REG_Y_LSB
C:00394b 91ff      	pop		REG_Z_MSB
C:00394c 91ef      	pop		REG_Z_LSB
C:00394d 910f      	pop		REG_TEMP_R16
         
          _uos_gestion_timer_next:
         	; Passage au prochain timer
C:00394e 9632      	adiw		REG_Z_LSB, 2					; Adresse du traitement associe au prochain timer
C:00394f 9622      	adiw		REG_Y_LSB, 2					; Acces au prochain timer de 16 bits SANS contexte
         
C:003950 9503      	inc		REG_TEMP_R16					; +1 dans le compteur de timer
C:003951 3100      	cpi		REG_TEMP_R16, NBR_TIMER		; Tous les timer sont maj [#0, #1, #(NBR_TIMER - 1)] ?
C:003952 f009      	breq		_uos_gestion_timer_rtn		; TODO: Gain d'une instruction avec 'brxxx'
         
C:003953 cfc2      	rjmp		_uos_gestion_timer_loop
         
          _uos_gestion_timer_rtn:
C:003954 9508      	ret
         ; ---------
         
         ; ---------
         ; Armement d'un timer #N avec une duree sur 16 bits
         ; => La duree est ajoutee a celle restante permettant ainsi un rearmement
         ;    avant l'expiration a l'image d'un watchdog
         ;    => Warning: le timer peut ne jamais expirer si plusieurs armement sans un 'uos_stop_timer'
         ;                car la duree est augmentee a chaque armement
         ; Usage:
         ;      ldi        REG_TEMP_R17, <timer_num>         ; Num in range [0, 1, ..., (NBR_TIMER-1)]
         ;      ldi			REG_TEMP_R18, <timer_value_lsb>   ; LSB value
         ;      ldi			REG_TEMP_R19, <timer_value_msb>   ; MSB value
         ;      rcall      uos_start_timer
         ;
         ; Registres utilises (non sauvegardes/restaures):
         ;    REG_Y_LSB:REG_Y_MSB -> Indexation du timer #N
         ;    REG_TEMP_R16        -> Registre de travail
         ;    REG_TEMP_R17        -> Num timer #N (1st argument inchange apres execution)
         ;    REG_TEMP_R18        -> Duration LSB (2nd argument)
         ;    REG_TEMP_R19        -> Duration MSB (3rd argument)
         ;    REG_TEMP_R20        -> Duration LSB restante avant ajout (duree totale apres ajout)
         ;    REG_TEMP_R21        -> Duration MSB restante avant ajout (duree totale apres ajout)
         ; ---------
          uos_start_timer:
C:003955 3110      	cpi		REG_TEMP_R17, NBR_TIMER		; N dans la plage [0, 1, ..., (NBR_TIMER-1)] ?
C:003956 f468      	brcc		_uos_start_timer_err				; Saut si REG_TEMP_R17 >= NBR_TIMER ?
         
C:003957 e3c5      	ldi		REG_Y_LSB, (G_TIMER_0 % 256)	; Non: Adresse de base des timers
C:003958 e0d5      	ldi		REG_Y_MSB, (G_TIMER_0 / 256)
         
C:003959 0f11      	lsl		REG_TEMP_R17						; REG_TEMP_R17 *= 2 (Adresse sur des mots de 16 bits)
         
C:00395a 2700      	clr		REG_TEMP_R16						; Indexation du timer #N
C:00395b 0fc1      	add		REG_Y_LSB, REG_TEMP_R17			; YL += 2*N
C:00395c 1fd0      	adc		REG_Y_MSB, REG_TEMP_R16			; Report C -> YH => Y contient l'adresse du timer #N
         
C:00395d 8148      	ldd		REG_TEMP_R20, Y+0				; Maj dans R20:R21 de la duree restante du timer indexe par Y
C:00395e 8159      	ldd		REG_TEMP_R21, Y+1
         
C:00395f 0f42      	add		REG_TEMP_R20, REG_TEMP_R18	; Ajout de la duree passee en argument a celle restante
C:003960 1f53      	adc		REG_TEMP_R21, REG_TEMP_R19
         
C:003961 8348      	std		Y+0, REG_TEMP_R20				; Set add duration LSB
C:003962 8359      	std		Y+1, REG_TEMP_R21				; Set add duration MSB
         
          _uos_start_timer_rtn:
C:003963 9508      	ret
         
          _uos_start_timer_err:
C:003964 9170 050f    lds      REG_TEMP_R23, UOS_G_PORTB_IMAGE
C:003966 7f7d      	cbr		REG_TEMP_R23, UOS_MSK_BIT_LED_RED
C:003967 9370 050f    sts      UOS_G_PORTB_IMAGE, REG_TEMP_R23
         
C:003969 9508      	ret
         ; ---------
         
         ; ---------
         ; Rearmement d'un timer #N avec une duree sur 16 bits
         ; => La nouvelle duree remplace la duree restante correspondant a un fonctionnement
         ;    'uos_stop_timer' + 'uos_start_timer'
         ;
         ; Usage:
         ;      ldi     REG_TEMP_R17, <timer_num>         ; Num in range [0, 1, ..., (NBR_TIMER-1)]
         ;      ldi		REG_TEMP_R18, <timer_value_lsb>   ; LSB value
         ;      ldi		REG_TEMP_R19, <timer_value_msb>   ; MSB value
         ;      rcall   uos_restart_timer
         ;
         ; Registres utilises (non sauvegardes/restaures):
         ;    REG_Y_LSB:REG_Y_MSB -> Indexation du timer #N
         ;    REG_TEMP_R16          -> Registre de travail
         ;    REG_TEMP_R17          -> Num timer #N (1st argument)
         ;    REG_TEMP_R18          -> Duration LSB (2nd argument)
         ;    REG_TEMP_R19          -> Duration MSB (3rd argument)
         ; ---------
          uos_restart_timer:
C:00396a 3110      	cpi		REG_TEMP_R17, NBR_TIMER		; N dans la plage [0, 1, ..., (NBR_TIMER-1)] ?
C:00396b f448      	brcc		_uos_restart_timer_err				; Saut si REG_TEMP_R17 >= NBR_TIMER ?
         
C:00396c e3c5      	ldi		REG_Y_LSB, (G_TIMER_0 % 256)	; Non: Adresse de base des timers
C:00396d e0d5      	ldi		REG_Y_MSB, (G_TIMER_0 / 256)
         
C:00396e 0f11      	lsl		REG_TEMP_R17						; REG_TEMP_R17 *= 2 (Adresse sur des mots de 16 bits)
         
C:00396f 2700      	clr		REG_TEMP_R16						; Indexation du timer #N
C:003970 0fc1      	add		REG_Y_LSB, REG_TEMP_R17			; YL += 2*N
C:003971 1fd0      	adc		REG_Y_MSB, REG_TEMP_R16			; Report C -> YH => Y contient l'adresse du timer #N
         
C:003972 8328      	std		Y+0, REG_TEMP_R18				; Set add duration LSB
C:003973 8339      	std		Y+1, REG_TEMP_R19				; Set add duration MSB
         
          _uos_restart_timer_rtn:
C:003974 9508      	ret
         
          _uos_restart_timer_err:
C:003975 9170 050f    lds      REG_TEMP_R23, UOS_G_PORTB_IMAGE
C:003977 7f7d      	cbr		REG_TEMP_R23, UOS_MSK_BIT_LED_RED
C:003978 9370 050f    sts      UOS_G_PORTB_IMAGE, REG_TEMP_R23
         
C:00397a 9508      	ret
         ; ---------
         
         ; ---------
         ; Arret d'un timer #N
         ;
         ; Usage:
         ;      ldi     REG_TEMP_R17, <timer_num>         ; Num in range [0, 1, ..., (NBR_TIMER-1)]
         ;      rcall   uos_stop_timer
         ;
         ; Registres utilises (non sauvegardes/restaures):
         ;    REG_Y_LSB:REG_Y_MSB -> Indexation du timer #N
         ;    REG_TEMP_R16          -> Registre de travail
         ;    REG_TEMP_R17          -> Num timer #N (1st argument)
         ; ---------
          uos_stop_timer:
C:00397b 3110      	cpi		REG_TEMP_R17, NBR_TIMER		; N dans la plage [0, 1, ..., (NBR_TIMER-1)] ?
C:00397c f448      	brcc		_uos_stop_timer_err					; Saut si REG_TEMP_R17 >= NBR_TIMER ?
         
C:00397d e3c5      	ldi		REG_Y_LSB, (G_TIMER_0 % 256)	; Non: Adresse de base des timers
C:00397e e0d5      	ldi		REG_Y_MSB, (G_TIMER_0 / 256)
         
C:00397f 0f11      	lsl		REG_TEMP_R17						; REG_TEMP_R17 *= 2 (Adresse sur des mots de 16 bits)
         
C:003980 2700      	clr		REG_TEMP_R16						; Indexation du timer #N
C:003981 0fc1      	add		REG_Y_LSB, REG_TEMP_R17			; YL += 2*N
C:003982 1fd0      	adc		REG_Y_MSB, REG_TEMP_R16			; Report C -> YH => Y contient l'adresse du timer #N
         
C:003983 8308      	std		Y+0, REG_TEMP_R16				; Raz duration LSB
C:003984 8309      	std		Y+1, REG_TEMP_R16				; Raz duration MSB
         
          _uos_stop_timer_rtn:
C:003985 9508      	ret
         
          _uos_stop_timer_err:
C:003986 9170 050f    lds      REG_TEMP_R23, UOS_G_PORTB_IMAGE
C:003988 7f7d      	cbr		REG_TEMP_R23, UOS_MSK_BIT_LED_RED
C:003989 9370 050f    sts      UOS_G_PORTB_IMAGE, REG_TEMP_R23
         
C:00398b 9508      	ret
         ; ---------
         
         ; ---------
         ; Test d'un timer #N
         ;
         ; => La duree est retournee (a zero si time non arme ou expire)
         ;
         ; Usage:
         ;      ldi        REG_TEMP_R17, <timer_num>         ; Num in range [0, 1, ..., (NBR_TIMER-1)]
         ;      rcall      uos_test_timer
         ;
         ; Registres utilises (non sauvegardes/restaures):
         ;    REG_Y_LSB:REG_Y_MSB -> Indexation du timer #N
         ;    REG_TEMP_R16        -> Registre de travail
         ;    REG_TEMP_R17        -> Num timer #N (1st argument inchange apres execution)
         ;    REG_TEMP_R20        -> Duration LSB restante ou 0
         ;    REG_TEMP_R21        -> Duration MSB restante ou 0
         ;
         ; Retour:
         ;    Bit T de SREG   -> 0/1: Non arme ou expire / Arme en cours de decrementation
         ; ---------
          uos_test_timer:
C:00398c 3110      	cpi		REG_TEMP_R17, NBR_TIMER		; N dans la plage [0, 1, ..., (NBR_TIMER-1)] ?
C:00398d f478      	brcc		_uos_test_timer_err					; Saut si REG_TEMP_R17 >= NBR_TIMER ?
         
C:00398e e3c5      	ldi		REG_Y_LSB, (G_TIMER_0 % 256)	; Non: Adresse de base des timers
C:00398f e0d5      	ldi		REG_Y_MSB, (G_TIMER_0 / 256)
         
C:003990 0f11      	lsl		REG_TEMP_R17						; REG_TEMP_R17 *= 2 (Adresse sur des mots de 16 bits)
         
C:003991 2700      	clr		REG_TEMP_R16						; Indexation du timer #N
C:003992 0fc1      	add		REG_Y_LSB, REG_TEMP_R17			; YL += 2*N
C:003993 1fd0      	adc		REG_Y_MSB, REG_TEMP_R16			; Report C -> YH => Y contient l'adresse du timer #N
         
C:003994 8148      	ldd		REG_TEMP_R20, Y+0				; Maj dans R20:R21 de la duree restante du timer indexe par Y
C:003995 8159      	ldd		REG_TEMP_R21, Y+1
         
C:003996 9468      	set											; Timer a priori arme et non expire ...
C:003997 2344      	tst		REG_TEMP_R20
C:003998 f419      	brne		_uos_test_timer_rtn
C:003999 2355      	tst		REG_TEMP_R21
C:00399a f409      	brne		_uos_test_timer_rtn
         
C:00399b 94e8      	clt											; ... et non => Timer non arme ou expire
         
          _uos_test_timer_rtn:
C:00399c 9508      	ret
         
          _uos_test_timer_err:
C:00399d 9170 050f    lds      REG_TEMP_R23, UOS_G_PORTB_IMAGE
C:00399f 7f7d      	cbr		REG_TEMP_R23, UOS_MSK_BIT_LED_RED
C:0039a0 9370 050f    sts      UOS_G_PORTB_IMAGE, REG_TEMP_R23
         
C:0039a2 9508      	ret
         ; ---------
         
         ; ---------
         ; Maj contexte d'un timer #N
         ;
         ; Usage:
         ;      ldi        REG_TEMP_R17, <timer_num>        ; Num in range [0, 1, ..., (NBR_TIMER-1)]
         ;      ldi			REG_TEMP_R18, <context_lsb>   	; LSB value
         ;      ldi			REG_TEMP_R19, <contex_msb>   		; MSB value
         ;      rcall      uos_set_context_timer
         ;
         ; Registres utilises (non sauvegardes/restaures):
         ;    REG_Y_LSB:REG_Y_MSB -> Indexation du timer #N
         ;    REG_TEMP_R16        -> Registre de travail
         ;    REG_TEMP_R17        -> Num timer #N
         ;    REG_TEMP_R18        -> Byte LSB du contexte LSB (2nd argument)
         ;    REG_TEMP_R19        -> Byte MSB du contexte MSB (3rd argument)
         ; ---------
          uos_set_context_timer:
C:0039a3 3110      	cpi		REG_TEMP_R17, NBR_TIMER			; N dans la plage [0, 1, ..., (NBR_TIMER-1)] ?
C:0039a4 f458      	brcc		_uos_set_context_timer_err			; Saut si REG_TEMP_R17 >= NBR_TIMER
         
C:0039a5 931f      	push		REG_TEMP_R17						; Sauvegarde Num Timer
         
C:0039a6 e5c5      	ldi		REG_Y_LSB, (G_TIMER_CONTEXT_0 % 256)	; Non: Adresse de base des contextes timers
C:0039a7 e0d5      	ldi		REG_Y_MSB, (G_TIMER_CONTEXT_0 / 256)
         
C:0039a8 0f11      	lsl		REG_TEMP_R17						; REG_TEMP_R17 *= 2 (Adresse sur des mots de 16 bits)
         
C:0039a9 2700      	clr		REG_TEMP_R16						; Indexation du timer #N
C:0039aa 0fc1      	add		REG_Y_LSB, REG_TEMP_R17			; YL += 2*N
C:0039ab 1fd0      	adc		REG_Y_MSB, REG_TEMP_R16			; Report C -> YH => Y contient l'adresse du timer #N
         
C:0039ac 8328      	std		Y+0, REG_TEMP_R18					; Set byte context LSB
C:0039ad 8339      	std		Y+1, REG_TEMP_R19					; Set byte context MSB
         
          _uos_set_context_timer_rtn:
C:0039ae 911f      	pop		REG_TEMP_R17						; Restauration Num Timer
C:0039af 9508      	ret
         
          _uos_set_context_timer_err:
C:0039b0 9170 050f    lds      REG_TEMP_R23, UOS_G_PORTB_IMAGE
C:0039b2 7f7d      	cbr		REG_TEMP_R23, UOS_MSK_BIT_LED_RED
C:0039b3 9370 050f    sts      UOS_G_PORTB_IMAGE, REG_TEMP_R23
         
C:0039b5 9508      	ret
         ; ---------
         
         ; ---------
         ; Get context d'un timer #N
         ;
         ; Usage:
         ;      ldi        REG_TEMP_R17, <timer_num>         ; Num in range [0, 1, ..., (NBR_TIMER-1)]
         ;      rcall      uos_get_context_timer
         ;
         ; Registres utilises (non sauvegardes/restaures):
         ;    REG_Y_LSB:REG_Y_MSB -> Indexation du timer #N
         ;    REG_TEMP_R16        -> Registre de travail
         ;    REG_TEMP_R17        -> Num timer #N
         ;    REG_TEMP_R20        -> Byte LSB du contexte associe au timer
         ;    REG_TEMP_R21        -> Byte MSB du contexte associe au timer
         ; ---------
          uos_get_context_timer:
C:0039b6 3110      	cpi		REG_TEMP_R17, NBR_TIMER			; N dans la plage [0, 1, ..., (NBR_TIMER-1)] ?
C:0039b7 f458      	brcc		_uos_get_context_timer_err			; Saut si REG_TEMP_R17 >= NBR_TIMER
         
C:0039b8 931f      	push		REG_TEMP_R17						; Sauvegarde Num Timer
         
C:0039b9 e5c5      	ldi		REG_Y_LSB, (G_TIMER_CONTEXT_0 % 256)	; Non: Adresse de base des contextes timers
C:0039ba e0d5      	ldi		REG_Y_MSB, (G_TIMER_CONTEXT_0 / 256)
         
C:0039bb 0f11      	lsl		REG_TEMP_R17						; REG_TEMP_R17 *= 2 (Adresse sur des mots de 16 bits)
         
C:0039bc 2700      	clr		REG_TEMP_R16						; Indexation du timer #N
C:0039bd 0fc1      	add		REG_Y_LSB, REG_TEMP_R17			; YL += 2*N
C:0039be 1fd0      	adc		REG_Y_MSB, REG_TEMP_R16			; Report C -> YH => Y contient l'adresse du timer #N
         
C:0039bf 8148      	ldd		REG_TEMP_R20, Y+0					; Maj dans R18:R19 du contexte
C:0039c0 8159      	ldd		REG_TEMP_R21, Y+1
         
          _uos_get_context_timer_end:
C:0039c1 911f      	pop		REG_TEMP_R17						; Restauration Num Timer
C:0039c2 9508      	ret
         
          _uos_get_context_timer_err:
C:0039c3 9170 050f    lds      REG_TEMP_R23, UOS_G_PORTB_IMAGE
C:0039c5 7f7d      	cbr		REG_TEMP_R23, UOS_MSK_BIT_LED_RED
C:0039c6 9370 050f    sts      UOS_G_PORTB_IMAGE, REG_TEMP_R23
         
C:0039c8 9508      	ret
         ; ---------
         
         ; ---------
         ; TIMER_SPARE
         ; ---------
          _uos_callback_exec_timer_0:
C:0039c9 9508      	ret
         ; ---------
         
         ; ---------
         ; TIMER_SPARE
         ; ---------
          _uos_callback_exec_timer_1:
C:0039ca 9508      	ret
         ; ---------
         
         ; ---------
         ; TIMER_SPARE
         ; ---------
          _uos_callback_exec_timer_2:
C:0039cb 9508      	ret
         ; ---------
         
         ; ---------
         ; TIMER_SPARE
         ; ---------
          _uos_callback_exec_timer_3:
C:0039cc 9508      	ret
         ; ---------
         
         ; ---------
         ; TIMER_SPARE
         ; ---------
          _uos_callback_exec_timer_4:
C:0039cd 9508      	ret
         ; ---------
         
         ; ---------
         ; TIMER_SPARE
         ; ---------
          _uos_callback_exec_timer_5:
C:0039ce 9508      	ret
         ; ---------
         
         ; ---------
         ; TIMER_SPARE
         ; ---------
          _uos_callback_exec_timer_6:
C:0039cf 9508      	ret
         ; ---------
         
         ; ---------
         ; TIMER_SPARE
         ; ---------
          _uos_callback_exec_timer_7:
C:0039d0 9508      	ret
         ; ---------
         
         ; ---------
         ; TIMER_SPARE
         ; ---------
          _uos_callback_exec_timer_8:
C:0039d1 9508      	ret
         ; ---------
         
         ; ---------
         ; TIMER_TEST_LEDS
         ; ---------
          _uos_callback_exec_timer_9:
C:0039d2 cd08      	rjmp		exec_test_leds
C:0039d3 9508      	ret
         ; ---------
         
         ; ---------
         ; TIMER_GEST_BUTTON_LED
         ; ---------
          _uos_callback_exec_timer_10:
C:0039d4 c28e      	rjmp		_exec_ext_timer_10	; TODO: Integration du code ici des que place disponible ;-)
         ; ---------
         
         ; ---------
         ; TIMER_GEST_BUTTON
         ; ---------
          _uos_callback_exec_timer_11:
C:0039d5 c1f4      	rjmp		_exec_timer_gest_button	; TODO: Integration du code ici des que place disponible ;-)
         ; ---------
         
         ; ---------
         ; TIMER_GEST_BUTTON_ACQ
         ; ---------
          _uos_callback_exec_timer_12:
C:0039d6 c292      	rjmp		_exec_timer_gest_button_acq	; TODO: Integration du code ici des que place disponible ;-)
         ; ---------
         
         ; ---------
         ; TIMER_ERROR
         ; ---------
          _uos_callback_exec_timer_13:
         	; Fin de la presentation des erreurs
C:0039d7 94f8      	cli
         
         	; Pas de changement de l'etat Led si "Test Leds en cours"
C:0039d8 9100 0513 	lds		REG_TEMP_R16, UOS_G_GESTION_TEST_LEDS
C:0039da fd07      	sbrc		REG_TEMP_R16, FLG_GESTION_TEST_LEDS_IDX
C:0039db c00b      	rjmp		_uos_callback_exec_timer_13_more
         
C:0039dc   +  	setLedRedOff
C:0039dc 9170 0511 lds		REG_TEMP_R23, UOS_G_FLAGS_1
C:0039de 777f      cbr		REG_TEMP_R23, UOS_FLG_1_LED_RED_ON_MSK	

C:0039df 9370 0511 sts		UOS_G_FLAGS_1, REG_TEMP_R23
         
C:0039e1 9170 050f lds		REG_TEMP_R23, UOS_G_PORTB_IMAGE
C:0039e3 6072      sbr		REG_TEMP_R23, UOS_MSK_BIT_LED_RED	
C:0039e4 9370 050f sts		UOS_G_PORTB_IMAGE, REG_TEMP_R23
C:0039e6 b975      out		PORTB, REG_TEMP_R23					

         
          _uos_callback_exec_timer_13_more:
C:0039e7 9478      	sei
         
C:0039e8 9508      	ret
         ; ---------
         
         ; ---------
         ; TIMER_LED_GREEN
         ; ---------
          _uos_callback_exec_timer_14:
         	; Allumage/Extinction atomique en fonction de G_CHENILLARD_LSB<0> de Led RED
         	; @ contenu de 'G_TEST_ERROR' (erreur permanente a acquiter)
         	; => Synchronisation avec les flash Led GREEN
         	; => Inversion de la presentation si 'FLG_2_CONNECTED' affirmee ou en cours de deconnexion @ 'TIMER_CONNECT'
C:0039e9 9100 050e 	lds		REG_TEMP_R16, G_TEST_ERROR
C:0039eb 2300      	tst		REG_TEMP_R16
C:0039ec f0b9      	breq		_uos_callback_exec_timer_led_green_cont_d_2
         
         	; Au moins une erreur est presente dans 'G_TEST_ERROR'
C:0039ed 9120 0508 	lds		REG_TEMP_R18, G_CHENILLARD_LSB		; 'G_CHENILLARD_MSB' inutile
         
         	; Verification 'TIMER_CONNECT' arme (deconnexion en cours)
C:0039ef e01f      	ldi		REG_TEMP_R17, TIMER_CONNECT
C:0039f0 df9b      	rcall		uos_test_timer
C:0039f1 f026      	brts		_uos_callback_exec_timer_led_green_inversion		; Saut si timer arme
         
C:0039f2 9100 0512 	lds		REG_TEMP_R16, UOS_G_FLAGS_2
C:0039f4 ff00      	sbrs		REG_TEMP_R16, FLG_2_CONNECTED_IDX
C:0039f5 c001      	rjmp		_uos_callback_exec_timer_led_green_cont_d
         
          _uos_callback_exec_timer_led_green_inversion:
C:0039f6 9520      	com		REG_TEMP_R18					; Connexion ou en cours de deconnexion
         
          _uos_callback_exec_timer_led_green_cont_d:
         	; Allumage/Extinction atomique en fonction de G_CHENILLARD_LSB<0>
         	; => Evite un flash car PORTB maj toutes les 100uS
          _uos_callback_exec_timer_led_red_synchro:
C:0039f7 94f8      	cli
         
         	; Pas de changement de l'etat Led si "Test Leds en cours"
C:0039f8 9170 0513 	lds		REG_TEMP_R23, UOS_G_GESTION_TEST_LEDS
C:0039fa fd77      	sbrc		REG_TEMP_R23, FLG_GESTION_TEST_LEDS_IDX
C:0039fb c007      	rjmp		_uos_callback_exec_timer_led_red_synchro_more
         
C:0039fc 9170 050f    lds      REG_TEMP_R23, UOS_G_PORTB_IMAGE
C:0039fe 6072      	sbr		REG_TEMP_R23, UOS_MSK_BIT_LED_RED	; Extinction a priori Led RED ...
C:0039ff fd20      	sbrc		REG_TEMP_R18, IDX_BIT0
C:003a00 7f7d      	cbr		REG_TEMP_R23, UOS_MSK_BIT_LED_RED	; ... en fait, Allumage Led RED
C:003a01 9370 050f 	sts		UOS_G_PORTB_IMAGE, REG_TEMP_R23
         
          _uos_callback_exec_timer_led_red_synchro_more:
C:003a03 9478      	sei
         	; Fin: Allumage/Extinction atomique en fonction de G_CHENILLARD_LSB<0> de Led RED (erreur permanente a acquiter)
         	; Fin: Au moins une erreur est presente dans 'G_TEST_ERROR'
         
          _uos_callback_exec_timer_led_green_cont_d_2:
         	; Recuperation du chenillard de presentation de la Led GREEN
C:003a04 9100 0507 	lds		REG_TEMP_R16, G_CHENILLARD_MSB
C:003a06 9110 0508 	lds		REG_TEMP_R17, G_CHENILLARD_LSB
         
         	; Allumage/Extinction atomique en fonction de G_CHENILLARD_LSB<0>
C:003a08 94f8      	cli
         
         	; Pas de changement de l'etat Led si "Test Leds en cours"
C:003a09 9170 0513 	lds		REG_TEMP_R23, UOS_G_GESTION_TEST_LEDS
C:003a0b fd77      	sbrc		REG_TEMP_R23, FLG_GESTION_TEST_LEDS_IDX
C:003a0c c007      	rjmp		_uos_callback_exec_timer_led_green_cont_d_2_more
         
C:003a0d 9170 050f    lds      REG_TEMP_R23, UOS_G_PORTB_IMAGE
C:003a0f 6074      	sbr		REG_TEMP_R23, UOS_MSK_BIT_LED_GREEN	      ; Extinction a priori Led GREEN ...
C:003a10 fd10      	sbrc		REG_TEMP_R17, IDX_BIT0
C:003a11 7f7b      	cbr		REG_TEMP_R23, UOS_MSK_BIT_LED_GREEN	      ; ... en fait, Allumage Led GREEN
C:003a12 9370 050f 	sts		UOS_G_PORTB_IMAGE, REG_TEMP_R23
         
          _uos_callback_exec_timer_led_green_cont_d_2_more:
C:003a14 9478      	sei
         	; Fin: Allumage/Extinction atomique en fonction de G_CHENILLARD_LSB<0>
         
         	; Progression du chenillard
C:003a15 9506      	lsr		REG_TEMP_R16							; G_CHENILLARD_MSB<0> -> Carry
C:003a16 9517      	ror		REG_TEMP_R17							; Carry -> G_CHENILLARD_LSB<7> et G_CHENILLARD_LSB<0> -> Carry
         
C:003a17 770f      	cbr		REG_TEMP_R16, MSK_BIT7				; Preparation '0' dans G_CHENILLARD_MSB<7> a priori ...
C:003a18 f408      	brcc		_uos_callback_exec_timer_led_green_more
C:003a19 6800      	sbr		REG_TEMP_R16, MSK_BIT7				; ... et non, '1' dans G_CHENILLARD_MSB<7>
         
          _uos_callback_exec_timer_led_green_more:				; Ici, G_CHENILLARD_MSB<7> reflete la Carry
C:003a1a 9300 0507 	sts		G_CHENILLARD_MSB, REG_TEMP_R16
C:003a1c 9310 0508 	sts		G_CHENILLARD_LSB, REG_TEMP_R17
         	; Fin: Chenillard de presentation de la Led GREEN
         
         	; Armement du Timer 'TIMER_LED_GREEN'
C:003a1e e01e      	ldi		REG_TEMP_R17, TIMER_LED_GREEN
C:003a1f e72d      	ldi		REG_TEMP_R18, (125 % 256)
C:003a20 e030      	ldi		REG_TEMP_R19, (125 / 256)
C:003a21 df33      	rcall		uos_start_timer
         
         	; Compteur du chenillard [0, 1, ..., 7]
         	; => Servira pour extraire les patterns en lieu et place des decalages ;-)
C:003a22 9100 0506 	lds		REG_TEMP_R16, G_COUNTER_CHENILLARD
C:003a24 9503      	inc		REG_TEMP_R16
C:003a25 7007      	andi		REG_TEMP_R16, 0x07
C:003a26 9300 0506 	sts		G_COUNTER_CHENILLARD, REG_TEMP_R16
         
C:003a28 9508      	ret
         ; ---------
         
         ; ---------
         ; TIMER_CONNECT
         ; ---------
          _uos_callback_exec_timer_15:
         	; Passage en mode non connecte pour une presentation Led GREEN __/--\_____
C:003a29 9100 0512 	lds		REG_TEMP_R16, UOS_G_FLAGS_2
C:003a2b 7f0e      	cbr		REG_TEMP_R16, FLG_2_CONNECTED_MSK
C:003a2c 9300 0512 	sts		UOS_G_FLAGS_2, REG_TEMP_R16
         
         	; Retour a la presentation "Non Connecte" @ emplacement des vecteurs d'interruption
C:003a2e 9100 0500 	lds		REG_TEMP_R16, G_STATES_AT_RESET
C:003a30 7404      	andi		REG_TEMP_R16, (FLG_STATE_AT_IT_TIM1_COMPA_BOOTLOADER_MSK | FLG_STATE_AT_IT_TIM1_COMPA_PROGRAM_MSK)
C:003a31 3400      	cpi		REG_TEMP_R16, FLG_STATE_AT_IT_TIM1_COMPA_BOOTLOADER_MSK
C:003a32 f021      	breq		_uos_callback_exec_timer_connect_bootloader
         
C:003a33 3004      	cpi		REG_TEMP_R16, FLG_STATE_AT_IT_TIM1_COMPA_PROGRAM_MSK
C:003a34 f021      	breq		_uos_callback_exec_timer_connect_program
         
C:003a35 e01f      	ldi		REG_TEMP_R17, CHENILLARD_UNKNOWN
C:003a36 c003      	rjmp		_uos_callback_exec_timer_connect_cont_d
         
          _uos_callback_exec_timer_connect_bootloader:
C:003a37 e515      	ldi		REG_TEMP_R17, CHENILLARD_BOOTLOADER
C:003a38 c001      	rjmp		_uos_callback_exec_timer_connect_cont_d
         
          _uos_callback_exec_timer_connect_program:
C:003a39 e011      	ldi		REG_TEMP_R17, CHENILLARD_PROGRAM
         	;rjmp		_uos_callback_exec_timer_connect_cont_d
         
          _uos_callback_exec_timer_connect_cont_d:
C:003a3a 9310 0507 	sts		G_CHENILLARD_MSB, REG_TEMP_R17
C:003a3c 9310 0508 	sts		G_CHENILLARD_LSB, REG_TEMP_R17
         	; Fin: Retour a la presentation "Non Connecte" @ emplacement des vecteurs d'interruption
         
C:003a3e 9508      	ret
         ; ---------
         
         ; End of file
         
          
          .include		"ATmega328P_uOS_Uart.asm"
         ; "$Id: ATmega328P_uOS_Uart.asm,v 1.6 2026/02/18 18:01:34 administrateur Exp $"
         
          #include "ATmega328P_uOS_Uart.h"
         ; "$Id: ATmega328P_uOS_Uart.h,v 1.2 2026/02/18 18:01:34 administrateur Exp $"
         
         ; Gestion de l'UART
         ; -----------------
         ; - FLG_0_UART_DETECT_LINE_IDLE: Passage a 1 si ligne RXD a l'etat haut durant au moins 10 bits;
         ;   => Soit 40 acquisitions concecutives espacees de 13uS = 520uS correspondant a 10 bits a 9600 bauds
         ; - FLG_0_UART_DETECT_BIT_START: Si 'FLG_0_UART_DETECT_LINE_IDLE' a 1, passage a 1 sur detection du bit START
         ;   => Acquisition au moyen de la detection du front descendant sur RXD (cf. 'int0_isr')
         ;   => Conservation de 'FLG_0_UART_DETECT_LINE_IDLE' et de 'FLG_0_UART_DETECT_BIT_START' a 1 jusqu'a
         ;      la fin de l'acquisition d'un byte UART (1 start + 8 datas + 1 stop)
         ;      => Passage a 0 de 'FLG_0_UART_DETECT_BIT_START' pour relancer la detaction du bit START
         ; - FLG_0_UART_DETECT_BYTE: Passage a 1 pour indiquer donnee UART disponible jusqu'a sa lecture
         ;   pour traitement (ie. ecriture dans la FIFO/UART RX)
         ;
         ; => 1 - L'acquisition des donnees UART commence des que les 2 flags 'FLG_0_UART_DETECT_LINE_IDLE' et
         ;    'FLG_0_UART_DETECT_BIT_START' sont a 1
         ;
         ;    2 - A la fin de l'acquisition, le flag 'FLG_0_UART_DETECT_BIT_START' est remis a 0
         ;        pour une detection du bit START
         ;
         ;    => 'FLG_0_UART_DETECT_LINE_IDLE' est remis a 0 sur erreur de communication comme:
         ;       - Pas de bit START lu au 1st bit apres la detection --\__ (Frame Error)
         ;       - Pas de bit STOP lu au 10th bit (Frame Error)
         ;       - Donnee non attendue @ protocole
         ;       - A completer...
         ;
         
          .dseg
         
D:000575    G_UART_CPT_LINE_IDLE_LSB:	.byte		1		; Compteur de 16 bits pour la detection de la ligne IDLE
D:000576    G_UART_CPT_LINE_IDLE_MSB:	.byte		1
         
D:000577    G_UART_BYTE_TX:				.byte		1		; Byte a emettre sur TXD
         
         ; FIFO UART/Rx
          #define	SIZE_UART_FIFO_RX			64			; Puissance de 2 pour un modulo SIZE_UART_FIFO_RX
         
D:000578    G_UART_FIFO_RX_WRITE:		.byte		1
D:000579    G_UART_FIFO_RX_READ:			.byte		1
D:00057a    G_UART_FIFO_RX_DATA:			.byte		(SIZE_UART_FIFO_RX - 1)		; 1st byte de la FIFO/Rx
D:0005b9    G_UART_FIFO_RX_DATA_END:	.byte		1									; Last byte de la FIFO/Rx
         
         ; FIFO UART/Tx
          #define	SIZE_UART_FIFO_TX			256		; Puissance de 2 pour un modulo SIZE_UART_FIFO_TX
         
D:0005ba    G_UART_FIFO_TX_WRITE:		.byte		1
D:0005bb    G_UART_FIFO_TX_READ:			.byte		1
D:0005bc    G_UART_FIFO_TX_DATA:			.byte		(SIZE_UART_FIFO_TX - 1)		; 1st byte de la FIFO/Tx
D:0006bb    G_UART_FIFO_TX_DATA_END:	.byte		1									; Last byte de la FIFO/Tx
         
         ; End of file
         
          
         
          .cseg
         
         ; ---------
         ; Gestion des FIFOs UART/Rx et UART/Tx
         ;
         ; Usages:
         ;      mov		REG_R5, <data>			; Donnee a ecrire
         ;      rcall   _uos_uart_fifo_rx|tx_write
         ;      => Retour: SREG<Bit> = 1 si FIFO/Rx|Tx pleine
         ;
         ;      rcall	_uos_uart_fifo_rx|tx_read
         ;      => Retour: Donnee dans G_STACK_RESULTS si SREG<Bit> = 1
         ;
         ; Registres utilises (non sauvegardes/restaures):
         ;    REG_X_LSB:REG_X_LSB -> Pointeur sur les pointeurs ecriture/lecture/data
         ;    REG_TEMP_R16        -> Working register
         ;    REG_TEMP_R17        -> Pointeur d'ecriture courant
         ;    REG_TEMP_R18        -> Pointeur de lecture courant
         ;
         ; Warning: Methode appelee sous l'It 'tim1_compa_isr'
         ; ---------
          _uos_uart_fifo_rx_write:
C:003a3f e0b5      	ldi		REG_X_MSB, (G_UART_FIFO_RX_DATA / 256)		; Indexation dans la FIFO/Rx
C:003a40 e7aa      	ldi		REG_X_LSB, (G_UART_FIFO_RX_DATA % 256)
C:003a41 9110 0578 	lds		REG_TEMP_R17, G_UART_FIFO_RX_WRITE			; Pointeur d'ecriture courant
C:003a43 9120 0579 	lds		REG_TEMP_R18, G_UART_FIFO_RX_READ			; Pointeur de lecture courant
         
C:003a45 2700      	clr		REG_TEMP_R16
C:003a46 0fa1      	add		REG_X_LSB, REG_TEMP_R17	; XL += REG_TEMP_R17
C:003a47 1fb0      	adc		REG_X_MSB, REG_TEMP_R16	; XH += 0 + Carry
         
C:003a48 924c      	st			X, REG_R5			; Ecriture donnee dans [G_UART_FIFO_RX_DATA, ..., G_UART_FIFO_RX_DATA_END]
         
C:003a49 9513      	inc		REG_TEMP_R17
C:003a4a 731f      	andi		REG_TEMP_R17, (SIZE_UART_FIFO_RX - 1)		; Pointeur d'ecriture dans [0, ..., [SIZE_UART_FIFO_RX - 1)]
C:003a4b 9310 0578 	sts		G_UART_FIFO_RX_WRITE, REG_TEMP_R17			; Maj pointeur d'ecriture
         
         	; Indication FIFO/Rx non vide
C:003a4d 9170 0511 	lds		REG_TEMP_R23, UOS_G_FLAGS_1
C:003a4f 6071      	sbr		REG_TEMP_R23, FLG_1_UART_FIFO_RX_NOT_EMPTY_MSK
C:003a50 9370 0511 	sts		UOS_G_FLAGS_1, REG_TEMP_R23
         
         	; Indication si FIFO/Rx pleine
         	; => FIFO/Rx pleine si le pointeur d'ecriture "rejoint" le pointeur de lecture
         	;    => Soit (REG_TEMP_R17 == REG_TEMP_R18) ici
C:003a52 9170 0511 	lds		REG_TEMP_R23, UOS_G_FLAGS_1
C:003a54 7f7d      	cbr		REG_TEMP_R23, FLG_1_UART_FIFO_RX_FULL_MSK 		; FIFO/Rx a priori non pleine ...
C:003a55 9370 0511 	sts		UOS_G_FLAGS_1, REG_TEMP_R23
         
C:003a57 94e8      	clt																	; SREG<T> = 0
C:003a58 1712      	cp			REG_TEMP_R17, REG_TEMP_R18
C:003a59 f431      	brne		_uos_uart_fifo_rx_write_rtn
         
C:003a5a 9170 0511 	lds		REG_TEMP_R23, UOS_G_FLAGS_1
C:003a5c 6072      	sbr		REG_TEMP_R23, FLG_1_UART_FIFO_RX_FULL_MSK		; ... et non, FIFO/Rx pleine
C:003a5d 9370 0511 	sts		UOS_G_FLAGS_1, REG_TEMP_R23
         
C:003a5f 9468      	set																	; SREG<T> = 1
         
          #if 0
          #endif
         
          _uos_uart_fifo_rx_write_rtn:
C:003a60 9508      	ret
         ; ---------
         
         ; ---------
          _uos_uart_fifo_rx_read:
C:003a61 e0b5      	ldi		REG_X_MSB, (G_UART_FIFO_RX_DATA / 256)		; Indexation dans la FIFO/Rx
C:003a62 e7aa      	ldi		REG_X_LSB, (G_UART_FIFO_RX_DATA % 256)
C:003a63 9110 0578 	lds		REG_TEMP_R17, G_UART_FIFO_RX_WRITE			; Pointeur d'ecriture courant
C:003a65 9120 0579 	lds		REG_TEMP_R18, G_UART_FIFO_RX_READ			; Pointeur de lecture courant
         
         	; Sortie prematuree si rien a lire
C:003a67 94e8      	clt													; A priori pas de donnee a lire
C:003a68 1712      	cp			REG_TEMP_R17, REG_TEMP_R18
C:003a69 f081      	breq		_uos_uart_fifo_rx_read_end				; Pointeurs egaux => FIFO/Rx trouvee vide
         
C:003a6a 2700      	clr		REG_TEMP_R16
C:003a6b 0fa2      	add		REG_X_LSB, REG_TEMP_R18	; XL += REG_TEMP_R18
C:003a6c 1fb0      	adc		REG_X_MSB, REG_TEMP_R16	; XH += 0 + Carry
         
C:003a6d 902c      	ld			REG_R2, X					; Lecture de la donnee dans [G_UART_FIFO_RX_DATA, ..., G_UART_FIFO_RX_DATA_END]
C:003a6e 9468      	set										; Indication donnee disponible
         
C:003a6f 9523      	inc		REG_TEMP_R18
C:003a70 732f      	andi		REG_TEMP_R18, (SIZE_UART_FIFO_RX - 1)		; Pointeur de lecture dans [0, ..., [SIZE_UART_FIFO_RX - 1)]
C:003a71 9320 0579 	sts		G_UART_FIFO_RX_READ, REG_TEMP_R18
         
         	; Indication FIFO/Rx vide ou non vide apres la lecture
         	; => FIFO/Rx vide si le pointeur de lecture "rejoint" le pointeur ecriture
         	;    => Soit (REG_TEMP_R17 == REG_TEMP_R18) ici
          _uos_uart_fifo_rx_read_test_empty:
C:003a73 9170 0511 	lds		REG_TEMP_R23, UOS_G_FLAGS_1
C:003a75 6071      	sbr		REG_TEMP_R23, FLG_1_UART_FIFO_RX_NOT_EMPTY_MSK		; FIFO/Rx a priori non vide...
C:003a76 9370 0511 	sts		UOS_G_FLAGS_1, REG_TEMP_R23
C:003a78 1712      	cp			REG_TEMP_R17, REG_TEMP_R18
C:003a79 f429      	brne		_uos_uart_fifo_rx_read_rtn
         
          _uos_uart_fifo_rx_read_end:
C:003a7a 9170 0511 	lds		REG_TEMP_R23, UOS_G_FLAGS_1
C:003a7c 7f7e      	cbr		REG_TEMP_R23, FLG_1_UART_FIFO_RX_NOT_EMPTY_MSK		; ... et non, FIFO/Rx vide
C:003a7d 9370 0511 	sts		UOS_G_FLAGS_1, REG_TEMP_R23
         
          _uos_uart_fifo_rx_read_rtn:
C:003a7f 9508      	ret
         ; ---------
         
         ; ---------
          uos_uart_fifo_tx_write:
          _uos_uart_fifo_tx_write:
C:003a80 93bf      	push		REG_X_MSB
C:003a81 93af      	push		REG_X_LSB
C:003a82 931f      	push		REG_TEMP_R17
C:003a83 932f      	push		REG_TEMP_R18
         
C:003a84 e0b5      	ldi		REG_X_MSB, (G_UART_FIFO_TX_DATA / 256)	; Indexation dans la FIFO/Tx et ses 2 pointeurs
C:003a85 ebac      	ldi		REG_X_LSB, (G_UART_FIFO_TX_DATA % 256)
C:003a86 9110 05ba 	lds		REG_TEMP_R17, G_UART_FIFO_TX_WRITE			; Pointeur d'ecriture courant
C:003a88 9120 05bb 	lds		REG_TEMP_R18, G_UART_FIFO_TX_READ			; Pointeur de lecture courant
         
C:003a8a 2700      	clr		REG_TEMP_R16
C:003a8b 0fa1      	add		REG_X_LSB, REG_TEMP_R17			; XL += REG_TEMP_R17
C:003a8c 1fb0      	adc		REG_X_MSB, REG_TEMP_R16			; XH += 0 + Carry
         
C:003a8d 923c      	st			X, REG_R3			; Ecriture donnee dans [G_UART_FIFO_TX_DATA, ..., G_UART_FIFO_TX_DATA_END]
         
C:003a8e 9513      	inc		REG_TEMP_R17
C:003a8f 7f1f      	andi		REG_TEMP_R17, (SIZE_UART_FIFO_TX - 1)		; Pointeur d'ecriture dans [0, ..., [SIZE_UART_FIFO_TX - 1)]
C:003a90 9310 05ba 	sts		G_UART_FIFO_TX_WRITE, REG_TEMP_R17			; Maj pointeur d'ecriture
         
         	; Indication FIFO/Tx non vide
C:003a92 9170 0511 	lds		REG_TEMP_R23, UOS_G_FLAGS_1
C:003a94 6170      	sbr		REG_TEMP_R23, FLG_1_UART_FIFO_TX_NOT_EMPTY_MSK
C:003a95 9370 0511 	sts		UOS_G_FLAGS_1, REG_TEMP_R23
         
         	; Emision de tous les caracteres de la FIFO/Tx jusqu'au dernier des que le pointeur d'ecriture (REG_TEMP_R17)
         	; atteint le pointeur de lecture (REG_TEMP_R18) -(SIZE_UART_FIFO_TX / 2) modulo SIZE_UART_FIFO_TX
         	; => Revient a vider la FIFO/Tx des que celle-ci est pleine a 50%
         	;    => Au dessous des 50%, les caracteres seront emis en fond de tache grace a l'appel de 'fifo_tx_to_send_async'
         	;    => Evite d'appeler dans le code la methode 'fifo_tx_to_send_sync' pour ne pas saturer la FIFO/Tx ;-)
C:003a97 2f02      	mov		REG_TEMP_R16, REG_TEMP_R18
C:003a98 5800      	subi		REG_TEMP_R16, (SIZE_UART_FIFO_TX / 2)		; Seuil a 50 % d'occupation de la FIFO/Tx
C:003a99 7f0f      	andi		REG_TEMP_R16, (SIZE_UART_FIFO_TX - 1)		; Modulo SIZE_UART_FIFO_TX
C:003a9a 1701      	cp			REG_TEMP_R16, REG_TEMP_R17
C:003a9b f409      	brne		_uos_uart_fifo_tx_write_skip
         
C:003a9c d055      	rcall		uos_fifo_tx_to_send_sync
         
          _uos_uart_fifo_tx_write_skip:
         	; Fin: Emision de tous les caracteres de la FIFO/Tx...
         
         	; Indication si FIFO pleine
         	; => FIFO pleine si le pointeur d'ecriture "rejoint" le pointeur de lecture
         	;    => Soit (REG_TEMP_R17 == REG_TEMP_R18) ici
C:003a9d 9170 0511 	lds		REG_TEMP_R23, UOS_G_FLAGS_1
C:003a9f 7d7f      	cbr		REG_TEMP_R23, FLG_1_UART_FIFO_TX_FULL_MSK 		; FIFO/Rx a priori non pleine ...
C:003aa0 9370 0511 	sts		UOS_G_FLAGS_1, REG_TEMP_R23
C:003aa2 94e8      	clt																	; SREG<T> = 0
C:003aa3 1712      	cp			REG_TEMP_R17, REG_TEMP_R18
C:003aa4 f431      	brne		_uos_uart_fifo_tx_write_rtn
         
C:003aa5 9170 0511 	lds		REG_TEMP_R23, UOS_G_FLAGS_1
C:003aa7 6270      	sbr		REG_TEMP_R23, FLG_1_UART_FIFO_TX_FULL_MSK		; ... et non, FIFO/Rx pleine
C:003aa8 9370 0511 	sts		UOS_G_FLAGS_1, REG_TEMP_R23
C:003aaa 9468      	set																	; SREG<T> = 1
         
          #if 0
          #endif
         
          _uos_uart_fifo_tx_write_rtn:
C:003aab 912f      	pop		REG_TEMP_R18
C:003aac 911f      	pop		REG_TEMP_R17
C:003aad 91af      	pop		REG_X_LSB
C:003aae 91bf      	pop		REG_X_MSB
C:003aaf 9508      	ret
         ; ---------
         
         ; ---------
          _uos_uart_fifo_tx_read:
C:003ab0 93bf      	push		REG_X_MSB
C:003ab1 93af      	push		REG_X_LSB
C:003ab2 931f      	push		REG_TEMP_R17
C:003ab3 932f      	push		REG_TEMP_R18
         
C:003ab4 e0b5      	ldi		REG_X_MSB, (G_UART_FIFO_TX_DATA / 256)	; Indexation dans la FIFO/Tx et ses 2 pointeurs
C:003ab5 ebac      	ldi		REG_X_LSB, (G_UART_FIFO_TX_DATA % 256)
C:003ab6 9110 05ba 	lds		REG_TEMP_R17, G_UART_FIFO_TX_WRITE			; Pointeur d'ecriture courant
C:003ab8 9120 05bb 	lds		REG_TEMP_R18, G_UART_FIFO_TX_READ			; Pointeur d'ecriture courant
         
         	; Sortie prematuree si rien a lire
C:003aba 94e8      	clt														; A priori pas de donnee a lire
C:003abb 1712      	cp			REG_TEMP_R17, REG_TEMP_R18
C:003abc f081      	breq		_uos_uart_fifo_tx_read_end					; Pas de lecture => maj flags
         
C:003abd 2700      	clr		REG_TEMP_R16
C:003abe 0fa2      	add		REG_X_LSB, REG_TEMP_R18	; XL += REG_TEMP_R18
C:003abf 1fb0      	adc		REG_X_MSB, REG_TEMP_R16	; XH += 0 + Carry
         
C:003ac0 904c      	ld			REG_R4, X			; Lecture de la donnee dans [G_UART_FIFO_TX_DATA, ..., G_UART_FIFO_TX_DATA_END]
C:003ac1 9468      	set								; Indication donnee disponible
         
C:003ac2 9523      	inc		REG_TEMP_R18
C:003ac3 7f2f      	andi		REG_TEMP_R18, (SIZE_UART_FIFO_TX - 1)		; Pointeur de lecture dans [0, ..., [SIZE_UART_FIFO_TX - 1)]
C:003ac4 9320 05bb 	sts		G_UART_FIFO_TX_READ, REG_TEMP_R18
         
         	; Indication FIFO/Tx vide ou non vide apres la lecture
         	; => FIFO/Tx vide si le pointeur de lecture "rejoint" le pointeur ecriture
         	;    => Soit (REG_TEMP_R17 == REG_TEMP_R18) ici
          _uos_uart_fifo_tx_read_test_empty:
C:003ac6 9170 0511 	lds		REG_TEMP_R23, UOS_G_FLAGS_1
C:003ac8 6170      	sbr		REG_TEMP_R23, FLG_1_UART_FIFO_TX_NOT_EMPTY_MSK		; FIFO/Rx a priori non vide...
C:003ac9 9370 0511 	sts		UOS_G_FLAGS_1, REG_TEMP_R23
C:003acb 1712      	cp			REG_TEMP_R17, REG_TEMP_R18
C:003acc f429      	brne		_uos_uart_fifo_tx_read_rtn
         
          _uos_uart_fifo_tx_read_end:
C:003acd 9170 0511 	lds		REG_TEMP_R23, UOS_G_FLAGS_1
C:003acf 7e7f      	cbr		REG_TEMP_R23, FLG_1_UART_FIFO_TX_NOT_EMPTY_MSK		; ... et non, FIFO/Rx vide
C:003ad0 9370 0511 	sts		UOS_G_FLAGS_1, REG_TEMP_R23
         
          _uos_uart_fifo_tx_read_rtn:
C:003ad2 912f      	pop		REG_TEMP_R18
C:003ad3 911f      	pop		REG_TEMP_R17
C:003ad4 91af      	pop		REG_X_LSB
C:003ad5 91bf      	pop		REG_X_MSB
C:003ad6 9508      	ret
         ; ---------
         
         ; ---------
         ; Emission d'un caractere sur Tx
         ; => Initialise 'G_UART_BYTE_TX' et positionne 'FLG_1_UART_TX_TO_SEND' a 1
         ;
         ; Usage:
         ;      mov		REG_TEMP_R16, <data>
         ;      rcall   _uos_uart_tx_send
         ;
         ; Registres utilises (sauvegardes/restaures):
         ; ---------
          _uos_uart_tx_send:
C:003ad7 9300 0577 	sts		G_UART_BYTE_TX, REG_TEMP_R16
         
C:003ad9 9170 0510 	lds		REG_TEMP_R23, UOS_G_FLAGS_0
C:003adb 6170      	sbr		REG_TEMP_R23, FLG_0_UART_TX_TO_SEND_MSK		; Positionnement donnee a emettre
C:003adc 9370 0510 	sts		UOS_G_FLAGS_0, REG_TEMP_R23
         
C:003ade 9508      	ret
         ; ---------
         
         ; ---------
         ; Emission asynchrone caractere par caractere de la FIFO/Tx
         ;
         ; Remarque: Methode a appeler en fond de tache permettant de vider et
         ;           emettre tous les caracteres de la FIFO/Tx jusqu'au dernier
         ;
         ; Usage:
         ;      rcall   _uos_fifo_tx_to_send_async
         ;
         ; Registres utilises
         ;    REG_TEMP_R16        -> Working register (non preserve)
         ; ---------
          uos_fifo_tx_to_send_async:
          _uos_fifo_tx_to_send_async:
         	; Caractere de la FIFO/Tx a emettre ?
C:003adf 9170 0511 	lds		REG_TEMP_R23, UOS_G_FLAGS_1
C:003ae1 ff76      	sbrs		REG_TEMP_R23, FLG_1_UART_FIFO_TX_TO_SEND_IDX
         
C:003ae2 c00e      	rjmp		_uos_fifo_tx_to_send_async_rtn
         
C:003ae3 9170 0510 	lds		REG_TEMP_R23, UOS_G_FLAGS_0
C:003ae5 fd74      	sbrc		REG_TEMP_R23, FLG_0_UART_TX_TO_SEND_IDX		; Caractere emis ?
         
C:003ae6 c00a      	rjmp		_uos_fifo_tx_to_send_async_rtn
         
C:003ae7 dfc8      	rcall		_uos_uart_fifo_tx_read					; Oui => Lecture du caractere suivant dans FIFO/Tx
C:003ae8 f41e      	brtc		_uos_fifo_tx_to_send_async_end		; Caractere disponible ?
         
C:003ae9 2d04      	mov		REG_TEMP_R16, REG_R4				; Oui => Emission de celui-ci
C:003aea dfec      	rcall		_uos_uart_tx_send
C:003aeb c005      	rjmp		_uos_fifo_tx_to_send_async_rtn		; Retour et attente que ce caractere soit emis...
         
          _uos_fifo_tx_to_send_async_end:
C:003aec 9170 0511 	lds		REG_TEMP_R23, UOS_G_FLAGS_1
C:003aee 7b7f      	cbr		REG_TEMP_R23, FLG_1_UART_FIFO_TX_TO_SEND_MSK		; Non => Arret de la demande d'emission
C:003aef 9370 0511 	sts		UOS_G_FLAGS_1, REG_TEMP_R23
         
          _uos_fifo_tx_to_send_async_rtn:
C:003af1 9508      	ret
         ; ---------
         
         ; ---------
         ; Emission synchrone caractere par caractere jusqu'a vidage de la FIFO/Tx
         ;
         ; Remarque: Methode a appeler apres un appel a 'uos_push_1_char_in_fifo_tx'
         ;           => Emision de tous les caracteres de la FIFO/Tx jusqu'au dernier
         ;
         ; Permet un forcage de l'emission pour eviter la saturation de la FIFO/Tx
         ; => En effet, la lecture de la FIFO/Tx et l'emission ne commence qu'au
         ;    retour en fond de tache (cf. 'rcall fifo_tx_to_send_async')
         ;
         ; Usage:
         ;      rcall   _uos_fifo_tx_to_send_sync
         ;
         ; Registres utilises
         ;    REG_TEMP_R16        -> Working register (non preserve)
         ; ---------
          uos_fifo_tx_to_send_sync:
          _uos_fifo_tx_to_send_sync:
          _uos_fifo_tx_to_send_sync_retry:
         	; Pas de changement de l'etat Led si "Test Leds en cours"
C:003af2 9170 0513 	lds		REG_TEMP_R23, UOS_G_GESTION_TEST_LEDS
C:003af4 fd77      	sbrc		REG_TEMP_R23, FLG_GESTION_TEST_LEDS_IDX
C:003af5 c005      	rjmp		_uos_fifo_tx_to_send_sync_retry_more
         
         	; Presentation passage en mode synchrone de l'emission TX
C:003af6 9170 050f    lds      REG_TEMP_R23, UOS_G_PORTB_IMAGE
C:003af8 7d7f      	cbr		REG_TEMP_R23, UOS_MSK_BIT_LED_YELLOW
C:003af9 9370 050f    sts      UOS_G_PORTB_IMAGE, REG_TEMP_R23
         
          _uos_fifo_tx_to_send_sync_retry_more:
C:003afb 9170 0511 	lds		REG_TEMP_R23, UOS_G_FLAGS_1
C:003afd 6470      	sbr		REG_TEMP_R23, FLG_1_UART_FIFO_TX_TO_SEND_MSK
C:003afe 9370 0511 	sts		UOS_G_FLAGS_1, REG_TEMP_R23
         
C:003b00 dfde      	rcall		_uos_fifo_tx_to_send_async
         
C:003b01 9170 0510 	lds		REG_TEMP_R23, UOS_G_FLAGS_0
C:003b03 fd74      	sbrc		REG_TEMP_R23, FLG_0_UART_TX_TO_SEND_IDX				; Caractere emis ?
         
C:003b04 cfed      	rjmp		_uos_fifo_tx_to_send_sync_retry								; Non => Retry
         
C:003b05 9170 0511 	lds		REG_TEMP_R23, UOS_G_FLAGS_1
C:003b07 fd74      	sbrc		REG_TEMP_R23, FLG_1_UART_FIFO_TX_NOT_EMPTY_IDX	; FIFO/Tx vide ?
         
C:003b08 cfe9      	rjmp		_uos_fifo_tx_to_send_sync_retry								; Non => Retry
         	; Fin: Emission, attente FIFO/Tx vide et dernier caractere emis
         
         	; Pas de changement de l'etat Led si "Test Leds en cours"
C:003b09 9170 0513 	lds		REG_TEMP_R23, UOS_G_GESTION_TEST_LEDS
C:003b0b fd77      	sbrc		REG_TEMP_R23, FLG_GESTION_TEST_LEDS_IDX
C:003b0c c005      	rjmp		_uos_fifo_tx_to_send_sync_rtn
         
         	; Fin de la presentation passage en mode synchrone de l'emission TX
         	; TODO: - Si peu de caracteres ont ete empiles + vitesse rapide (ie. 19200 bauds)
         	;       => Effacement premature de la presentation
         	;          => Implementation d'un timer d'une duree minimale (ie. 100 mS)
         	;       - Comportement constaste avec les commandes a reponse "courte"
         	;         du monitor comme "<f", "<S", "<t", etc.
C:003b0d 9170 050f    lds      REG_TEMP_R23, UOS_G_PORTB_IMAGE
C:003b0f 6270      	sbr		REG_TEMP_R23, UOS_MSK_BIT_LED_YELLOW
C:003b10 9370 050f    sts      UOS_G_PORTB_IMAGE, REG_TEMP_R23
         
          _uos_fifo_tx_to_send_sync_rtn:
C:003b12 9508      	ret
         ; ---------
         
         ; End of file
          ; End of file
          .include		"ATmega328P_uOS_Buttons.asm"
         ; "$Id: ATmega328P_uOS_Buttons.asm,v 1.3 2026/02/18 18:01:34 administrateur Exp $"
         
          #include "ATmega328P_uOS_Buttons.h"
         ; "$Id: ATmega328P_uOS_Buttons.h,v 1.2 2026/02/18 18:01:34 administrateur Exp $"
         
         ; Definitions pour la gestion de 4 boutons...
          #define	UOS_BUTTON_1_NUM						1
          #define	UOS_BUTTON_2_NUM						2
          #define	UOS_BUTTON_3_NUM						3
          #define	UOS_BUTTON_4_NUM						4
         
         ; Bits des boutons sur le PIND<4:5:6:7>
          #define	BUTTON_1_MSK							MSK_BIT4
          #define	BUTTON_2_MSK							MSK_BIT5
          #define	BUTTON_3_MSK							MSK_BIT6
          #define	BUTTON_4_MSK							MSK_BIT7
         
          #define	BUTTON_1_IDX							IDX_BIT4
          #define	BUTTON_2_IDX							IDX_BIT5
          #define	BUTTON_3_IDX							IDX_BIT6
          #define	BUTTON_4_IDX							IDX_BIT7
         
          #define	DURATION_WAIT_STABILITY				10
          #define	DURATION_BUTTON_LED					100
          #define	DURATION_BUTTON_ACQ					200
          #define	DURATION_WAIT_ACTION					500
         
          #define	FLG_BUTTON_REPEAT_MSK			MSK_BIT4
          #define	FLG_BUTTON_RISING_EDGE_MSK		MSK_BIT3
          #define	FLG_BUTTON_PRESSED_MSK			MSK_BIT2
          #define	FLG_BUTTON_FALLING_EDGE_MSK	MSK_BIT1
          #define	FLG_BUTTON_WAIT_DONE_MSK		MSK_BIT0
         
          #define	FLG_BUTTON_REPEAT_IDX			IDX_BIT4
          #define	FLG_BUTTON_RISING_EDGE_IDX		IDX_BIT3
          #define	FLG_BUTTON_PRESSED_IDX			IDX_BIT2
          #define	FLG_BUTTON_FALLING_EDGE_IDX	IDX_BIT1
          #define	FLG_BUTTON_WAIT_DONE_IDX		IDX_BIT0
         
          #define	FLG_STATE_BUTTON_ACTION_MSK			MSK_BIT7		; Action a executer pour le bouton #N [1, 2, ...]
          #define	FLG_STATE_BUTTON_SHORT_TOUCH_MSK		MSK_BIT6		; Appui "court" a l'expiration de 'TIMER_GEST_BUTTON_ACQ'
          #define	FLG_STATE_BUTTON_LONG_TOUCH_MSK		MSK_BIT5		; Appui "long" a l'expiration de 'TIMER_GEST_BUTTON_ACQ'
         
          #define	FLG_STATE_BUTTON_ACTION_IDX			IDX_BIT7		; Action a executer pour le bouton #N [1, 2, ...]
          #define	UOS_FLG_STATE_BUTTON_SHORT_TOUCH_IDX		IDX_BIT6		; Appui "court" a l'expiration de 'TIMER_GEST_BUTTON_ACQ'
          #define	FLG_STATE_BUTTON_LONG_TOUCH_IDX		IDX_BIT5		; Appui "long" a l'expiration de 'TIMER_GEST_BUTTON_ACQ'
         
          #define	BUTTONS_MASK_1_2_3_4						(BUTTON_1_MSK | BUTTON_2_MSK | BUTTON_3_MSK | BUTTON_4_MSK)
         
          #define	FLG_BUTTONS_1_2_3_4_VALID_MSK			MSK_BIT7		; 1! bouton est valide parmi les 4
          #define	FLG_BUTTONS_1_2_3_4_LOW_MSK			MSK_BIT6		; Ce bouton est appuye
          #define	FLG_BUTTONS_1_2_3_4_HIGH_MSK			MSK_BIT5		; Ce bouton est relache
         
          #define	FLG_BUTTONS_1_2_3_4_VALID_IDX			IDX_BIT7		; 1! bouton est valide parmi les 4
          #define	FLG_BUTTONS_1_2_3_4_LOW_IDX			IDX_BIT6		; Ce bouton est appuye
          #define	FLG_BUTTONS_1_2_3_4_HIGH_IDX			IDX_BIT5		; Ce bouton est relache
         
          .dseg
         
D:0006bc    G_NUM_BUTTON:							.byte		1			; Numero du bouton en cours d'acquisition parmi [1, 2, 3, ...]
         																	; avec les flags 'FLG_BUTTONS_1_2_3_4_xxx' renseignes
D:0006bd    G_NUM_BUTTON_PRE:						.byte		1			; Numero du bouton precedent pour comparaison
D:0006be    G_FLAGS_BUTTON:						.byte		1			; Gestion des rebonds, appuis "court" et "long" d'un bouton
D:0006bf    G_BUTTON_NBR_LONG_TOUCH:			.byte		1			; Nombre d'appuis "long" (sans relacher)
D:0006c0    UOS_G_STATES_BUTTON:					.byte		1			; Etats du bouton a l'expiration de 'TIMER_GEST_BUTTON_ACQ'
D:0006c1    UOS_G_STATES_BUTTON_NBR_TOUCH:	.byte		1			; et le nombre d'appuis avant expiration de 'TIMER_GEST_BUTTON_ACQ'
         
D:0006c2    UOS_G_STATES_BUTTON_NOTIF:					.byte		1			; Recopie de 'G_STATES_BUTTON'...
D:0006c3    UOS_G_STATES_BUTTON_NBR_TOUCH_NOTIF:	.byte		1			; ...pour une mise a disposition dans le traitement 1mS
         
         ; End of file
          ; End of file
         
          .cseg
         
         ; ======================================================= Gestion des 4 boutons
         ; ---------
         ; Gestion boutons
         ; ---------
          _uos_gest_buttons_ret:
C:003b13 c075      	rjmp		_uos_gest_buttons_rtn
         
          _uos_gest_buttons:
         	; Acquitement et action de(s) appui(s) boutons appele toutes les 1mS
C:003b14 9100 06c2 	lds		REG_TEMP_R16, UOS_G_STATES_BUTTON_NOTIF
C:003b16 9110 06c3 	lds		REG_TEMP_R17, UOS_G_STATES_BUTTON_NBR_TOUCH_NOTIF
C:003b18 2300      	tst		REG_TEMP_R16
C:003b19 f3c9      	breq		_uos_gest_buttons_ret
         
C:003b1a 2311      	tst		REG_TEMP_R17
C:003b1b f3b9      	breq		_uos_gest_buttons_ret
         
         	; Appui bouton a traiter et a acquiter
         	;
         	; ---------
         	; Prolongement si le code est execute au RESET depuis l'espace PROGRAM et
         	; si le vecteur commence par l'instruction 'rjmp'
         	; ---------
C:003b1c e3f8      	ldi		REG_Z_MSB, high(_uos_callback_gest_buttons)	; Execution si possible de l'extension
C:003b1d e5ee      	ldi		REG_Z_LSB, low(_uos_callback_gest_buttons)		; dans l'espace PROGRAM
C:003b1e db03      	rcall		_uos_exec_extension_into_program
         	; ---------
         
         	; Apres l'eventuel execution dan le program, l'appui bouton peut ne pas avoir ete
         	; traite ni acquite
         	; => Si pas traite ni acquite => Continue dans le BOOTLOADER
         	;    Sinon => retour
         	;
         	; L'acquitement a t'il ete effectue dans l'espace PROGRAM ?
         	;
C:003b1f 9100 06c2 	lds		REG_TEMP_R16, UOS_G_STATES_BUTTON_NOTIF
C:003b21 9110 06c3 	lds		REG_TEMP_R17, UOS_G_STATES_BUTTON_NBR_TOUCH_NOTIF
C:003b23 2300      	tst		REG_TEMP_R16
C:003b24 f371      	breq		_uos_gest_buttons_ret
         
C:003b25 2311      	tst		REG_TEMP_R17
C:003b26 f361      	breq		_uos_gest_buttons_ret
         
         	; Non => Bouton a traite et a acquiter
         
          #if USE_TRACE_BUTTON
          #endif
         
         	; Notification vers 'DigiSpark-Monitoring'
C:003b27 9110 06c2 	lds		REG_TEMP_R17, UOS_G_STATES_BUTTON_NOTIF
C:003b29 fd16      	sbrc		REG_TEMP_R17, UOS_FLG_STATE_BUTTON_SHORT_TOUCH_IDX
C:003b2a c003      	rjmp		_uos_gest_buttons_short
         
C:003b2b fd15      	sbrc		REG_TEMP_R17, FLG_STATE_BUTTON_LONG_TOUCH_IDX
C:003b2c c004      	rjmp		_uos_gest_buttons_long
C:003b2d c05b      	rjmp		_uos_gest_buttons_rtn
         
          _uos_gest_buttons_short:
C:003b2e e7ff      	ldi		REG_Z_MSB, high(_uos_text_press_button_short << 1)
C:003b2f e1e8      	ldi		REG_Z_LSB, low(_uos_text_press_button_short << 1)
C:003b30 c002      	rjmp		_uos_gest_buttons_print_text
         
          _uos_gest_buttons_long:
C:003b31 e7ff      	ldi		REG_Z_MSB, high(_uos_text_press_button_long << 1)
C:003b32 e3e0      	ldi		REG_Z_LSB, low(_uos_text_press_button_long << 1)
         
          _uos_gest_buttons_print_text:
C:003b33 d1b5      	rcall		uos_push_text_in_fifo_tx_skip						; Print message "### Press button..."
         
C:003b34 9110 0512 	lds		REG_TEMP_R17, UOS_G_FLAGS_2						; Reset 'FLG_2_ENABLE_DERIVATION'
C:003b36 771f      	cbr		REG_TEMP_R17, UOS_FLG_2_ENABLE_DERIVATION_MSK		; a chaque appui bouton
C:003b37 9310 0512 	sts		UOS_G_FLAGS_2, REG_TEMP_R17
         
         	; Determination du bouton #N [1, 2, 3, 4]
C:003b39 9110 06c2 	lds		REG_TEMP_R17, UOS_G_STATES_BUTTON_NOTIF
C:003b3b 701f      	andi		REG_TEMP_R17, 0x0F						; Button #1, #2, #3 or #4
         
         	; Determination de l'origine de l'execution
C:003b3c dd87      	rcall		_uos_if_execution_into_zone_bootloader	; Code si execute depuis l'espace BOOTLOADER
         
C:003b3d e520      	ldi		REG_TEMP_R18, 'P'							; A priori dans l'espace "PROGRAM"
C:003b3e f011      	breq		_uos_gest_buttons_program				; Saut si pas dans l'espace "BOOTLOADER"
         
C:003b3f e422      	ldi		REG_TEMP_R18, 'B'							; Et non, dans l'espace BOOTLOADER
C:003b40 c00c      	rjmp		_uos_gest_buttons_bootloader
         	; Fin: Determination de l'origine de l'execution
         
          _uos_gest_buttons_program:
C:003b41 3011      	cpi		REG_TEMP_R17, UOS_BUTTON_1_NUM
C:003b42 f4f1      	brne		_uos_gest_buttons_more					; Saut si bouton #1 non appuye
         
         	; Appui "court" du bouton #1 dans l'espace PROGRAM ?
C:003b43 9110 06c2 	lds		REG_TEMP_R17, UOS_G_STATES_BUTTON_NOTIF
C:003b45 ff16      	sbrs		REG_TEMP_R17, UOS_FLG_STATE_BUTTON_SHORT_TOUCH_IDX
C:003b46 c01a      	rjmp		_uos_gest_buttons_more					; Ignore si appui "long" dans l'espace PROGRAM
         
         	; Oui: Bascule via le 'jump reset' de l'espace PROGRAM vers l'espace BOOTLOADER
C:003b47 94f8      	cli
         
         	; Reinitialisation de la stack d'appel et saut au BOOTLOADER
C:003b48 e008      	ldi		REG_TEMP_R16, high(RAMEND)
C:003b49 bf0e      	out		SPH, REG_TEMP_R16
         
C:003b4a ef0f      	ldi		REG_TEMP_R16, low(RAMEND)
C:003b4b bf0d      	out		SPL, REG_TEMP_R16
         
C:003b4c ca3c      	rjmp		_uos_main_bootloader
         	; Fin: Reinitialisation de la stack d'appel et saut au BOOTLOADER
         
          _uos_gest_buttons_bootloader:
C:003b4d 3011      	cpi		REG_TEMP_R17, UOS_BUTTON_1_NUM
C:003b4e f491      	brne		_uos_gest_buttons_more					; Saut si bouton #1 non appuye
         
         	; Appui "court" du bouton #1 dans l'espace BOOTLOADER ?
C:003b4f 9110 06c2 	lds		REG_TEMP_R17, UOS_G_STATES_BUTTON_NOTIF
C:003b51 ff16      	sbrs		REG_TEMP_R17, UOS_FLG_STATE_BUTTON_SHORT_TOUCH_IDX
C:003b52 c007      	rjmp		_uos_gest_buttons_1_long				; Non: Programmation de l'addon
         
         	; Oui: Bascule via le 'jump reset' de l'espace BOOTLOADER vers l'espace PROGRAM
C:003b53 94f8      	cli
         
         	; Reinitialisation de la stack d'appel et saut dans le PROGRAM
C:003b54 e008      	ldi		REG_TEMP_R16, high(RAMEND)
C:003b55 bf0e      	out		SPH, REG_TEMP_R16
         
C:003b56 ef0f      	ldi		REG_TEMP_R16, low(RAMEND)
C:003b57 bf0d      	out		SPL, REG_TEMP_R16
         
         
         	; TODO: Changer avec un saut a l'adresse 0x0000 a laquelle
         	;       un '[r]jmp uos_main_program' est defini
         	;       => Cf. 'ATmega328P_monitor.asm'
          #if 0
          #else
C:003b58 940c 0000 	jmp		reset_addr_0x0
          #endif
         	; Fin: Reinitialisation de la stack d'appel et saut dans le PROGRAM
         
          _uos_gest_buttons_1_long:
         	; L'appui "long" du bouton #1 ne doit etre pris en compte que depuis BOOTLOADER ;-)
         	; => Evite le "bypass" dans PROGRAM (cf. 'ATmega328P_uOS_P1.addons')
C:003b5a dd69      	rcall		_uos_if_execution_into_zone_bootloader
C:003b5b f029      	breq		_uos_gest_buttons_more
         
         	; Autorisation d'ecriture dans le programme si appui long bouton #1 dans BOOTLOADER
C:003b5c 9110 0512 	lds		REG_TEMP_R17, UOS_G_FLAGS_2
C:003b5e 6810      	sbr		REG_TEMP_R17, UOS_FLG_2_ENABLE_DERIVATION_MSK
C:003b5f 9310 0512 	sts		UOS_G_FLAGS_2, REG_TEMP_R17
         	;rjmp		_uos_gest_buttons_more
         	; Fin: Autorisation d'ecriture dans le programme si appui long bouton #1 dans BOOTLOADER
         
          _uos_gest_buttons_more:
C:003b61 3012      	cpi		REG_TEMP_R17, UOS_BUTTON_2_NUM
C:003b62 f439      	brne		_uos_gest_buttons_more_2				; Saut si bouton #2 non appuye
         
         	; Appui "court" du bouton #2 dans l'espace PROGRAM ou BOOTLOADER ?
C:003b63 9110 06c2 	lds		REG_TEMP_R17, UOS_G_STATES_BUTTON_NOTIF
C:003b65 ff16      	sbrs		REG_TEMP_R17, UOS_FLG_STATE_BUTTON_SHORT_TOUCH_IDX
C:003b66 c003      	rjmp		_uos_gest_buttons_more_2				; Ignore si appui "long"
         
         	; Reset de l'erreur
         	; => Arret des flash Led RED
C:003b67 2711      	clr		REG_TEMP_R17
C:003b68 9310 050e 	sts		G_TEST_ERROR, REG_TEMP_R17
         
          _uos_gest_buttons_more_2:
C:003b6a 2f02      	mov		REG_TEMP_R16, REG_TEMP_R18		; Print 'REG_TEMP_R18' ([B]ootloader ou [P]rogram)
C:003b6b 9110 0512 	lds		REG_TEMP_R17, UOS_G_FLAGS_2
C:003b6d d18c      	rcall		uos_push_1_char_in_fifo_tx_skip
         
C:003b6e 9110 06c2 	lds		REG_TEMP_R17, UOS_G_STATES_BUTTON_NOTIF
C:003b70 701f      	andi		REG_TEMP_R17, 0x0F	; Button #1, #2, #3 or #4
C:003b71 e300      	ldi		REG_TEMP_R16, '0'
C:003b72 0f01      	add		REG_TEMP_R16, REG_TEMP_R17
C:003b73 d186      	rcall		uos_push_1_char_in_fifo_tx_skip
         
         	; Ajout nombre d'appuis "court" ou "long" si >= 2
C:003b74 9110 06c3 	lds		REG_TEMP_R17, UOS_G_STATES_BUTTON_NBR_TOUCH_NOTIF
C:003b76 3012      	cpi		REG_TEMP_R17, 2
C:003b77 f028      	brlo		_uos_gest_buttons_end
         
C:003b78 e200      	ldi		REG_TEMP_R16, ' '
C:003b79 d180      	rcall		uos_push_1_char_in_fifo_tx_skip
C:003b7a 91a0 06c3 	lds		REG_X_LSB, UOS_G_STATES_BUTTON_NBR_TOUCH_NOTIF
C:003b7c d1a5      	rcall		uos_print_1_byte_hexa_skip
         
          _uos_gest_buttons_end:
C:003b7d d193      	rcall		uos_print_line_feed_skip
         	; Fin: Notification vers 'DigiSpark-Monitoring'
         
C:003b7e 2700      	clr		REG_TEMP_R16
C:003b7f 9300 06c2 	sts		UOS_G_STATES_BUTTON_NOTIF, REG_TEMP_R16
C:003b81 9300 06c3 	sts		UOS_G_STATES_BUTTON_NBR_TOUCH_NOTIF, REG_TEMP_R16
         
C:003b83 9100 0512 	lds		REG_TEMP_R16, UOS_G_FLAGS_2
C:003b85 ff07      	sbrs		REG_TEMP_R16, UOS_FLG_2_ENABLE_DERIVATION_IDX
C:003b86 c002      	rjmp		_uos_gest_buttons_rtn
         
C:003b87 e510      	ldi		REG_TEMP_R17, 'P'				; Trace [P]rogrammation
C:003b88 d1bd      	rcall		uos_print_mark_skip
         
          _uos_gest_buttons_rtn:
C:003b89 9508      	ret
         
         ; ---------
         ; Etats des boutons
         ; ---------
          _uos_get_states_buttons:
         	; Lecture PORTD
C:003b8a b109      	in			REG_TEMP_R16, PIND
C:003b8b 7f00      	andi		REG_TEMP_R16, (BUTTON_1_MSK | BUTTON_2_MSK | BUTTON_3_MSK | BUTTON_4_MSK)
         
          #if USE_TRACE_BUTTON
          #endif
         
C:003b8c 2711      	clr		REG_TEMP_R17		; Effacement numero du bouton
         
C:003b8d 3f00      	cpi		REG_TEMP_R16, (BUTTON_1_MSK | BUTTON_2_MSK | BUTTON_3_MSK | BUTTON_4_MSK)
C:003b8e f409      	brne		_uos_get_states_button_pressed
         
C:003b8f c027      	rjmp		_uos_get_states_buttons_all_high
         
          _uos_get_states_button_pressed:
         	; Complement pour determiner l'entree a l'etat bas
C:003b90 9500      	com		REG_TEMP_R16
C:003b91 7f00      	andi		REG_TEMP_R16, (BUTTON_1_MSK | BUTTON_2_MSK | BUTTON_3_MSK | BUTTON_4_MSK)
         
         	; 1 bouton est au moins appuye
         	; => Appui valide si un seul est appuye
C:003b92 e011      	ldi		REG_TEMP_R17, UOS_BUTTON_1_NUM			; A priori bouton #1 appuye
C:003b93 3100      	cpi		REG_TEMP_R16, BUTTON_1_MSK
C:003b94 f069      	breq		_uos_get_states_button_low
         
C:003b95 e012      	ldi		REG_TEMP_R17, UOS_BUTTON_2_NUM			; Non -> A priori bouton #2 appuye
C:003b96 3200      	cpi		REG_TEMP_R16, BUTTON_2_MSK
C:003b97 f051      	breq		_uos_get_states_button_low
         
C:003b98 e013      	ldi		REG_TEMP_R17, UOS_BUTTON_3_NUM			; Non -> A priori bouton #3 appuye
C:003b99 3400      	cpi		REG_TEMP_R16, BUTTON_3_MSK
C:003b9a f039      	breq		_uos_get_states_button_low
         
C:003b9b e014      	ldi		REG_TEMP_R17, UOS_BUTTON_4_NUM			; Non -> A priori bouton #4 appuye
C:003b9c 3800      	cpi		REG_TEMP_R16, BUTTON_4_MSK
C:003b9d f021      	breq		_uos_get_states_button_low
         
C:003b9e 2700      	clr		REG_TEMP_R16
C:003b9f 9300 06bc 	sts		G_NUM_BUTTON, REG_TEMP_R16
C:003ba1 c027      	rjmp		_uos_get_states_buttons_end
         
          _uos_get_states_button_low:
C:003ba2 2700      	clr		REG_TEMP_R16
C:003ba3 6800      	sbr		REG_TEMP_R16, FLG_BUTTONS_1_2_3_4_VALID_MSK
C:003ba4 6400      	sbr		REG_TEMP_R16, FLG_BUTTONS_1_2_3_4_LOW_MSK
C:003ba5 7d0f      	cbr		REG_TEMP_R16, FLG_BUTTONS_1_2_3_4_HIGH_MSK
C:003ba6 2b01      	or			REG_TEMP_R16, REG_TEMP_R17
C:003ba7 9300 06bc 	sts		G_NUM_BUTTON, REG_TEMP_R16		; New 'G_NUM_BUTTON'
         
         	; Verification pendant 'DURATION_BUTTON_ACQ' de 'G_NUM_BUTTON' @ 'G_NUM_BUTTON_PRE' si significatif
C:003ba9 e01c      	ldi		REG_TEMP_R17, TIMER_GEST_BUTTON_ACQ
C:003baa dde1      	rcall		uos_test_timer
C:003bab f456      	brtc		_uos_get_states_button_low_valid				; Saut si timer expire
         
C:003bac 9120 06bc 	lds		REG_TEMP_R18, G_NUM_BUTTON
C:003bae 702f      	andi		REG_TEMP_R18, 0x0F
C:003baf 9130 06bd 	lds		REG_TEMP_R19, G_NUM_BUTTON_PRE
C:003bb1 703f      	andi		REG_TEMP_R19, 0x0F
         
          #if USE_TRACE_BUTTON
          #endif
         
C:003bb2 2333      	tst		REG_TEMP_R19
C:003bb3 f011      	breq		_uos_get_states_button_low_valid
         
C:003bb4 1323      	cpse		REG_TEMP_R18, REG_TEMP_R19
C:003bb5 c009      	rjmp		_uos_get_states_buttons_error
         	; Fin: Verification pendant 'DURATION_BUTTON_ACQ' de 'G_NUM_BUTTON' @ 'G_NUM_BUTTON_PRE' si significatif
         
          _uos_get_states_button_low_valid:
         
          #if USE_TRACE_BUTTON
          #endif
         
C:003bb6 c012      	rjmp		_uos_get_states_buttons_end
         
          _uos_get_states_buttons_all_high:
C:003bb7 9100 06bc 	lds		REG_TEMP_R16, G_NUM_BUTTON
C:003bb9 6800      	sbr		REG_TEMP_R16, FLG_BUTTONS_1_2_3_4_VALID_MSK
C:003bba 7b0f      	cbr		REG_TEMP_R16, FLG_BUTTONS_1_2_3_4_LOW_MSK
C:003bbb 6200      	sbr		REG_TEMP_R16, FLG_BUTTONS_1_2_3_4_HIGH_MSK
C:003bbc 9300 06bc 	sts		G_NUM_BUTTON, REG_TEMP_R16
         
          #if USE_TRACE_BUTTON
          #endif
         
C:003bbe c00a      	rjmp		_uos_get_states_buttons_end
         
          _uos_get_states_buttons_error:
          #if USE_TRACE_BUTTON_ERROR
          #endif
         
C:003bbf 2700      	clr		REG_TEMP_R16
C:003bc0 9300 06bd 	sts		G_NUM_BUTTON_PRE, REG_TEMP_R16
C:003bc2 9300 06bc 	sts		G_NUM_BUTTON, REG_TEMP_R16
         
C:003bc4 9170 050f    lds      REG_TEMP_R23, UOS_G_PORTB_IMAGE
C:003bc6 7f7d      	cbr		REG_TEMP_R23, UOS_MSK_BIT_LED_RED
C:003bc7 9370 050f    sts      UOS_G_PORTB_IMAGE, REG_TEMP_R23
         
          _uos_get_states_buttons_end:
C:003bc9 9508      	ret
         ; ---------
         
         ; ---------
         ; TIMER_GEST_BUTTON
         ;
         ; Chronograme de l'appui bouton avec ses anti-rebonds
         ;
         ;  (1)      (2)           (3)      (4)      (5)
         ; --\_/-\________________________/-\_/-\_/-------------
         ;
         ; Appui  Stabilite de l'appui    Relacher Stabilite du relacher
         ;
         ;  (1) Entree(s) dans l'It PCINT2 (Changement(s) d'etat de l'entree)
         ;      => Rearmement du timer a 'DURATION_WAIT_STABILITY' a chaque changement (dernier --\__ ou __/--)
         ;
         ;  (2) A l'expiration et si l'entree est a 0 => Armement du timer a 'DURATION_WAIT_ACTION'
         ;         State: FLG_BUTTON_WAIT_DONE
         ;
         ;  (3) A l'expiration et si l'entree est a 0 => Execution de l'action + armement du timer a 'DURATION_WAIT_ACTION'
         ;      (Ignore si entree a 1) permettant la prise en compte d'un appui long
         ;         State: FLG_STATE_BUTTON_ACTION
         ;
         ;  (4) Entree(s) dans l'It PCINT2 (Changement(s) d'etat de l'entree)
         ;         State: FLG_BUTTON_WAIT_DONE
         ;      => Rearmement du timer a 'DURATION_WAIT_STABILITY' a chaque changement (dernier --\__ ou __/--)
         ;
         ;  (5) A l'expiration et si l'entree est a 1
         ;      => Fin de l'appui
         ; ---------
          _exec_timer_gest_button:
C:003bca 930f      	push		REG_TEMP_R16
C:003bcb 931f      	push		REG_TEMP_R17
C:003bcc 932f      	push		REG_TEMP_R18
C:003bcd 933f      	push		REG_TEMP_R19
         
         	; Determination de l'entree a l'etat bas
C:003bce dfbb      	rcall		_uos_get_states_buttons
         
         	; Test de coherence
          #if USE_TRACE_BUTTON_ERROR
          #endif
         
C:003bcf 9100 06bc 	lds		REG_TEMP_R16, G_NUM_BUTTON
C:003bd1 ff07      	sbrs		REG_TEMP_R16, FLG_BUTTONS_1_2_3_4_VALID_IDX
C:003bd2 c086      	rjmp		_exec_timer_gest_button_error
         
          #if USE_TRACE_BUTTON_ERROR
          #endif
         
C:003bd3 fd06      	sbrc		REG_TEMP_R16, FLG_BUTTONS_1_2_3_4_LOW_IDX
C:003bd4 c003      	rjmp		_exec_timer_gest_button_pin_low
         
C:003bd5 fd05      	sbrc		REG_TEMP_R16, FLG_BUTTONS_1_2_3_4_HIGH_IDX
C:003bd6 c051      	rjmp		_exec_timer_gest_button_pin_high
         
          #if USE_TRACE_BUTTON_ERROR
          #endif
         
C:003bd7 c081      	rjmp		_exec_timer_gest_button_error
         
         	; Entree du bouton a l'etat LOW
          _exec_timer_gest_button_pin_low:
         	; Update num button
C:003bd8 9100 06c0 	lds		REG_TEMP_R16, UOS_G_STATES_BUTTON
C:003bda 9110 06bc 	lds		REG_TEMP_R17, G_NUM_BUTTON
C:003bdc 2b01      	or			REG_TEMP_R16, REG_TEMP_R17
C:003bdd 9300 06c0 	sts		UOS_G_STATES_BUTTON, REG_TEMP_R16
         
C:003bdf 9100 06be 	lds		REG_TEMP_R16, G_FLAGS_BUTTON
C:003be1 ff00      	sbrs		REG_TEMP_R16, FLG_BUTTON_WAIT_DONE_IDX
C:003be2 c01d      	rjmp		_exec_timer_gest_button_end_of_done_on
         	;rjmp		_exec_timer_gest_button_end_of_stability_on
         
          _exec_timer_gest_button_end_of_stability_on:
C:003be3 6002      	sbr		REG_TEMP_R16, FLG_BUTTON_FALLING_EDGE_MSK
C:003be4 9300 06be 	sts		G_FLAGS_BUTTON, REG_TEMP_R16
         
          #if USE_TRACE_BUTTON
          #endif
         
C:003be6 9100 06be 	lds		REG_TEMP_R16, G_FLAGS_BUTTON
C:003be8 7f0e      	cbr		REG_TEMP_R16, FLG_BUTTON_WAIT_DONE_MSK
C:003be9 9300 06be 	sts		G_FLAGS_BUTTON, REG_TEMP_R16
         
         	; Armement a 'DURATION_WAIT_ACTION'
C:003beb e01b      	ldi		REG_TEMP_R17, TIMER_GEST_BUTTON
C:003bec ef24      	ldi		REG_TEMP_R18, (DURATION_WAIT_ACTION % 256)
C:003bed e031      	ldi		REG_TEMP_R19, (DURATION_WAIT_ACTION / 256)
C:003bee dd7b      	rcall		uos_restart_timer
         
         	; Comptabilisation des appuis fugitifs durant 'DURATION_BUTTON_ACQ'
C:003bef e01c      	ldi		REG_TEMP_R17, TIMER_GEST_BUTTON_ACQ
C:003bf0 dd9b      	rcall		uos_test_timer
C:003bf1 f456      	brtc		_exec_timer_gest_button_end_of_stability_on_end				; Saut si timer expire
         
         	; Repetition des appuis "courts"
C:003bf2 9100 06be 	lds		REG_TEMP_R16, G_FLAGS_BUTTON
C:003bf4 6100      	sbr		REG_TEMP_R16, FLG_BUTTON_REPEAT_MSK
C:003bf5 9300 06be 	sts		G_FLAGS_BUTTON, REG_TEMP_R16
         
         	; Incrementation des appuis
C:003bf7 9100 06c1 	lds		REG_TEMP_R16, UOS_G_STATES_BUTTON_NBR_TOUCH
C:003bf9 9503      	inc		REG_TEMP_R16
C:003bfa 9300 06c1 	sts		UOS_G_STATES_BUTTON_NBR_TOUCH, REG_TEMP_R16
         
          #if USE_TRACE_BUTTON
          #endif
         	; Fin: Incrementation des appuis
         	; Fin: Comptabilisation des appuis fugitifs durant 'DURATION_BUTTON_ACQ'
         
          _exec_timer_gest_button_end_of_stability_on_end:
C:003bfc 2700      	clr		REG_TEMP_R16
C:003bfd 9300 06bf 	sts		G_BUTTON_NBR_LONG_TOUCH, REG_TEMP_R16
C:003bff c05e      	rjmp		_exec_timer_gest_button_end
         
          _exec_timer_gest_button_end_of_done_on:
         	; Le bouton est vu appuye durant 'DURATION_WAIT_ACTION' (appui "long")
C:003c00 9100 06c0 	lds		REG_TEMP_R16, UOS_G_STATES_BUTTON
C:003c02 6800      	sbr		REG_TEMP_R16, FLG_STATE_BUTTON_ACTION_MSK
C:003c03 7b0f      	cbr		REG_TEMP_R16, FLG_STATE_BUTTON_SHORT_TOUCH_MSK
C:003c04 6200      	sbr		REG_TEMP_R16, FLG_STATE_BUTTON_LONG_TOUCH_MSK
C:003c05 9300 06c0 	sts		UOS_G_STATES_BUTTON, REG_TEMP_R16
         
C:003c07 9100 06be 	lds		REG_TEMP_R16, G_FLAGS_BUTTON
C:003c09 6004      	sbr		REG_TEMP_R16, FLG_BUTTON_PRESSED_MSK
C:003c0a 9300 06be 	sts		G_FLAGS_BUTTON, REG_TEMP_R16	
         
         	; Incrementation des appuis "long"
C:003c0c 9100 06c1 	lds		REG_TEMP_R16, UOS_G_STATES_BUTTON_NBR_TOUCH
C:003c0e 9503      	inc		REG_TEMP_R16
C:003c0f 9300 06c1 	sts		UOS_G_STATES_BUTTON_NBR_TOUCH, REG_TEMP_R16
         
C:003c11 9100 06bf 	lds		REG_TEMP_R16, G_BUTTON_NBR_LONG_TOUCH
C:003c13 9503      	inc		REG_TEMP_R16
C:003c14 9300 06bf 	sts		G_BUTTON_NBR_LONG_TOUCH, REG_TEMP_R16
         
          #if USE_TRACE_BUTTON
          #endif
         	; Fin: Incrementation "long"
         
          #if USE_TRACE_BUTTON
          #endif
         
         	; Presentation d'un flash de la Led YELLOW
C:003c16 9170 050f    lds      REG_TEMP_R23, UOS_G_PORTB_IMAGE
C:003c18 7d7f      	cbr		REG_TEMP_R23, UOS_MSK_BIT_LED_YELLOW
C:003c19 9370 050f    sts      UOS_G_PORTB_IMAGE, REG_TEMP_R23
         
C:003c1b e01a      	ldi		REG_TEMP_R17, TIMER_GEST_BUTTON_LED
C:003c1c e624      	ldi		REG_TEMP_R18, (DURATION_BUTTON_LED % 256)
C:003c1d e030      	ldi		REG_TEMP_R19, (DURATION_BUTTON_LED / 256)
C:003c1e dd4b      	rcall		uos_restart_timer
         
         	; Armement a 'DURATION_WAIT_ACTION'
C:003c1f e01b      	ldi		REG_TEMP_R17, TIMER_GEST_BUTTON
C:003c20 ef24      	ldi		REG_TEMP_R18, (DURATION_WAIT_ACTION % 256)
C:003c21 e031      	ldi		REG_TEMP_R19, (DURATION_WAIT_ACTION / 256)
C:003c22 dd47      	rcall		uos_restart_timer
         
          #if USE_TRACE_BUTTON
          #endif
         
         	; Armement pour la detection des appuis "long"
C:003c23 e01c      	ldi		REG_TEMP_R17, TIMER_GEST_BUTTON_ACQ
C:003c24 ec28      	ldi		REG_TEMP_R18, (DURATION_BUTTON_ACQ % 256)
C:003c25 e030      	ldi		REG_TEMP_R19, (DURATION_BUTTON_ACQ / 256)
C:003c26 dd43      	rcall		uos_restart_timer
         
C:003c27 c036      	rjmp		_exec_timer_gest_button_end
         	; Fin: Entree du bouton a l'etat LOW
         
         	; Entree du bouton a l'etat HIGH
          _exec_timer_gest_button_pin_high:
C:003c28 9100 06be 	lds		REG_TEMP_R16, G_FLAGS_BUTTON
C:003c2a ff00      	sbrs		REG_TEMP_R16, FLG_BUTTON_WAIT_DONE_IDX
C:003c2b c02c      	rjmp		_exec_timer_gest_button_end_of_done_off
         	;rjmp		_exec_timer_gest_button_end_of_stability_off
         
          _exec_timer_gest_button_end_of_stability_off:
         	; Fin des rebonds au relacher du boutton
C:003c2c 7f0e      	cbr		REG_TEMP_R16, FLG_BUTTON_WAIT_DONE_MSK
C:003c2d 6008      	sbr		REG_TEMP_R16, FLG_BUTTON_RISING_EDGE_MSK
C:003c2e 9300 06be 	sts		G_FLAGS_BUTTON, REG_TEMP_R16
         
         	; Relacher de l'appui
          #if USE_TRACE_BUTTON
          #endif
         
         	; Le bouton est vu relache apres un appui "court" ou apres le dernier appui "long"
         	; => Pas d'incrementation si dernier appui "long"
         
C:003c30 9100 06c0 	lds		REG_TEMP_R16, UOS_G_STATES_BUTTON
C:003c32 6800      	sbr		REG_TEMP_R16, FLG_STATE_BUTTON_ACTION_MSK
C:003c33 6400      	sbr		REG_TEMP_R16, FLG_STATE_BUTTON_SHORT_TOUCH_MSK
C:003c34 9300 06c0 	sts		UOS_G_STATES_BUTTON, REG_TEMP_R16
         
         	; Incrementation des appuis si pas en 'FLG_STATE_BUTTON_LONG_TOUCH'
C:003c36 9100 06c0 	lds		REG_TEMP_R16, UOS_G_STATES_BUTTON
C:003c38 fd05      	sbrc		REG_TEMP_R16, FLG_STATE_BUTTON_LONG_TOUCH_IDX
C:003c39 c009      	rjmp		_exec_timer_gest_button_end_of_stability_off_no_inc
         
C:003c3a 9100 06be 	lds		REG_TEMP_R16, G_FLAGS_BUTTON
C:003c3c fd04      	sbrc		REG_TEMP_R16, FLG_BUTTON_REPEAT_IDX
C:003c3d c005      	rjmp		_exec_timer_gest_button_end_of_stability_off_no_inc
         
C:003c3e 9100 06c1 	lds		REG_TEMP_R16, UOS_G_STATES_BUTTON_NBR_TOUCH
C:003c40 9503      	inc		REG_TEMP_R16
C:003c41 9300 06c1 	sts		UOS_G_STATES_BUTTON_NBR_TOUCH, REG_TEMP_R16
         
          #if USE_TRACE_BUTTON
          #endif
         	; Fin: Incrementation des appuis si pas en 'FLG_STATE_BUTTON_LONG_TOUCH'
         
          _exec_timer_gest_button_end_of_stability_off_no_inc:
C:003c43 2700      	clr		REG_TEMP_R16
C:003c44 9300 06bf 	sts		G_BUTTON_NBR_LONG_TOUCH, REG_TEMP_R16
         
         	;rjmp		_exec_timer_gest_button_end_of_stability_off_more
         
          _exec_timer_gest_button_end_of_stability_off_more:
         
         	; Presentation d'un flash de la Led YELLOW
C:003c46 9170 050f    lds      REG_TEMP_R23, UOS_G_PORTB_IMAGE
C:003c48 7d7f      	cbr		REG_TEMP_R23, UOS_MSK_BIT_LED_YELLOW
C:003c49 9370 050f    sts      UOS_G_PORTB_IMAGE, REG_TEMP_R23
         
C:003c4b e01a      	ldi		REG_TEMP_R17, TIMER_GEST_BUTTON_LED
C:003c4c e624      	ldi		REG_TEMP_R18, (DURATION_BUTTON_LED % 256)
C:003c4d e030      	ldi		REG_TEMP_R19, (DURATION_BUTTON_LED / 256)
C:003c4e dd1b      	rcall		uos_restart_timer
         	; Fin: Presentation d'un flash de la Led YELLOW
         
         	; Armement pour la detection des appuis fugitifs successifs
C:003c4f 9100 06c0 	lds		REG_TEMP_R16, UOS_G_STATES_BUTTON
C:003c51 fd05      	sbrc		REG_TEMP_R16, FLG_STATE_BUTTON_LONG_TOUCH_IDX
C:003c52 c004      	rjmp		_exec_timer_gest_button_end_of_stability_off_no_armed
         
          #if USE_TRACE_BUTTON
          #endif
         
C:003c53 e01c      	ldi		REG_TEMP_R17, TIMER_GEST_BUTTON_ACQ
C:003c54 ec28      	ldi		REG_TEMP_R18, (DURATION_BUTTON_ACQ % 256)
C:003c55 e030      	ldi		REG_TEMP_R19, (DURATION_BUTTON_ACQ / 256)
C:003c56 dd13      	rcall		uos_restart_timer
         
          _exec_timer_gest_button_end_of_stability_off_no_armed:
C:003c57 c006      	rjmp		_exec_timer_gest_button_end
         
          _exec_timer_gest_button_end_of_done_off:
         	; Le bouton est vu relache durant 'DURATION_WAIT_STABILITY' => Fin de(s) appui(s)
         	; => Etat non detecte systematiquement
         
          #if USE_TRACE_BUTTON
          #endif
         
C:003c58 c005      	rjmp		_exec_timer_gest_button_end
         	; Fin: Entree du bouton a l'etat HIGH
         
          _exec_timer_gest_button_error:
          #if USE_TRACE_BUTTON_ERROR
          #endif
         
C:003c59 9170 050f    lds      REG_TEMP_R23, UOS_G_PORTB_IMAGE
C:003c5b 7f7d      	cbr		REG_TEMP_R23, UOS_MSK_BIT_LED_RED
C:003c5c 9370 050f    sts      UOS_G_PORTB_IMAGE, REG_TEMP_R23
         	;rjmp		_exec_timer_gest_button_end
         
          _exec_timer_gest_button_end:
C:003c5e 913f      	pop		REG_TEMP_R19
C:003c5f 912f      	pop		REG_TEMP_R18
C:003c60 911f      	pop		REG_TEMP_R17
C:003c61 910f      	pop		REG_TEMP_R16
C:003c62 9508      	ret
         ; ---------
         
         ; ---------
         ; TIMER_GEST_BUTTON_LED
         ;
         ; Flash Led YELLOW a chaque prise en compte d'un appui bouton ("court" ou "long")
         ; ---------
          _exec_ext_timer_10:
C:003c63 9170 050f    lds      REG_TEMP_R23, UOS_G_PORTB_IMAGE
C:003c65 6270      	sbr		REG_TEMP_R23, UOS_MSK_BIT_LED_YELLOW
C:003c66 9370 050f    sts      UOS_G_PORTB_IMAGE, REG_TEMP_R23
         
C:003c68 9508      	ret
         ; ---------
         
         ; ---------
         ; TIMER_GEST_BUTTON_ACQ
         ;
         ; Recopie des etats d'un bouton pour traitement en fond de tache
         ;
         ; Mise a disposition si 'G_FLAGS_BUTTON'est egal a ('FLG_BUTTON_WAIT_DONE' toujours a 0):
         ;                D4                     D3                 D2                      D1 D0
         ; ----------------- ---------------------- ------------------ ----------------------- --
         ; FLG_BUTTON_REPEAT FLG_BUTTON_RISING_EDGE FLG_BUTTON_PRESSED FLG_BUTTON_FALLING_EDGE
         ;                 0                      1                  0                       1  0 => Appui "court"
         ;                 1                      1                  0                       1  0 => Appuis "court" successif
         ;                 0                      0                  1                       1  0 => 1st appui "long"
         ;                 0                      1                  1                       1  0 => 1st appui "long"
         ;                 0                      0                  1                       X  0 => Appuis "long" suivants
         ; ---------
          _exec_timer_gest_button_acq:
C:003c69 9170 050f    lds      REG_TEMP_R23, UOS_G_PORTB_IMAGE
C:003c6b 6072      	sbr		REG_TEMP_R23, UOS_MSK_BIT_LED_RED
C:003c6c 9370 050f    sts      UOS_G_PORTB_IMAGE, REG_TEMP_R23
         
C:003c6e 9100 06be 	lds		REG_TEMP_R16, G_FLAGS_BUTTON
         
          #if USE_TRACE_BUTTON
          #endif
         
         	; Appui "court" unique ?
C:003c70 300a      	cpi		REG_TEMP_R16, (FLG_BUTTON_RISING_EDGE_MSK | FLG_BUTTON_FALLING_EDGE_MSK)
C:003c71 f0e1      	breq		_exec_timer_gest_button_acq_available
         
         	; Appuis "court" successif ?
C:003c72 310a      	cpi		REG_TEMP_R16, (FLG_BUTTON_REPEAT_MSK | FLG_BUTTON_RISING_EDGE_MSK | FLG_BUTTON_FALLING_EDGE_MSK)
C:003c73 f0d1      	breq		_exec_timer_gest_button_acq_available
         
         	; Appuis "long" repetitifs ?
C:003c74 3004      	cpi		REG_TEMP_R16, (FLG_BUTTON_PRESSED_MSK)
C:003c75 f029      	breq		_exec_timer_gest_button_acq_long_touch
         
         	; 1st appui "long" ?
C:003c76 3006      	cpi		REG_TEMP_R16, (FLG_BUTTON_PRESSED_MSK | FLG_BUTTON_FALLING_EDGE_MSK)
C:003c77 f019      	breq		_exec_timer_gest_button_acq_long_touch
         
         	; 1st appui "long" ?
C:003c78 300e      	cpi		REG_TEMP_R16, (FLG_BUTTON_RISING_EDGE_MSK | FLG_BUTTON_PRESSED_MSK | FLG_BUTTON_FALLING_EDGE_MSK)
C:003c79 f009      	breq		_exec_timer_gest_button_acq_long_touch
         
C:003c7a c029      	rjmp		_exec_timer_gest_button_acq_not_available
         
          _exec_timer_gest_button_acq_long_touch:
         	; Increment 'G_BUTTON_NBR_LONG_TOUCH' @ 'G_STATES_BUTTON'
C:003c7b 9100 06c0 	lds		REG_TEMP_R16, UOS_G_STATES_BUTTON
C:003c7d 7e00      	andi		REG_TEMP_R16, (FLG_STATE_BUTTON_ACTION_MSK | FLG_STATE_BUTTON_SHORT_TOUCH_MSK | FLG_STATE_BUTTON_LONG_TOUCH_MSK)
C:003c7e 3e00      	cpi		REG_TEMP_R16, (FLG_STATE_BUTTON_ACTION_MSK | FLG_STATE_BUTTON_SHORT_TOUCH_MSK | FLG_STATE_BUTTON_LONG_TOUCH_MSK)
C:003c7f f429      	brne		_exec_timer_gest_button_acq_long_touch_more
         
C:003c80 9100 06bf 	lds		REG_TEMP_R16, G_BUTTON_NBR_LONG_TOUCH
C:003c82 9503      	inc		REG_TEMP_R16
C:003c83 9300 06bf 	sts		G_BUTTON_NBR_LONG_TOUCH, REG_TEMP_R16
         	; Fin: Increment 'G_BUTTON_NBR_LONG_TOUCH' @ 'G_STATES_BUTTON'
         
          _exec_timer_gest_button_acq_long_touch_more:
C:003c85 9100 06bf 	lds		REG_TEMP_R16, G_BUTTON_NBR_LONG_TOUCH
C:003c87 9300 06c1 	sts		UOS_G_STATES_BUTTON_NBR_TOUCH, REG_TEMP_R16
         
         	; Effacement 'FLG_STATE_BUTTON_SHORT_TOUCH'
         	; => Permet de gerer que les 2 etats 'FLG_STATE_BUTTON_SHORT_TOUCH' eor 'FLG_STATE_BUTTON_LONG_TOUCH'
C:003c89 9100 06c0 	lds		REG_TEMP_R16, UOS_G_STATES_BUTTON
C:003c8b 7b0f      	cbr		REG_TEMP_R16, FLG_STATE_BUTTON_SHORT_TOUCH_MSK
C:003c8c 9300 06c0 	sts		UOS_G_STATES_BUTTON, REG_TEMP_R16
         	; Fin: Effacement 'FLG_STATE_BUTTON_SHORT_TOUCH'
         
          _exec_timer_gest_button_acq_available:
         	; Test si la notification precedente a ete acquitee
C:003c8e 9100 06c2 	lds		REG_TEMP_R16, UOS_G_STATES_BUTTON_NOTIF
C:003c90 9110 06c3 	lds		REG_TEMP_R17, UOS_G_STATES_BUTTON_NBR_TOUCH_NOTIF
C:003c92 2300      	tst		REG_TEMP_R16
C:003c93 f459      	brne		_exec_timer_gest_button_acq_available_error
         
C:003c94 2311      	tst		REG_TEMP_R17
C:003c95 f449      	brne		_exec_timer_gest_button_acq_available_error
         
C:003c96 9110 06c0 	lds		REG_TEMP_R17, UOS_G_STATES_BUTTON
C:003c98 9310 06c2 	sts		UOS_G_STATES_BUTTON_NOTIF, REG_TEMP_R17
C:003c9a 9100 06c1 	lds		REG_TEMP_R16, UOS_G_STATES_BUTTON_NBR_TOUCH
C:003c9c 9300 06c3 	sts		UOS_G_STATES_BUTTON_NBR_TOUCH_NOTIF, REG_TEMP_R16
         
          #if USE_TRACE_BUTTON
          #endif
         
C:003c9e c005      	rjmp		_exec_timer_gest_button_acq_end
         
          _exec_timer_gest_button_acq_available_error:
C:003c9f 9170 050f    lds      REG_TEMP_R23, UOS_G_PORTB_IMAGE
C:003ca1 7f7d      	cbr		REG_TEMP_R23, UOS_MSK_BIT_LED_RED
C:003ca2 9370 050f    sts      UOS_G_PORTB_IMAGE, REG_TEMP_R23
         	;rjmp		_exec_timer_gest_button_acq_not_available
         
          _exec_timer_gest_button_acq_not_available:
          #if USE_TRACE_BUTTON
          #endif
         
          _exec_timer_gest_button_acq_end:
C:003ca4 9100 06bc 	lds		REG_TEMP_R16, G_NUM_BUTTON
C:003ca6 9300 06bd 	sts		G_NUM_BUTTON_PRE, REG_TEMP_R16
         
C:003ca8 2700      	clr		REG_TEMP_R16
C:003ca9 9300 06c1 	sts		UOS_G_STATES_BUTTON_NBR_TOUCH, REG_TEMP_R16
C:003cab 9300 06c0 	sts		UOS_G_STATES_BUTTON, REG_TEMP_R16
C:003cad 9300 06be 	sts		G_FLAGS_BUTTON, REG_TEMP_R16
C:003caf 9300 06bc 	sts		G_NUM_BUTTON, REG_TEMP_R16
         
C:003cb1 9508      	ret
         ; ---------
         ; ======================================================= Gestion des 4 boutons
         
         ; End of file
          ; End of file
          .include		"ATmega328P_uOS_Print.asm"
         ; "$Id: ATmega328P_uOS_Print.asm,v 1.6 2026/02/18 18:01:34 administrateur Exp $"
         
          .cseg
         
         ;--------------------
         ; Lecture et sauvegarde des informations de l'EEPROM
         ;--------------------
          uos_set_infos_from_eeprom:
         	; => Prompt "### EEPROM..."
C:003cb2 e028      	ldi		REG_TEMP_R18, 8
C:003cb3 e7fe      	ldi		REG_Z_MSB, ((_uos_text_prompt_eeprom_version << 1) / 256)
C:003cb4 eee8      	ldi		REG_Z_LSB, ((_uos_text_prompt_eeprom_version << 1) % 256)
C:003cb5 d037      	rcall		uos_push_text_in_fifo_tx
         
         	; Lecture de la version de l'EEPROM definie dans l'EEPROM
C:003cb6 e0b0      	ldi		REG_X_MSB, high(EEPROM_ADDR_VERSION)
C:003cb7 e0a0      	ldi		REG_X_LSB, low(EEPROM_ADDR_VERSION)
C:003cb8 d0b1      	rcall		uos_push_text_in_fifo_tx_from_eeprom
C:003cb9 d05b      	rcall		uos_print_line_feed
         
         	; => Prompt "### Type..."
C:003cba e7fe      	ldi		REG_Z_MSB, ((_uos_text_prompt_type << 1) / 256)
C:003cbb efe6      	ldi		REG_Z_LSB, ((_uos_text_prompt_type << 1) % 256)
C:003cbc d030      	rcall		uos_push_text_in_fifo_tx
         
         	; Lecture du type de platine defini dans l'EEPROM
C:003cbd e0b0      	ldi		REG_X_MSB, high(EEPROM_ADDR_TYPE);
C:003cbe e0a8      	ldi		REG_X_LSB, low(EEPROM_ADDR_TYPE);
C:003cbf d26e      	rcall		uos_eeprom_read_byte
         
C:003cc0 9300 050b 	sts		UOS_G_HEADER_TYPE_PLATINE, REG_TEMP_R16
         
C:003cc2 d046      	rcall		uos_convert_and_put_fifo_tx
C:003cc3 d051      	rcall		uos_print_line_feed
         
         	; => Prompt "### Id..."
C:003cc4 e7ff      	ldi		REG_Z_MSB, ((_uos_text_prompt_id << 1) / 256)
C:003cc5 e0e2      	ldi		REG_Z_LSB, ((_uos_text_prompt_id << 1) % 256)
C:003cc6 d026      	rcall		uos_push_text_in_fifo_tx
         	
         	; Lecture de l'Id de la Platine defini dans l'EEPROM
C:003cc7 e0b0      	ldi		REG_X_MSB, high(EEPROM_ADDR_ID);
C:003cc8 e0a9      	ldi		REG_X_LSB, low(EEPROM_ADDR_ID);
C:003cc9 d264      	rcall		uos_eeprom_read_byte
         
C:003cca 9300 050c 	sts		UOS_G_HEADER_INDEX_PLATINE, REG_TEMP_R16
         
C:003ccc d03c      	rcall		uos_convert_and_put_fifo_tx
C:003ccd d047      	rcall		uos_print_line_feed
         
         	; Lecture de la vitesse configuree dans l'EEPROM
         	; => Prompt "### Bauds..."
C:003cce e7ff      	ldi		REG_Z_MSB, ((_uos_text_prompt_bauds_value << 1) / 256)
C:003ccf e0ec      	ldi		REG_Z_LSB, ((_uos_text_prompt_bauds_value << 1) % 256)
C:003cd0 d01c      	rcall		uos_push_text_in_fifo_tx
         	
C:003cd1 e0b0      	ldi		REG_X_MSB, high(EEPROM_ADDR_BAUDS_IDX);
C:003cd2 e0aa      	ldi		REG_X_LSB, low(EEPROM_ADDR_BAUDS_IDX);
         
          #if USE_AVRSIMU
          #else
C:003cd3 d25a      	rcall		uos_eeprom_read_byte
          #endif
         
C:003cd4 3f0f      	cpi		REG_TEMP_R16, 0xFF
C:003cd5 f409      	brne		uos_set_infos_from_eeprom_more
C:003cd6 e001      	ldi		REG_TEMP_R16, 1						; Set to 9600 bauds (value by default)
         
          uos_set_infos_from_eeprom_more:
C:003cd7 9300 050d 	sts		UOS_G_HEADER_BAUDS_VALUE, REG_TEMP_R16
         
          #if 0
          #else
C:003cd9 d0a7      	rcall		get_index_bauds_rate_value
C:003cda d012      	rcall		uos_push_text_in_fifo_tx
          #endif
         
C:003cdb d039      	rcall		uos_print_line_feed
         	; Fin: Preparation emission des prompts d'accueil
         
C:003cdc 9508      	ret
         ; ---------
         
         ; ---------
         ; Reset the 'UOS_FLG_0_PRINT_SKIP' flag
         ; ---------
          uos_reset_skip_print:
C:003cdd 9170 0510 	lds		REG_TEMP_R23, UOS_G_FLAGS_0
C:003cdf 7d7f      	cbr		REG_TEMP_R23, UOS_FLG_0_PRINT_SKIP_MSK
C:003ce0 9370 0510 	sts		UOS_G_FLAGS_0, REG_TEMP_R23
         
C:003ce2 9508      	ret
         ; ---------
         
         ; ---------
         ; Set the 'UOS_FLG_0_PRINT_SKIP' flag
         ; ---------
          uos_set_skip_print:
C:003ce3 9170 0510 	lds		REG_TEMP_R23, UOS_G_FLAGS_0
C:003ce5 6270      	sbr		REG_TEMP_R23, UOS_FLG_0_PRINT_SKIP_MSK
C:003ce6 9370 0510 	sts		UOS_G_FLAGS_0, REG_TEMP_R23
         
C:003ce8 9508      	ret
         ; ---------
         
         ; ---------
         ; Mise dans la FIFO/Tx d'un texte termine par '\0'
         ;
         ; Usage:
         ;      ldi		REG_Z_MSB, <address MSB>
         ;      ldi		REG_Z_LSB, <address LSB>
         ;      rcall   uos_push_text_in_fifo_tx
         ;
         ; Registres utilises
         ;    REG_Z_LSB:REG_Z_LSB -> Pointeur sur le texte en memoire programme (preserve)
         ;    REG_TEMP_R16        -> Working register (preserve)
         ; ---------
          uos_push_text_in_fifo_tx_skip:
C:003ce9 9170 0510 	lds		REG_TEMP_R23, UOS_G_FLAGS_0
C:003ceb fd75      	sbrc		REG_TEMP_R23, UOS_FLG_0_PRINT_SKIP_IDX		; Pas de trace si 'FLG_0_PRINT_SKIP' affirme
         
C:003cec 9508      	ret
         
          uos_push_text_in_fifo_tx:
C:003ced 93ff      	push		REG_Z_MSB
C:003cee 93ef      	push		REG_Z_LSB
C:003cef 930f      	push		REG_TEMP_R16
         
          _uos_push_text_in_fifo_tx_loop:
C:003cf0 9105      	lpm		REG_TEMP_R16, Z+
C:003cf1 3000      	cpi		REG_TEMP_R16, CHAR_NULL		; '\0' terminal ?
C:003cf2 f019      	breq		_uos_push_text_in_fifo_tx_end
         
C:003cf3 2e30      	mov		REG_R3, REG_TEMP_R16
C:003cf4 dd8b      	rcall		_uos_uart_fifo_tx_write
         
C:003cf5 cffa      	rjmp		_uos_push_text_in_fifo_tx_loop
         
          _uos_push_text_in_fifo_tx_end:
C:003cf6 910f      	pop		REG_TEMP_R16
C:003cf7 91ef      	pop		REG_Z_LSB
C:003cf8 91ff      	pop		REG_Z_MSB
C:003cf9 9508      	ret
         ; ---------
         
         ; ---------
         ; Mise dans la FIFO/Tx d'un char
         ;
         ; Usage:
         ;      ldi		REG_TEMP_R16, <value>
         ;      rcall   uos_push_1_char_in_fifo_tx
         ;
         ; Registres utilises
         ;    REG_TEMP_R16 -> Working register
         ; ---------
          uos_push_1_char_in_fifo_tx_skip:
C:003cfa 9170 0510 	lds		REG_TEMP_R23, UOS_G_FLAGS_0
C:003cfc fd75      	sbrc		REG_TEMP_R23, UOS_FLG_0_PRINT_SKIP_IDX		; Pas de trace si 'FLG_0_PRINT_SKIP' affirme
         
C:003cfd 9508      	ret
         
          uos_push_1_char_in_fifo_tx:
C:003cfe 2e30      	mov		REG_R3, REG_TEMP_R16
C:003cff dd80      	rcall		_uos_uart_fifo_tx_write
         
C:003d00 9508      	ret
         ; ---------
         
         ; ---------
          _uos_convert_nibble_to_ascii:
C:003d01 700f      	andi		REG_TEMP_R16, 0x0f
C:003d02 e7ff      	ldi		REG_Z_MSB, high(_uos_text_convert_hex_to_min_ascii_table << 1)
C:003d03 e4e8      	ldi		REG_Z_LSB, low(_uos_text_convert_hex_to_min_ascii_table << 1)
C:003d04 0fe0      	add		REG_Z_LSB, REG_TEMP_R16
C:003d05 2700      	clr		REG_TEMP_R16
C:003d06 1ff0      	adc		REG_Z_MSB, REG_TEMP_R16
C:003d07 9104      	lpm		REG_TEMP_R16, Z
         
          _uos_convert_nibble_to_ascii_rtn:
C:003d08 9508      	ret
         ; ---------
         
         ; ---------
         ; Mise dans la FIFO/Tx d'un byte converti en 2 hex-char
         ; => En majuscule si '_uos_text_convert_hex_to_maj_ascii_table' utilisee
         ; => En minuscule si '_uos_text_convert_hex_to_min_ascii_table' utilisee
         ;
         ; Usage:
         ;      ldi		REG_TEMP_R16, <value>
         ;      rcall   uos_convert_and_put_fifo_tx
         ; ---------
          uos_convert_and_put_fifo_tx:
C:003d09 930f      	push		REG_TEMP_R16		; Sauvegarde de la valeur a convertir et ecrire
         
C:003d0a 9502      	swap		REG_TEMP_R16		; Copie Bits<7-4> dans Bits<3-0>
C:003d0b dff5      	rcall		_uos_convert_nibble_to_ascii
C:003d0c dff1      	rcall    uos_push_1_char_in_fifo_tx
         
C:003d0d 910f      	pop		REG_TEMP_R16		; Reprise de la valeur a convertir et ecrire
         
C:003d0e dff2      	rcall		_uos_convert_nibble_to_ascii
C:003d0f dfee      	rcall    uos_push_1_char_in_fifo_tx
         
C:003d10 9508      	ret
         ; ---------
         
         ; ---------
          uos_print_line_feed_skip:
C:003d11 9170 0510 	lds		REG_TEMP_R23, UOS_G_FLAGS_0
C:003d13 fd75      	sbrc		REG_TEMP_R23, UOS_FLG_0_PRINT_SKIP_IDX		; Pas de trace si 'FLG_0_PRINT_SKIP' affirme
         
C:003d14 9508      	ret
         
          uos_print_line_feed:
C:003d15 93ff      	push		REG_Z_MSB
C:003d16 93ef      	push		REG_Z_LSB
         
C:003d17 e7ff      	ldi		REG_Z_MSB, ((_uos_text_line_feed << 1) / 256)
C:003d18 e9e4      	ldi		REG_Z_LSB, ((_uos_text_line_feed << 1) % 256)
C:003d19 dfd3      	rcall		uos_push_text_in_fifo_tx
         
C:003d1a 9170 0511 	lds		REG_TEMP_R23, UOS_G_FLAGS_1
C:003d1c 6470      	sbr		REG_TEMP_R23, FLG_1_UART_FIFO_TX_TO_SEND_MSK	; Caracteres mis en FIFO a emettre ;-)
C:003d1d 9370 0511 	sts		UOS_G_FLAGS_1, REG_TEMP_R23
         
C:003d1f 91ef      	pop		REG_Z_LSB
C:003d20 91ff      	pop		REG_Z_MSB
C:003d21 9508      	ret
         ; ---------
         
         ; ---------
          uos_print_1_byte_hexa_skip:
C:003d22 9170 0510 	lds		REG_TEMP_R23, UOS_G_FLAGS_0
C:003d24 fd75      	sbrc		REG_TEMP_R23, UOS_FLG_0_PRINT_SKIP_IDX		; Pas de trace si 'FLG_0_PRINT_SKIP' affirme
         
C:003d25 9508      	ret
         
          uos_print_1_byte_hexa:
C:003d26 93ff      	push		REG_Z_MSB
C:003d27 93ef      	push		REG_Z_LSB
         
         	; Emission en hexa du contenu de 'REG_X_LSB'
C:003d28 e7ff      	ldi		REG_Z_MSB, ((uos_text_hexa_value << 1) / 256)
C:003d29 e8ea      	ldi		REG_Z_LSB, ((uos_text_hexa_value << 1) % 256)
C:003d2a dfc2      	rcall		uos_push_text_in_fifo_tx
         
C:003d2b 2f0a      	mov		REG_TEMP_R16, REG_X_LSB
C:003d2c dfdc      	rcall		uos_convert_and_put_fifo_tx
         
C:003d2d e7ff      	ldi		REG_Z_MSB, ((_uos_text_hexa_value_end << 1) / 256)
C:003d2e e8ee      	ldi		REG_Z_LSB, ((_uos_text_hexa_value_end << 1) % 256)
C:003d2f dfbd      	rcall		uos_push_text_in_fifo_tx
         
C:003d30 91ef      	pop		REG_Z_LSB
C:003d31 91ff      	pop		REG_Z_MSB
C:003d32 9508      	ret
         ; ---------
         
         ; ---------
          uos_print_2_bytes_hexa_skip:
C:003d33 9170 0510 	lds		REG_TEMP_R23, UOS_G_FLAGS_0
C:003d35 fd75      	sbrc		REG_TEMP_R23, UOS_FLG_0_PRINT_SKIP_IDX		; Pas de trace si 'FLG_0_PRINT_SKIP' affirme
         
C:003d36 9508      	ret
         
          uos_print_2_bytes_hexa:
C:003d37 93ff      	push		REG_Z_MSB
C:003d38 93ef      	push		REG_Z_LSB
         
         	; Emission en hexa du contenu de 'REG_X_MSB:REG_X_LSB'
C:003d39 e7ff      	ldi		REG_Z_MSB, ((uos_text_hexa_value << 1) / 256)
C:003d3a e8ea      	ldi		REG_Z_LSB, ((uos_text_hexa_value << 1) % 256)
C:003d3b dfb1      	rcall		uos_push_text_in_fifo_tx
         
C:003d3c 2f0b      	mov		REG_TEMP_R16, REG_X_MSB
C:003d3d dfcb      	rcall		uos_convert_and_put_fifo_tx
         
C:003d3e 2f0a      	mov		REG_TEMP_R16, REG_X_LSB
C:003d3f dfc9      	rcall		uos_convert_and_put_fifo_tx
         
C:003d40 e7ff      	ldi		REG_Z_MSB, ((_uos_text_hexa_value_end << 1) / 256)
C:003d41 e8ee      	ldi		REG_Z_LSB, ((_uos_text_hexa_value_end << 1) % 256)
C:003d42 dfaa      	rcall		uos_push_text_in_fifo_tx
         
C:003d43 91ef      	pop		REG_Z_LSB
C:003d44 91ff      	pop		REG_Z_MSB
C:003d45 9508      	ret
         ; ---------
         
         ; ---------
         ; Marquage traces
         ; ---------
          uos_print_mark_skip:
C:003d46 9170 0510 	lds		REG_TEMP_R23, UOS_G_FLAGS_0
C:003d48 fd75      	sbrc		REG_TEMP_R23, UOS_FLG_0_PRINT_SKIP_IDX		; Pas de trace si 'FLG_0_PRINT_SKIP' affirme
         
C:003d49 9508      	ret
         
          uos_print_mark:
C:003d4a 930f      	push		REG_TEMP_R16
C:003d4b e003      	ldi		REG_TEMP_R16, 3
         
          _uos_print_mark_loop:
C:003d4c 930f      	push		REG_TEMP_R16
C:003d4d 3002      	cpi		REG_TEMP_R16, 2
C:003d4e f411      	brne		_uos_print_mark_loop_a
C:003d4f 2f01      	mov		REG_TEMP_R16, REG_TEMP_R17
C:003d50 c001      	rjmp		_uos_print_mark_loop_b
         
          _uos_print_mark_loop_a:
C:003d51 e20d      	ldi		REG_TEMP_R16, '-'
         
          _uos_print_mark_loop_b:
C:003d52 dfab      	rcall		uos_push_1_char_in_fifo_tx
C:003d53 910f      	pop		REG_TEMP_R16
C:003d54 950a      	dec		REG_TEMP_R16
C:003d55 f7b1      	brne		_uos_print_mark_loop
         
C:003d56 dfbe      	rcall		uos_print_line_feed
         
C:003d57 910f      	pop		REG_TEMP_R16
         
C:003d58 9508      	ret
         ; ---------
         
         ; ---------
         ; Traces pour les developpements
         ; ---------
          uos_print_mark_3_char_skip:
C:003d59 9170 0510 	lds		REG_TEMP_R23, UOS_G_FLAGS_0
C:003d5b fd75      	sbrc		REG_TEMP_R23, UOS_FLG_0_PRINT_SKIP_IDX		; Pas de trace si 'FLG_0_PRINT_SKIP' affirme
         
C:003d5c 9508      	ret
         
          uos_print_mark_3_char:
C:003d5d 930f      	push		REG_TEMP_R16
         
C:003d5e 2f01      	mov		REG_TEMP_R16, REG_TEMP_R17
C:003d5f df9e      	rcall		uos_push_1_char_in_fifo_tx
         
C:003d60 2f02      	mov		REG_TEMP_R16, REG_TEMP_R18
C:003d61 df9c      	rcall		uos_push_1_char_in_fifo_tx
         
C:003d62 2f03      	mov		REG_TEMP_R16, REG_TEMP_R19
C:003d63 df9a      	rcall		uos_push_1_char_in_fifo_tx
         
C:003d64 910f      	pop		REG_TEMP_R16
         
C:003d65 9508      	ret
         ; ---------
         
         ; ---------
         ; Mise dans la FIFO/Tx d'un texte lu de l'EEPROM et termine par '\0'
         ; => Si un 0xff est lu (EEPROM non initialisee), abandon de la lecture
         ; => Limitation a 8 caracteres lus pour eviter un bouclage ;-)
         ;
         ; Usage:
         ;      ldi		REG_TEMP_R18, 8
         ;      ldi		REG_X_MSB, <address MSB>
         ;      ldi		REG_X_LSB, <address LSB>
         ;      rcall   uos_push_text_in_fifo_tx_from_eeprom
         ;
         ; ---------
          uos_push_text_in_fifo_tx_from_eeprom_skip:
C:003d66 9170 0510 	lds		REG_TEMP_R23, UOS_G_FLAGS_0
C:003d68 fd75      	sbrc		REG_TEMP_R23, UOS_FLG_0_PRINT_SKIP_IDX		; Pas de trace si 'FLG_0_PRINT_SKIP' affirme
         
C:003d69 9508      	ret
         
          uos_push_text_in_fifo_tx_from_eeprom:
          uos_push_text_in_fifo_tx_from_eeprom_loop:
C:003d6a d1c3      	rcall		uos_eeprom_read_byte
         
C:003d6b 3f0f      	cpi		REG_TEMP_R16, 0xff
C:003d6c f031      	breq		uos_push_text_in_fifo_tx_from_eeprom_end
         
C:003d6d 2300      	tst		REG_TEMP_R16
C:003d6e f021      	breq		uos_push_text_in_fifo_tx_from_eeprom_end
         
C:003d6f df8e      	rcall		uos_push_1_char_in_fifo_tx
         
C:003d70 9611      	adiw		REG_X_LSB, 1
C:003d71 952a      	dec		REG_TEMP_R18
C:003d72 f7b9      	brne		uos_push_text_in_fifo_tx_from_eeprom_loop
         
          uos_push_text_in_fifo_tx_from_eeprom_end:
C:003d73 9508      	ret
         ; ---------
         
         ; ---------
         ; Mise en FIFO/Tx d'un buffer 'C' defini en SRAM dans l'ordre "naturel"
         ; comme "### Enter in Program C (0x05a0)":
         ;       00000130  34 78 29 0a 00 23 23 23  20 45 6e 74 65 72 20 69  |4x)..### Enter i|
         ;       00000140  6e 20 50 72 6f 67 72 61  6d 20 43 20 28 30 78 30  |n Program C (0x0|
         ;       00000150  35 61 30 29 0a 00 20 20  20 20 20 20 20 20 20 20  |5a0)..          |
         ;
         ; Usage:
         ;    lds   r24, low('address_buffer')
         ;    lds   r25, high('address_buffer')
         ;    call  uos_puts
         ; ---------
          uos_puts:
C:003d74 01dc      	movw		REG_X_LSB, REG_TEMP_R24
         
          uos_puts_loop:
C:003d75 910d      	ld			REG_TEMP_R16, X+
C:003d76 3000      	cpi		REG_TEMP_R16, CHAR_NULL		; '\0' terminal ?
C:003d77 f019      	breq		uos_puts_end
         
C:003d78 2e30      	mov		REG_R3, REG_TEMP_R16
C:003d79 dd06      	rcall		uos_uart_fifo_tx_write
         
C:003d7a cffa      	rjmp		uos_puts_loop
         
          uos_puts_end:
         
C:003d7b 9170 0511 	lds		REG_TEMP_R23, UOS_G_FLAGS_1
C:003d7d 6470      	sbr		REG_TEMP_R23, FLG_1_UART_FIFO_TX_TO_SEND_MSK	; Caracteres mis en FIFO a emettre ;-)
C:003d7e 9370 0511 	sts		UOS_G_FLAGS_1, REG_TEMP_R23
         
C:003d80 9508      	ret
         ; ---------
         
         ; ---------
         ; Retourne dans 'REG_Z_MSB:REG_Z_LSB' l'index pour l'affichage de la vitesse en Bauds @ 'UOS_G_HEADER_BAUDS_VALUE'
         ; ---------
          get_index_bauds_rate_value:
         ; ---------
C:003d81 e7ff      	ldi		REG_Z_MSB, high(const_for_bauds_rate_values << 1)
C:003d82 eae2      	ldi		REG_Z_LSB, low(const_for_bauds_rate_values << 1)
         
         	; Longueur du texte defini sur 6 caracteres
         	; +> Multiplication par 6 de l'adresse de base de la table 'const_for_bauds_rate_values'
C:003d83 9100 050d 	lds		REG_TEMP_R16, UOS_G_HEADER_BAUDS_VALUE
C:003d85 2f10      	mov		REG_TEMP_R17, REG_TEMP_R16
C:003d86 0f00      	lsl		REG_TEMP_R16						; REG_TEMP_R16 = (2 * REG_TEMP_R16)
C:003d87 0f01      	add		REG_TEMP_R16, REG_TEMP_R17		; REG_TEMP_R16 = (3 * REG_TEMP_R16)
C:003d88 0f00      	lsl		REG_TEMP_R16						; REG_TEMP_R16 = (6 * UOS_G_HEADER_BAUDS_VALUE)
C:003d89 0fe0      	add		REG_Z_LSB, REG_TEMP_R16
C:003d8a 2700      	clr		REG_TEMP_R16
C:003d8b 1ff0      	adc		REG_Z_MSB, REG_TEMP_R16			; Z = (const_for_bauds_rate_values + 6 * UOS_G_HEADER_BAUDS_VALUE)
         
C:003d8c 9508      	ret
         ; ---------
         
         ; End of file
          ; End of file
          .include		"ATmega328P_uOS_Commands.asm"
         ; "$Id: ATmega328P_uOS_Commands.asm,v 1.12 2026/02/20 16:55:34 administrateur Exp $"
         
          #include "ATmega328P_uOS_Commands.h"
         ; "$Id: ATmega328P_uOS_Commands.h,v 1.2 2026/02/18 18:01:34 administrateur Exp $"
         
          #define	CHAR_COMMAND_REC		'<'
          #define	CHAR_COMMAND_SEND		'>'
          #define	CHAR_COMMAND_MORE		'-'
          #define	CHAR_COMMAND_PLUS		'+'
          #define	CHAR_COMMAND_UNKNOWN	'?'
         
          #define	FLG_TEST_COMMAND_TYPE_MSK				MSK_BIT0
          #define	FLG_TEST_COMMAND_IN_PROGRESS_MSK		MSK_BIT1
          #define	FLG_TEST_COMMAND_MORE_MSK				MSK_BIT2
          #define	FLG_TEST_COMMAND_PLUS_MSK				MSK_BIT3
          #define	FLG_TEST_COMMAND_ERROR_MSK				MSK_BIT4
          #define	FLG_TEST_PROGRAMING_ERROR_MSK			MSK_BIT5
          #define	UOS_FLG_TEST_EEPROM_ERROR_MSK			MSK_BIT6
          #define	FLG_TEST_CONFIG_ERROR_MSK				MSK_BIT7
         
          #define	FLG_TEST_COMMAND_TYPE_IDX				IDX_BIT0
          #define	FLG_TEST_COMMAND_IN_PROGRESS_IDX		IDX_BIT1
          #define	FLG_TEST_COMMAND_MORE_IDX				IDX_BIT2
          #define	FLG_TEST_COMMAND_PLUS_IDX				IDX_BIT3
          #define	FLG_TEST_COMMAND_ERROR_IDX				IDX_BIT4
          #define	FLG_TEST_PROGRAMING_ERROR_IDX			IDX_BIT5
          #define	FLG_TEST_EEPROM_ERROR_IDX				IDX_BIT6
          #define	FLG_TEST_CONFIG_ERROR_IDX				IDX_BIT7
         
          .dseg
         
D:0006c4    UOS_G_TEST_FLAGS:		.byte		1
         
D:0006c5    UOS_G_TEST_COMMAND_TYPE:	.byte		1
D:0006c6    UOS_G_TEST_VALUE_MSB:		.byte		1
D:0006c7    UOS_G_TEST_VALUE_LSB:		.byte		1
D:0006c8    UOS_G_TEST_VALUE_MSB_MORE:	.byte		1
D:0006c9    UOS_G_TEST_VALUE_LSB_MORE:	.byte		1
         
D:0006ca    UOS_G_TEST_VALUE_DEC_MSB:	.byte		1
D:0006cb    UOS_G_TEST_VALUE_DEC_LSB:	.byte		1
         
D:0006cc    UOS_G_TEST_VALUES_IDX_WRK:	.byte		1				; Index sur les valeurs de 'G_TEST_VALUES_ZONE' (travail)
D:0006cd    UOS_G_TEST_VALUES_IDX:		.byte		1				; Index sur les valeurs de 'G_TEST_VALUES_ZONE' (disponible)
D:0006ce    UOS_G_TEST_VALUES_ZONE:		.byte		(2 * 64)		; Page de 64 mots
         
         ; End of file
          ; End of file
         
          .cseg
         
         ; ---------
         ; Interpretation d'une commande "<X"
         ;
         ; Usage:
         ;		 rcall	_uos_interpret_command		; Lecture de la FIFO/Rx
         ;
         ; Registres utilises (sauvegarde/restaures):
         ;    REG_TEMP_R16 -> Caractere a convertir et a ajouter apres x10
         ;    REG_TEMP_R17 -> Working register
         ;    
         ; Warning: Pas de test du 'char' passe en argument dans la plage ['0,', '1', ..., '9']
         ; Remarque: Lecture de la FIFO/Rx jusqu'au vidage
         ;
         ; Retour ajoute a 'UOS_G_TEST_VALUE_MSB:UOS_G_TEST_VALUE_LSB' par decalage et sans raz
         ; => Raz a la charge de l'interpretation de la valeur
         ; ---------
          _uos_interpret_command:
C:003d8d 0000      	nop
         
          _uos_interpret_command_loop:
C:003d8e 94f8      	cli
C:003d8f dcd1      	rcall		_uos_uart_fifo_rx_read			; Lecture atomique
C:003d90 9478      	sei
         
C:003d91 f5de      	brtc		_uos_interpret_command_rtn	; Nouvelle donnee disponible ?
         
C:003d92 9110 06c4 	lds		REG_TEMP_R17, UOS_G_TEST_FLAGS
         
         	; Oui. -> Caractere dans 'REG_R2'
C:003d94 2d02      	mov		REG_TEMP_R16, REG_R2
C:003d95 330c      	cpi		REG_TEMP_R16, CHAR_COMMAND_REC
C:003d96 f421      	brne		_uos_interpret_command_loop_more
         
         	; Le prochain caractere sera le type de la commande
C:003d97 6011      	sbr		REG_TEMP_R17, FLG_TEST_COMMAND_TYPE_MSK
C:003d98 9310 06c4 	sts		UOS_G_TEST_FLAGS, REG_TEMP_R17
C:003d9a cff3      	rjmp		_uos_interpret_command_loop
         
          _uos_interpret_command_loop_more:
C:003d9b 320d      	cpi		REG_TEMP_R16, CHAR_COMMAND_MORE
C:003d9c f421      	brne		_uos_interpret_command_loop_more_2
         
C:003d9d 6014      	sbr		REG_TEMP_R17, FLG_TEST_COMMAND_MORE_MSK
C:003d9e 9310 06c4 	sts		UOS_G_TEST_FLAGS, REG_TEMP_R17
C:003da0 cfed      	rjmp		_uos_interpret_command_loop
         
          _uos_interpret_command_loop_more_2:
C:003da1 320b      	cpi		REG_TEMP_R16, CHAR_COMMAND_PLUS
C:003da2 f441      	brne		_uos_interpret_command_loop_more_2A
         
         	; Effacement de 'UOS_G_TEST_VALUES_ZONE' sur le 1st 'CHAR_COMMAND_PLUS
C:003da3 ff13      	sbrs		REG_TEMP_R17, FLG_TEST_COMMAND_PLUS_IDX
C:003da4 d152      	rcall		_uos_raz_value_into_zone
         
         	; Ajout 'UOS_G_TEST_VALUE_MSB_MORE:UOS_G_TEST_VALUE_LSB_MORE' a 'UOS_G_TEST_VALUES_ZONE'
         	; precedent 'CHAR_COMMAND_PLUS'
C:003da5 fd13      	sbrc		REG_TEMP_R17, FLG_TEST_COMMAND_PLUS_IDX
C:003da6 d164      	rcall		_uos_add_value_into_zone
         
         	; Force maj 'UOS_G_TEST_VALUE_MSB_MORE:UOS_G_TEST_VALUE_LSB_MORE'
C:003da7 601c      	sbr		REG_TEMP_R17, (FLG_TEST_COMMAND_MORE_MSK | FLG_TEST_COMMAND_PLUS_MSK)
C:003da8 9310 06c4 	sts		UOS_G_TEST_FLAGS, REG_TEMP_R17
C:003daa cfe3      	rjmp		_uos_interpret_command_loop
         
          _uos_interpret_command_loop_more_2A:
C:003dab 300a      	cpi		REG_TEMP_R16, CHAR_LF
C:003dac f449      	brne		_uos_interpret_command_loop_more_3
         
         	; Ajout 'UOS_G_TEST_VALUE_MSB_MORE:UOS_G_TEST_VALUE_LSB_MORE' a 'UOS_G_TEST_VALUES_ZONE'
C:003dad fd13      	sbrc		REG_TEMP_R17, FLG_TEST_COMMAND_PLUS_IDX
C:003dae d15c      	rcall		_uos_add_value_into_zone
         
C:003daf d037      	rcall		_uos_exec_command								; Execution de la commande
         
         	; Lancement de l'emission
C:003db0 9170 0511 	lds		REG_TEMP_R23, UOS_G_FLAGS_1
C:003db2 6470      	sbr		REG_TEMP_R23, FLG_1_UART_FIFO_TX_TO_SEND_MSK
C:003db3 9370 0511 	sts		UOS_G_FLAGS_1, REG_TEMP_R23
         
C:003db5 c017      	rjmp		_uos_interpret_command_rtn
         
          _uos_interpret_command_loop_more_3:
C:003db6 ff10      	sbrs		REG_TEMP_R17, FLG_TEST_COMMAND_TYPE_IDX
C:003db7 c013      	rjmp		_uos_interpret_command_loop_more_4
         
C:003db8 9300 06c5 	sts		UOS_G_TEST_COMMAND_TYPE, REG_TEMP_R16	; Save command type
         
         	; Raz des donnees de la commande a recevoir
C:003dba 2700      	clr		REG_TEMP_R16
C:003dbb 9300 06c6 	sts		UOS_G_TEST_VALUE_MSB, REG_TEMP_R16
C:003dbd 9300 06c7 	sts		UOS_G_TEST_VALUE_LSB, REG_TEMP_R16
C:003dbf 9300 06c8 	sts		UOS_G_TEST_VALUE_MSB_MORE, REG_TEMP_R16
C:003dc1 9300 06c9 	sts		UOS_G_TEST_VALUE_LSB_MORE, REG_TEMP_R16
         
C:003dc3 9100 06cc 	lds		REG_TEMP_R16, UOS_G_TEST_VALUES_IDX_WRK
C:003dc5 9300 06cd 	sts		UOS_G_TEST_VALUES_IDX, REG_TEMP_R16
         
         	; Effacement pour prendre la valeur qui suit avec eventuellement des donnees a suivre
C:003dc7 7f12      	cbr		REG_TEMP_R17, (FLG_TEST_COMMAND_TYPE_MSK | FLG_TEST_COMMAND_MORE_MSK | FLG_TEST_COMMAND_PLUS_MSK)
C:003dc8 9310 06c4 	sts		UOS_G_TEST_FLAGS, REG_TEMP_R17
C:003dca cfc3      	rjmp		_uos_interpret_command_loop
         
          _uos_interpret_command_loop_more_4:
C:003dcb d0fe      	rcall		_uos_char_to_hex_incremental		; Construction de 'UOS_G_TEST_VALUE_MSB:UOS_G_TEST_VALUE_LSB'
C:003dcc cfc1      	rjmp		_uos_interpret_command_loop
         
          _uos_interpret_command_rtn:
C:003dcd 9508      	ret
         ; ---------
         
         ; ---------
         ; - Echo de la commande avec ses parametres
         ; ---------
          uos_print_command_ok:
         	; Echo de la commande reconnue avec uniquement l'adresse
         	; => ie. "[34>zA987-4321]"
         	;
C:003dce 9110 06c4 	lds		REG_TEMP_R17, UOS_G_TEST_FLAGS
C:003dd0 7e1f      	cbr		REG_TEMP_R17, FLG_TEST_COMMAND_ERROR_MSK
         
C:003dd1 e30e      	ldi		REG_TEMP_R16, CHAR_COMMAND_SEND
C:003dd2 c004      	rjmp		uos_print_command
         
          uos_print_command_ko:
         	; Echo de la commande non reconnue avec ses parametres
         	; => ie. "34?zA987-4321" si commande non reconnue
         	;
C:003dd3 9110 06c4 	lds		REG_TEMP_R17, UOS_G_TEST_FLAGS
C:003dd5 6110      	sbr		REG_TEMP_R17, FLG_TEST_COMMAND_ERROR_MSK
         
C:003dd6 e30f      	ldi		REG_TEMP_R16, CHAR_COMMAND_UNKNOWN
         
          uos_print_command:
C:003dd7 9310 06c4 	sts		UOS_G_TEST_FLAGS, REG_TEMP_R17				; Maj Flag 'FLG_TEST_COMMAND_ERROR'
         
C:003dd9 df24      	rcall		uos_push_1_char_in_fifo_tx				; '>' eor '?'
         
C:003dda 9100 06c5 	lds		REG_TEMP_R16, UOS_G_TEST_COMMAND_TYPE
C:003ddc df21      	rcall		uos_push_1_char_in_fifo_tx
         
         	; 1st argument sur 16 bits de la commande
C:003ddd 9100 06c6 	lds		REG_TEMP_R16, UOS_G_TEST_VALUE_MSB
C:003ddf df29      	rcall		uos_convert_and_put_fifo_tx
         
C:003de0 9100 06c7 	lds		REG_TEMP_R16, UOS_G_TEST_VALUE_LSB
C:003de2 df26      	rcall		uos_convert_and_put_fifo_tx
         	; Fin: Echo de la commande avec uniquement l'adresse
         
C:003de3 e7ff      	ldi		REG_Z_MSB, ((uos_text_hexa_value_lf_end << 1) / 256)
C:003de4 e9e0      	ldi		REG_Z_LSB, ((uos_text_hexa_value_lf_end << 1) % 256)
C:003de5 df07      	rcall		uos_push_text_in_fifo_tx
         
C:003de6 9508      	ret
         ; ---------
         
         ; ---------
         ; Execution de la commande recue
         ; ---------
          _uos_exec_command:
C:003de7 e50b      	ldi		REG_TEMP_R16, '['
C:003de8 df15      	rcall		uos_push_1_char_in_fifo_tx
         
         	; Comptabilisation et print des executions
C:003de9 9100 0509 	lds		REG_TEMP_R16, G_NBR_VALUE_TRACE
C:003deb 9503      	inc		REG_TEMP_R16
C:003dec 9300 0509 	sts		G_NBR_VALUE_TRACE, REG_TEMP_R16
         
         	; Compteur d'execution commande sur 8 bits
C:003dee 9100 0509 	lds		REG_TEMP_R16, G_NBR_VALUE_TRACE
C:003df0 df18      	rcall		uos_convert_and_put_fifo_tx
         
         	; Fin: Comptabilisation et print des executions
         
         	; Liste des commandes supportees
C:003df1 9100 06c5 	lds		REG_TEMP_R16, UOS_G_TEST_COMMAND_TYPE
         
C:003df3 3402      	cpi		REG_TEMP_R16, 'B'				; [B] (Set Bauds Rate)
C:003df4 b71f      	in			REG_TEMP_R17, SREG
C:003df5 fd11      	sbrc		REG_TEMP_R17, SREG_Z
C:003df6 c085      	rjmp		_uos_exec_command_type_b_maj
         
C:003df7 3700      	cpi		REG_TEMP_R16, 'p'				; [s] (Read from FLASH)
C:003df8 b71f      	in			REG_TEMP_R17, SREG
C:003df9 fd11      	sbrc		REG_TEMP_R17, SREG_Z
C:003dfa c00f      	rjmp		_uos_exec_command_type_p_read
         
C:003dfb 3500      	cpi		REG_TEMP_R16, 'P'				; [P] (Write into FLASH)
C:003dfc b71f      	in			REG_TEMP_R17, SREG
C:003dfd fd11      	sbrc		REG_TEMP_R17, SREG_Z
C:003dfe c02a      	rjmp		_uos_exec_command_type_p_write
         
C:003dff 3703      	cpi		REG_TEMP_R16, 's'				; [s] (Read from SRAM)
C:003e00 b71f      	in			REG_TEMP_R17, SREG	
C:003e01 fd11      	sbrc		REG_TEMP_R17, SREG_Z
C:003e02 c0a3      	rjmp		_uos_exec_command_type_s_min
         
         	; Fin: Liste des commandes supportees
         
          _uos_exec_command_unknown_here:
         	; Commande non reconnue
         	; => Execution de l'extension qui prendrait eventuellement en charge la commande !
         
         	; ---------
         	; Prolongement si le code est execute au RESET depuis l'espace PROGRAM et
         	; si le vecteur commence par l'instruction 'rjmp'
         	; ---------
         	; Init a commande non reconnue ou pas d'execution de l'extension
C:003e03 94e8      	clt
         
C:003e04 e3f8      	ldi		REG_Z_MSB, high(_uos_callback_command)	; Execution si possible de l'extension
C:003e05 e6e0      	ldi		REG_Z_LSB, low(_uos_callback_command)	; dans l'espace PROGRAM
C:003e06 d81b      	rcall		_uos_exec_extension_into_program
         	; ---------
         
C:003e07 f00e      	brts		_uos_exec_command_test_end	; Saut si commande reconnue dans l'espace PROGRAM
         
C:003e08 dfca      	rcall		uos_print_command_ko			; Commande NON reconnue dans les espaces BOOTLOADER et PROGRAM
         
          _uos_exec_command_test_end:
C:003e09 9508      	ret
         ; ---------
         
         ; ---------
         ; Execution de la commande 'p'
         ; => Dump de la memoire programme: "<pAAAA-BBBB" avec:
         ;    - 0xAAAA: l'adresse du 1st word a lire
         ;    - 0xBBBB: le nombre de blocs de 16 bytes
         ;    - La lecture et l'emission sont effectuees 8 bytes par 8 bytes
         ;
         ; Reponse: "[NN>pAAAA-BBBB]"
         ;          "[0xAAAA] [0xd0d1d2d3d4d5d6d7...]" (0xAAAA actualise @ adresse en cours)
         ; ---------
          _uos_exec_command_type_p_read:
C:003e0a dfc3      	rcall		uos_print_command_ok			; Commande reconnue
         
         	; Recuperation de l'adresse du 1st byte a lire
C:003e0b 91b0 06c6 	lds		REG_X_MSB, UOS_G_TEST_VALUE_MSB
C:003e0d 91a0 06c7 	lds		REG_X_LSB, UOS_G_TEST_VALUE_LSB
         
         	; Adresse sur des mots
C:003e0f 0faa      	lsl		REG_X_LSB
C:003e10 1fbb      	rol		REG_X_MSB
         
          #if 0
          #endif
         
C:003e11 e018      	ldi		REG_TEMP_R17, 8
         
          _uos_exec_command_type_p_read_loop_0:
         	; Impression de 'X' ("[0xHHHH] ")
         	; Remarque: Division par 2 car dump de word ;-)
C:003e12 93bf      	push		REG_X_MSB
C:003e13 93af      	push		REG_X_LSB
         
C:003e14 95b6      	lsr		REG_X_MSB
C:003e15 95a7      	ror		REG_X_LSB
C:003e16 df20      	rcall		uos_print_2_bytes_hexa
         
C:003e17 91af      	pop		REG_X_LSB
C:003e18 91bf      	pop		REG_X_MSB
         
         	; Impression du dump ("[0x....]")
C:003e19 e7ff      	ldi		REG_Z_MSB, ((uos_text_hexa_value << 1) / 256)
C:003e1a e8ea      	ldi		REG_Z_LSB, ((uos_text_hexa_value << 1) % 256)
C:003e1b ded1      	rcall		uos_push_text_in_fifo_tx
         
C:003e1c e120      	ldi		REG_TEMP_R18, 16
         
          _uos_exec_command_type_p_read_loop_1:
         	; Valeur de la memoire programme indexee par 'REG_X_MSB:REG_X_LSB'
C:003e1d 01fd      	movw		REG_Z_LSB, REG_X_LSB
C:003e1e 9611      	adiw		REG_X_LSB, 1						; Preparation prochain byte
         
C:003e1f 9104      	lpm		REG_TEMP_R16, Z
C:003e20 dee8      	rcall		uos_convert_and_put_fifo_tx
         
C:003e21 952a      	dec		REG_TEMP_R18
C:003e22 f7d1      	brne		_uos_exec_command_type_p_read_loop_1
         
C:003e23 e7ff      	ldi		REG_Z_MSB, ((uos_text_hexa_value_lf_end << 1) / 256)
C:003e24 e9e0      	ldi		REG_Z_LSB, ((uos_text_hexa_value_lf_end << 1) % 256)
C:003e25 dec7      	rcall		uos_push_text_in_fifo_tx
         
C:003e26 951a      	dec		REG_TEMP_R17
C:003e27 f751      	brne		_uos_exec_command_type_p_read_loop_0
         
C:003e28 9508      	ret
         ; ---------
         
         ; ---------
         ; Execution de la commande 'P'
         ; => Ecriture d'une page dans la memoire programme: "<PAAAA-DDDD..." avec:
         ;    - 0xAAAA:    l'adresse du word a ecrire dans la memoire programme
         ;    - 0xDDDD...: les valeurs des mots a ecrire limite a 64 mots car
         ;                 ecriture d'une page de taille 'PAGESIZE'
         ;
         ; Usages:
         ;   - '_uos_exec_command_type_p_write': 'G_TEST_VALUE': Adresse de 1st opcode a ecrire
         ;     => Le traitement est poursuivi avec 'G_TEST_VALUE'
         ;		   => Si appele avec la commande "<D2", maj de 'G_TEST_VALUE'...
         ;
         ;     => La zone de copie des opcodes est a l'adresse 'UOS_G_TEST_VALUES_ZONE'
         ;		   => Si appele avec la commande "<D2", maj de 'UOS_G_TEST_VALUES_ZONE'...
         ;
         ;     => Affirmer 'FLG_2_ENABLE_DERIVATION' pour autoriser l'ecriture
         ;
         ; Warning: Cette adresse de 1st opcode a ecrire doit etre alignee sur une adresse 64 bytes
         ;
         ; Reponse: "[NN>PAAAA]" (adresse du mot a ecrire)
         ; ---------
          _uos_exec_command_type_p_write:
         	; Recuperation de l'adresse du 1st word a ecrire
C:003e29 91f0 06c6 	lds		REG_Z_MSB, UOS_G_TEST_VALUE_MSB
C:003e2b 91e0 06c7 	lds		REG_Z_LSB, UOS_G_TEST_VALUE_LSB
         
         	; Test de 'REG_Z_MSB:REG_Z_LSB' aligne sur des pages de 64 bytes
C:003e2d 2f0e      	mov		REG_TEMP_R16, REG_Z_LSB
C:003e2e 710f      	andi		REG_TEMP_R16, 0x1F						; TODO: Change 0x1F to 0x3F
C:003e2f f009      	breq		_uos_exec_command_type_p_write_cont_d
         
C:003e30 c03c      	rjmp		_uos_exec_command_type_p_write_invalid_address
         	; Fin: Test de 'REG_Z_MSB:REG_Z_LSB' aligne sur des pages de 64 bytes
         
          _uos_exec_command_type_p_write_cont_d:
         	; Test de 'REG_Z_MSB:REG_Z_LSB' dans la plage [end_of_program + 1, ..., (FLASHEND - 125)]
         	; Test si autorisation d'ecriture avant l'adresse 'end_of_program' pour la derivation de code ;-)
C:003e31 9100 0512 	lds		REG_TEMP_R16, UOS_G_FLAGS_2
C:003e33 fd07      	sbrc		REG_TEMP_R16, UOS_FLG_2_ENABLE_DERIVATION_IDX
C:003e34 c005      	rjmp		_uos_exec_command_type_p_write_bypass
         
C:003e35 ef03      	ldi		REG_TEMP_R16, low(end_of_program + 1)
C:003e36 e31f      	ldi		REG_TEMP_R17, high(end_of_program + 1)
C:003e37 17e0      	cp			REG_Z_LSB, REG_TEMP_R16		
C:003e38 07f1      	cpc		REG_Z_MSB, REG_TEMP_R17		
C:003e39 f19a      	brmi		_uos_exec_command_type_p_write_out_of_range
         
          _uos_exec_command_type_p_write_bypass:
C:003e3a e801      	ldi		REG_TEMP_R16, low(FLASHEND + 2 - 128)		; Place pour une page de 64 mots
C:003e3b e31f      	ldi		REG_TEMP_R17, high(FLASHEND + 2 - 128)
C:003e3c 17e0      	cp			REG_Z_LSB, REG_TEMP_R16		
C:003e3d 07f1      	cpc		REG_Z_MSB, REG_TEMP_R17		
C:003e3e f572      	brpl		_uos_exec_command_type_p_write_out_of_range		; 'X' >= (FLASHEND - 126) = 0x0fe1
         	; Fin: Test de 'REG_Z_MSB:REG_Z_LSB' dans la plage [end_of_program + 1, ..., (FLASHEND - 125)]
         
         	; TODO: Deplacer le retour Ok pour etre parfaitement synchrone des commandes/reponses ;-)
C:003e3f df8e      	rcall		uos_print_command_ok			; Commande reconnue
         
         	; Attente du vidage de la FIFO/Tx avant de continuer
C:003e40 dcb1      	rcall		uos_fifo_tx_to_send_sync
         	; Fin: Attente du vidage de la FIFO/Tx avant de continuer
         
         	; Sequence interruptible
C:003e41 94f8      	cli
         
         	; Reprise de l'adresse du 1st word a ecrire
C:003e42 91f0 06c6 	lds		REG_Z_MSB, UOS_G_TEST_VALUE_MSB
C:003e44 91e0 06c7 	lds		REG_Z_LSB, UOS_G_TEST_VALUE_LSB
         
         	; Adresse sur des mots
C:003e46 0fee      	lsl		REG_Z_LSB
C:003e47 1fff      	rol		REG_Z_MSB
         
         	; Recopie des 64 mots de la SRAM
C:003e48 e0d6      	ldi		REG_Y_MSB, high(UOS_G_TEST_VALUES_ZONE)
C:003e49 ecce      	ldi		REG_Y_LSB, low(UOS_G_TEST_VALUES_ZONE)
         
         	;-the routine writes one page of data from RAM to Flash
         	; the first data location in RAM is pointed to by the Y pointer
         	; the first data location in Flash is pointed to by the Z-pointer
         	;-error handling is not included
         	;-the routine must be placed inside the Boot space
         	; (at least the Do_spm sub routine). Only code inside NRWW section can
         	; be read during Self-Programming (Page Erase and Page Write).
         	;-registers used: r0, r1, temp1 (r16), temp2 (r17), looplo (r24),
         	; loophi (r25), spmcrval (r20)
         	; storing and restoring of registers is not included in the routine
         	; register usage can be optimized at the expense of code size
         	;-It is assumed that either the interrupt table is moved to the Boot
         	; loader section or that the interrupts are disabled.
         
         ;.equ   PAGESIZEB = PAGESIZE*2     ;PAGESIZEB is page size in BYTES, not words
         ;.org SMALLBOOTSTART
         
          _uos_write_page:
         	;Page Erase
C:003e4a e043      	ldi		REG_TEMP_R20, (1<<PGERS) | (1<<SELFPRGEN)
C:003e4b d0e9      	rcall		_uos_do_spm
         
         	;re-enable the RWW section
C:003e4c e141      	ldi		REG_TEMP_R20, (1<<RWWSRE) | (1<<SELFPRGEN)
C:003e4d d0e7      	rcall		_uos_do_spm
         
         	;transfer data from RAM to Flash page buffer
C:003e4e e8a0      	ldi		REG_X_LSB, low(PAGESIZE_BYTES)     ;init loop variable
C:003e4f e0b0      	ldi		REG_X_MSB, high(PAGESIZE_BYTES)    ;not required for PAGESIZE_BYTES<=256
         
          _uos_write_page_loop:
C:003e50 9009      	ld			r0, Y+
C:003e51 9019      	ld			r1, Y+
C:003e52 e041      	ldi		REG_TEMP_R20, (1<<SELFPRGEN)
C:003e53 d0e1      	rcall		_uos_do_spm
         
C:003e54 9632      	adiw		ZH:ZL, 2
C:003e55 9712      	sbiw		REG_X_LSB, 2           ;use subi for PAGESIZE_BYTES<=256
C:003e56 f7c9      	brne		_uos_write_page_loop
         
         	;execute Page Write
C:003e57 58e0      	subi		ZL, low(PAGESIZE_BYTES)         ;restore pointer
C:003e58 40f0      	sbci		ZH, high(PAGESIZE_BYTES)        ;not required for PAGESIZE_BYTES<=256
C:003e59 e045      	ldi		REG_TEMP_R20, (1<<PGWRT) | (1<<SELFPRGEN)
C:003e5a d0da      	rcall		_uos_do_spm
         
         	;re-enable the RWW section
C:003e5b e141      	ldi		REG_TEMP_R20, (1<<RWWSRE) | (1<<SELFPRGEN)
C:003e5c d0d8      	rcall		_uos_do_spm
         
         	;read back and check, optional
C:003e5d e8a0      	ldi		REG_X_LSB, low(PAGESIZE_BYTES)     ;init loop variable
C:003e5e e0b0      	ldi		REG_X_MSB, high(PAGESIZE_BYTES)    ;not required for PAGESIZE_BYTES<=256
C:003e5f 58c0      	subi		YL, low(PAGESIZE_BYTES)         ;restore pointer
C:003e60 40d0      	sbci		YH, high(PAGESIZE_BYTES)
         
          _uos_read_loop:
C:003e61 9005      	lpm		r0, Z+
C:003e62 9019      	ld			r1, Y+
C:003e63 1001      	cpse		r0, r1
C:003e64 c00a      	rjmp		_uos_exec_command_type_p_write_error
         
C:003e65 9711      	sbiw  	 REG_X_LSB, 1           ;use subi for PAGESIZE_BYTES<=256
C:003e66 f7d1      	brne  	 _uos_read_loop
         	;return to RWW section
         	;verify that RWW section is safe to read
         
          _uos_read_rtn:
C:003e67 b707      	in			REG_TEMP_R16, SPMCSR
C:003e68 ff06      	sbrs		REG_TEMP_R16, RWWSB        ; If RWWSB is set, the RWW section is not ready yet
C:003e69 9508      	ret
         
         	;re-enable the RWW section
C:003e6a e141      	ldi		REG_TEMP_R20, (1<<RWWSRE) | (1<<SELFPRGEN)
C:003e6b d0c9      	rcall		_uos_do_spm
C:003e6c cffa      	rjmp		_uos_read_rtn
         
         	; Remarque: Attention, ecriture de la FIFO/Tx dans une sequence interruptible
         	;           => Blocage si remplissage de la FIFO/Tx a 50% qui ne pourra pas se vider ;-)
          _uos_exec_command_type_p_write_invalid_address:
          _uos_exec_command_type_p_write_out_of_range:
C:003e6d 9478      	sei										; Set interrupt flag @ remark
         
C:003e6e df64      	rcall		uos_print_command_ko			; Commande non executee
         
          _uos_exec_command_type_p_write_error:
C:003e6f e7ff      	ldi      REG_Z_MSB, ((_uos_text_flash_error << 1) / 256)
C:003e70 e5e8      	ldi      REG_Z_LSB, ((_uos_text_flash_error << 1) % 256)
C:003e71 de7b      	rcall    uos_push_text_in_fifo_tx
         
C:003e72 01df      	movw		REG_X_LSB, REG_Z_LSB
C:003e73 dec3      	rcall		uos_print_2_bytes_hexa
C:003e74 dea0      	rcall    uos_print_line_feed
         
C:003e75 9100 06c4 	lds		REG_TEMP_R16, UOS_G_TEST_FLAGS
C:003e77 6200      	sbr		REG_TEMP_R16, FLG_TEST_PROGRAMING_ERROR_MSK
C:003e78 9300 06c4 	sts		UOS_G_TEST_FLAGS, REG_TEMP_R16
         	; End: Read back and check the programming
         
          _uos_exec_command_type_p_write_end:
C:003e7a 9478      	sei
         	; Fin: Sequence interruptible
         
C:003e7b 9508      	ret
         ; ---------
         
         ; ---------
         ; Execution de la commande 'B'
         ;
         ; Reprogrammation du Baud Rate
         ; - "<B0": 19200 bauds
         ; - "<B1":  9600 bauds
         ; - "<B2":  4800 bauds
         ; - "<B3":  2400 bauds
         ; - "<B4":  1200 bauds
         ; - "<B5":   600 bauds
         ; - "<B6":   300 bauds
         ; ---------
          _uos_exec_command_type_b_maj:
         	; Recuperation de l'index
         	; Update EEPROM
C:003e7c e0b0      	ldi		REG_X_MSB, (EEPROM_ADDR_BAUDS_IDX / 256)
C:003e7d e0aa      	ldi		REG_X_LSB, (EEPROM_ADDR_BAUDS_IDX % 256)
C:003e7e 9100 06c7 	lds		REG_TEMP_R16, UOS_G_TEST_VALUE_LSB
C:003e80 d884      	rcall		uos_eeprom_write_byte
         	; End: Update EEPROM
         
C:003e81 27bb      	clr		REG_X_MSB
C:003e82 91a0 06c7 	lds		REG_X_LSB, UOS_G_TEST_VALUE_LSB
         
          _uos_set_bauds_rate:
         	; Multiplication par 2 pour acceder a chaque doublets de la table 'const_for_bauds_rate'
         	; => Pas de report dans 'REG_X_MSB' car 7 resultats dans la plage [0, 2, 4, 6, 8, 10 et 12]
C:003e84 0faa      	lsl		REG_X_LSB
         
C:003e85 e7ff      	ldi		REG_Z_MSB, high(const_for_bauds_rate << 1)
C:003e86 ecec      	ldi		REG_Z_LSB, low(const_for_bauds_rate << 1)
C:003e87 0fea      	add		REG_Z_LSB, REG_X_LSB	
C:003e88 1ffb      	adc		REG_Z_MSB, REG_X_MSB	
         
         	; Adresse du dernier doublet cadree sur un mot
C:003e89 ed18      	ldi		REG_TEMP_R17, low((const_for_bauds_rate_end - 1) << 1)
C:003e8a 171e      	cp			REG_TEMP_R17, REG_Z_LSB
C:003e8b e71f      	ldi		REG_TEMP_R17, high((const_for_bauds_rate_end - 1) << 1)
C:003e8c 071f      	cpc		REG_TEMP_R17, REG_Z_MSB
C:003e8d f082      	brmi		_uos_exec_command_type_b_maj_ko	; Z <= 'Adresse du dernier doublet' ?
         
          _uos_exec_command_type_b_maj_ok:					; -> Yes (adresse de copie dans la plage ;-)
         	; Ecriture atomique dans [UBRR0H:UBRR0L]
C:003e8e 94f8      	cli
C:003e8f 9105      	lpm		REG_TEMP_R16, Z+				; LSB value
C:003e90 9114      	lpm		REG_TEMP_R17, Z				; MSB value
         
         	; Ajustement 8/16 MHz @ 'FLG_0_RC_OSC_8MHZ'
C:003e91 9170 0510 	lds		REG_TEMP_R23, UOS_G_FLAGS_0
C:003e93 ff77      	sbrs		REG_TEMP_R23, FLG_0_RC_OSC_8MHZ_IDX
         
C:003e94 c002      	rjmp		_uos_exec_command_type_b_maj_no_rc_osc_8mhz
         
         	; Division par 2 de la valeur a configurer ;-)
C:003e95 9516      	lsr		REG_TEMP_R17
C:003e96 9507      	ror		REG_TEMP_R16
         
         	; Fin: Ajustement 8/16 MHz @ 'FLG_0_RC_OSC_8MHZ'
         
          _uos_exec_command_type_b_maj_no_rc_osc_8mhz:
C:003e97 9310 00c5 	sts		UBRR0H, REG_TEMP_R17
C:003e99 9300 00c4 	sts		UBRR0L, REG_TEMP_R16
C:003e9b 9478      	sei
         	; Fin: Ecriture atomique dans [UBRR0H:UBRR0L]
         
         	; Commande executee
         	; => Pas d'appel a 'uos_print_command_ok' car changement de la vitesse en cours
         	; => TODO: Allumage fugitif de la Led RED ?!..
C:003e9c 9468      	set
C:003e9d 9508      	ret
         
          _uos_exec_command_type_b_maj_ko:				; Commande non executee (index trop grand)
C:003e9e 9508      	ret
         ; ---------
         
         ; ---------
          read_and_set_bauds_rate_from_eeprom:
         	; Lecture de l'index des Bauds
C:003e9f e0b0      	ldi		REG_X_MSB, high(EEPROM_ADDR_BAUDS_IDX);
C:003ea0 e0aa      	ldi		REG_X_LSB, low(EEPROM_ADDR_BAUDS_IDX);
C:003ea1 d08c      	rcall		uos_eeprom_read_byte
         
         	; Maj de 'UBRR0H:UBRR0L' si dans la plage supportee
C:003ea2 27bb      	clr		REG_X_MSB
C:003ea3 2fa0      	mov		REG_X_LSB, REG_TEMP_R16
C:003ea4 dfdf      	rcall		_uos_set_bauds_rate
         
C:003ea5 9508      	ret
         ; ---------
         
         ; ---------
         ; Execution de la commande 's'
         ; => Dump de la SRAM: "<sAAAA-BBBB" avec:
         ;    - 0xAAAA: l'adresse du 1st byte a lire (si 0xAAAA == 0x0000 => Debut en SRAM_START
         ;    - 0xBBBB: le nombre de blocs de 16 bytes
         ;    - La lecture et l'emission sont effectuees 8 bytes par 8 bytes
         ;      avec une limitation des adresses dans la plage [SRAM_START, ..., RAMEND]
         ;
         ; Reponse: "[NN>sAAAA-BBBB]"
         ;          "[0xAAAA] [0xd0d1d2d3d4d5d6d7...]" (0xAAAA actualise @ adresse en cours)
         ; ---------
          _uos_exec_command_type_s_min:
C:003ea6 df27      	rcall		uos_print_command_ok			; Commande reconnue
         
         	; Recuperation de l'adresse du 1st byte a lire
C:003ea7 91b0 06c6 	lds		REG_X_MSB, UOS_G_TEST_VALUE_MSB
C:003ea9 91a0 06c7 	lds		REG_X_LSB, UOS_G_TEST_VALUE_LSB
         
C:003eab 23bb      	tst		REG_X_MSB
C:003eac f431      	brne		_uos_exec_command_type_s_read_cont_d
C:003ead 23aa      	tst		REG_X_LSB
C:003eae f421      	brne		_uos_exec_command_type_s_read_cont_d
         
C:003eaf e0b1      	ldi		REG_X_MSB, (SRAM_START / 256)
C:003eb0 e0a0      	ldi		REG_X_LSB, (SRAM_START % 256)
         
         	; Dump de toute la SRAM
         	; TODO: Calcul @ 'SRAM_START' et 'RAMEND'
C:003eb1 e210      	ldi		REG_TEMP_R17, 32
C:003eb2 c001      	rjmp		_uos_exec_command_type_s_read_loop_0
         
          _uos_exec_command_type_s_read_cont_d:
         	; Dump sur 8 x 16 bytes
         	; TODO: Get 'UOS_G_TEST_VALUE_MSB_MORE:UOS_G_TEST_VALUE_LSB_MORE'
C:003eb3 e018      	ldi		REG_TEMP_R17, 8
         
          _uos_exec_command_type_s_read_loop_0:
         	; Impression de 'X' ("[0xHHHH] ")
C:003eb4 de82      	rcall		uos_print_2_bytes_hexa
         
         	; Impression du dump ("[0x....]")
C:003eb5 e7ff      	ldi		REG_Z_MSB, ((text_hexa_value << 1) / 256)
C:003eb6 edea      	ldi		REG_Z_LSB, ((text_hexa_value << 1) % 256)
C:003eb7 de35      	rcall		uos_push_text_in_fifo_tx
         
C:003eb8 e120      	ldi		REG_TEMP_R18, 16
         
          _uos_exec_command_type_s_read_loop_1:
         	; Valeur de la SRAM indexee par 'REG_X_MSB:REG_X_LSB'
C:003eb9 910d      	ld			REG_TEMP_R16, X+
C:003eba de4e      	rcall		uos_convert_and_put_fifo_tx
         
         	; Test limite 'RAMEND'
         	; => On suppose qu'au depart 'X <= RAMEND'
C:003ebb 30b9      	cpi		REG_X_MSB, ((RAMEND + 1) / 256)
C:003ebc f421      	brne		_uos_exec_command_type_s_read_more2
C:003ebd 30a0      	cpi		REG_X_LSB, ((RAMEND + 1) % 256)
C:003ebe f411      	brne		_uos_exec_command_type_s_read_more2
         
         	; Astuce pour gagner du code de presentation ;-)
C:003ebf e021      	ldi		REG_TEMP_R18, 1
C:003ec0 e011      	ldi		REG_TEMP_R17, 1
         
          _uos_exec_command_type_s_read_more2:
C:003ec1 952a      	dec		REG_TEMP_R18
C:003ec2 f7b1      	brne		_uos_exec_command_type_s_read_loop_1
         
C:003ec3 e7ff      	ldi		REG_Z_MSB, ((text_hexa_value_lf_end << 1) / 256)
C:003ec4 edee      	ldi		REG_Z_LSB, ((text_hexa_value_lf_end << 1) % 256)
C:003ec5 de27      	rcall		uos_push_text_in_fifo_tx
         
C:003ec6 951a      	dec		REG_TEMP_R17
C:003ec7 f761      	brne		_uos_exec_command_type_s_read_loop_0
         
C:003ec8 9468      	set													; Commande reconnue
C:003ec9 9508      	ret
         ; ---------
         
         ; ---------
         ; Conversion ASCII -> Hexa-16 bits
         ;
         ; Usage:
         ;		 rcall	_uos_char_to_hex_incremental	; 'REG_R2' in ['0,', '1', ..., '9', 'A', ..., 'F'
         ;
         ; Registres utilises (sauvegarde/restaures):
         ;    REG_TEMP_R16 -> Caractere a convertir et a ajouter apres x16
         ;    REG_TEMP_R17 -> Working register
         ;    
         ; Warning: Pas de test du 'char' passe en argument dans la plage ['0,', '1', ..., '9', 'A', ..., 'F']
         ;
         ; Retour ajoute a 'UOS_G_TEST_VALUE_MSB:UOS_G_TEST_VALUE_LSB'
         ; ---------
          _uos_char_to_hex_incremental:
C:003eca 930f      	push		REG_TEMP_R16
C:003ecb 931f      	push		REG_TEMP_R17
         
         	; Discrimination...
C:003ecc 9100 06c4 	lds		REG_TEMP_R16, UOS_G_TEST_FLAGS
C:003ece fd02      	sbrc		REG_TEMP_R16, FLG_TEST_COMMAND_MORE_IDX
C:003ecf c005      	rjmp		_uos_char_to_hex_incremental_more
         
C:003ed0 91a0 06c7 	lds		REG_X_LSB, UOS_G_TEST_VALUE_LSB			; Reprise valeur -> X
C:003ed2 91b0 06c6 	lds		REG_X_MSB, UOS_G_TEST_VALUE_MSB
C:003ed4 c004      	rjmp		_uos_char_to_hex_incremental_cont_d
         
          _uos_char_to_hex_incremental_more:
C:003ed5 91a0 06c9 	lds		REG_X_LSB, UOS_G_TEST_VALUE_LSB_MORE		; Reprise valeur -> X
C:003ed7 91b0 06c8 	lds		REG_X_MSB, UOS_G_TEST_VALUE_MSB_MORE
         	; Fin: Discrimination...
         
          _uos_char_to_hex_incremental_cont_d:
C:003ed9 2d02      	mov		REG_TEMP_R16, REG_R2				; Recuperation valeur a concatener
         
         	; REG_TEMP_R17 = 4: 1st pass: X = 2X
         	; REG_TEMP_R17 = 3: 2nd pass: X = 4X
         	; REG_TEMP_R17 = 2: 3rd pass: X = 8X
         	; REG_TEMP_R17 = 1: 4th pass: X = 16X => Fin
         
C:003eda e014      	ldi		REG_TEMP_R17, 4
         
          _uos_char_to_hex_incremental_loop:
C:003edb 0faa      	lsl		REG_X_LSB				; X *= 2
C:003edc 1fbb      	rol		REG_X_MSB
C:003edd 951a      	dec		REG_TEMP_R17
C:003ede f7e1      	brne		_uos_char_to_hex_incremental_loop
         
         	; Conversion ['0', ... , '9'] = [0x30, ... , 0x39] -> [0x0, ..., 0x9]
         	;            ['A', ... , 'F'] = [0x41, ... , 0x46] -> [0xa, ..., 0xf]
         	;            ['a', ... , 'f'] = [0x61, ... , 0x66] -> [0xa, ..., 0xf]
         	;
C:003edf fd06      	sbrc		REG_TEMP_R16, IDX_BIT6			; ['0', ... , '9'] ?
C:003ee0 c002      	rjmp		_uos_char_to_hex_incremental_a_f	; Non
         
          _uos_char_to_hex_incremental_0_9:					; Oui
C:003ee1 5300      	subi		REG_TEMP_R16, '0'
C:003ee2 c002      	rjmp		_uos_char_to_hex_incremental_add
         
          _uos_char_to_hex_incremental_a_f:
C:003ee3 7d0f      	cbr		REG_TEMP_R16, MSK_BIT5			; Lowercase -> Uppercase ('a' (0x61) -> 'A' (0x41))
C:003ee4 5307      	subi		REG_TEMP_R16, ('A' - 0xa)		; 'A' -> 0xa, ..., 'F' -> 0xf
         
          _uos_char_to_hex_incremental_add:
C:003ee5 700f      	andi		REG_TEMP_R16, 0x0f				; Filtre Bits<3,0> (precaution ;-)
C:003ee6 2ba0      	or			REG_X_LSB, REG_TEMP_R16			; X |= REG_TEMP_R16
         
         	; Discrimination...
C:003ee7 9100 06c4 	lds		REG_TEMP_R16, UOS_G_TEST_FLAGS
C:003ee9 fd02      	sbrc		REG_TEMP_R16, FLG_TEST_COMMAND_MORE_IDX
C:003eea c005      	rjmp		_uos_char_to_hex_incremental_more_2
         
C:003eeb 93a0 06c7 	sts		UOS_G_TEST_VALUE_LSB, REG_X_LSB
C:003eed 93b0 06c6 	sts		UOS_G_TEST_VALUE_MSB, REG_X_MSB
C:003eef c004      	rjmp		_uos_char_to_hex_incremental_end
         
          _uos_char_to_hex_incremental_more_2:
C:003ef0 93a0 06c9 	sts		UOS_G_TEST_VALUE_LSB_MORE, REG_X_LSB
C:003ef2 93b0 06c8 	sts		UOS_G_TEST_VALUE_MSB_MORE, REG_X_MSB
         	; Fin: Discrimination...
         
          _uos_char_to_hex_incremental_end:
         
C:003ef4 911f      	pop		REG_TEMP_R17
C:003ef5 910f      	pop		REG_TEMP_R16
C:003ef6 9508      	ret
         ; ---------
         
         ; ---------
         ; Raz de 'UOS_G_TEST_VALUES_ZONE'
         ; ---------
          _uos_raz_value_into_zone:
C:003ef7 93df      	push		REG_Y_MSB
C:003ef8 93cf      	push		REG_Y_LSB
C:003ef9 930f      	push		REG_TEMP_R16
C:003efa 931f      	push		REG_TEMP_R17
         
C:003efb 2700      	clr		REG_TEMP_R16
C:003efc 9300 06cc 	sts		UOS_G_TEST_VALUES_IDX_WRK, REG_TEMP_R16
         
C:003efe e0d6      	ldi		REG_Y_MSB, high(UOS_G_TEST_VALUES_ZONE)
C:003eff ecce      	ldi		REG_Y_LSB, low(UOS_G_TEST_VALUES_ZONE)
         
C:003f00 e400      	ldi		REG_TEMP_R16, 64
C:003f01 2711      	clr		REG_TEMP_R17
         
          _uos_raz_value_into_zone_loop:
C:003f02 9319      	st			Y+, REG_TEMP_R17
C:003f03 9319      	st			Y+, REG_TEMP_R17
         
C:003f04 950a      	dec		REG_TEMP_R16
C:003f05 f7e1      	brne		_uos_raz_value_into_zone_loop
         
C:003f06 911f      	pop		REG_TEMP_R17
C:003f07 910f      	pop		REG_TEMP_R16
C:003f08 91cf      	pop		REG_Y_LSB
C:003f09 91df      	pop		REG_Y_MSB
         
C:003f0a 9508      	ret
         ; ---------
         
         ; Recopie de 'UOS_G_TEST_VALUE_MSB_MORE:UOS_G_TEST_VALUE_LSB_MORE' a 'UOS_G_TEST_VALUES_ZONE'
         ; ---------
          _uos_add_value_into_zone:
C:003f0b 93bf      	push		REG_X_MSB
C:003f0c 93af      	push		REG_X_LSB
C:003f0d 93df      	push		REG_Y_MSB
C:003f0e 93cf      	push		REG_Y_LSB
C:003f0f 930f      	push		REG_TEMP_R16
C:003f10 931f      	push		REG_TEMP_R17
         
C:003f11 9100 06cc 	lds		REG_TEMP_R16, UOS_G_TEST_VALUES_IDX_WRK
C:003f13 e0d6      	ldi		REG_Y_MSB, high(UOS_G_TEST_VALUES_ZONE)
C:003f14 ecce      	ldi		REG_Y_LSB, low(UOS_G_TEST_VALUES_ZONE)
C:003f15 2711      	clr		REG_TEMP_R17
C:003f16 0fc0      	add		REG_Y_LSB, REG_TEMP_R16
C:003f17 1fd1      	adc		REG_Y_MSB, REG_TEMP_R17
         
C:003f18 91b0 06c8 	lds		REG_X_MSB, UOS_G_TEST_VALUE_MSB_MORE
C:003f1a 91a0 06c9 	lds		REG_X_LSB, UOS_G_TEST_VALUE_LSB_MORE
         
C:003f1c 83a8      	std		Y+0, REG_X_LSB			; LSB en tete
C:003f1d 83b9      	std		Y+1, REG_X_MSB
         
C:003f1e 9503      	inc		REG_TEMP_R16			; Next word
C:003f1f 9503      	inc		REG_TEMP_R16
C:003f20 9300 06cc 	sts		UOS_G_TEST_VALUES_IDX_WRK, REG_TEMP_R16
         
         	; Raz donnee
C:003f22 2700      	clr		REG_TEMP_R16
C:003f23 9300 06c8 	sts		UOS_G_TEST_VALUE_MSB_MORE, REG_TEMP_R16
C:003f25 9300 06c9 	sts		UOS_G_TEST_VALUE_LSB_MORE, REG_TEMP_R16
         
C:003f27 911f      	pop		REG_TEMP_R17
C:003f28 910f      	pop		REG_TEMP_R16
C:003f29 91cf      	pop		REG_Y_LSB
C:003f2a 91df      	pop		REG_Y_MSB
C:003f2b 91af      	pop		REG_X_LSB
C:003f2c 91bf      	pop		REG_X_MSB
         
C:003f2d 9508      	ret
         ; ---------
         
         ; ---------
         ; Lecture d'un byte de l'EEPROM a l'adresse 'REG_X_MSB:REG_X_LSB'
         ; => Valeur retournee dans 'REG_TEMP_R16'
         ; ---------
          uos_eeprom_read_byte:
         	; Set address
C:003f2e bda1      	out		EEARL, REG_X_LSB
C:003f2f bdb2      	out		EEARH, REG_X_MSB
         
         	; Lecture a l'adresse 'REG_X_MSB:REG_X_LSB'
          _uos_eeprom_read_byte_wait:
C:003f30 99f9      	sbic		EECR, EEPE
C:003f31 cffe      	rjmp		_uos_eeprom_read_byte_wait
         
C:003f32 9af8      	sbi		EECR, EERE
C:003f33 b500      	in			REG_TEMP_R16, EEDR
         	; Fin: Lecture a l'adresse 'REG_X_MSB:REG_X_LSB'
         
C:003f34 9508      	ret
         ; ---------
         
         ; ---------
          _uos_do_spm:
         
         	; Awaiting the previous SPM complete
          _uos_wait_spm:
C:003f35 b707      	in			REG_TEMP_R16, SPMCSR
C:003f36 fd00      	sbrc		REG_TEMP_R16, SELFPRGEN
C:003f37 cffd      	rjmp		_uos_wait_spm
         	; End: Awaiting the previous SPM complete
         
         	; Input: REG_TEMP_R20 determines SPM action
         	;        => Disable interrupts if enabled, save status in 'REG_TEMP_R17'
C:003f38 b71f      	in			REG_TEMP_R17, SREG
C:003f39 94f8      	cli
         
          _uos_wait_ee:
C:003f3a 99f9      	sbic		EECR, EEPE
C:003f3b cffe      	rjmp		_uos_wait_ee
         
         	; SPM timed sequence
C:003f3c bf47      	out		SPMCSR, REG_TEMP_R20
C:003f3d 95e8      	spm
         
         	; Restore SREG (to enable interrupts if originally enabled)
C:003f3e bf1f      	out		SREG, REG_TEMP_R17	; Restore 'SREG' from 'REG_TEMP_R17'
C:003f3f 9508      	ret
         ; ---------
         
         ; End of file
          ; End of file
         ; Fin: Fonctionnalites dans un fichier a part
         
         ; ---------
          .dseg
         
         ; Fin des variables propres au BOOTLOADER
         ; => 'G_FLAGS_EXTENSIONS' appartient au BOOTLOADER dans la mesure ou 'UOS_G_FLAGS_EXTENSIONS'
         ;    doit etre initialise a 0x00 pour poursuivre l'initialisation des extensions
         ; => IMPORTANT: Ne pas definir de section '.dseg' apres celle-ci ;-)
         ;
D:00074e    UOS_G_SRAM_BOOTLOADER_END_OF_USE:	.byte		1		; Initialisee a 0xff pour reperage dans la SRAM
         ; ---------
         
          .cseg
         
         ; ---------
         ; Derniere instruction du programme
         ; ---------
C:003f40 940c 35e8 	jmp		_uos_forever	; Ne sera jamais execute
         
          .dw	CHAR_SEPARATOR			; Debut section datas		; NE PAS SUPPRIMER ;-)
C:003f42 ffff
         
          _uos_text_prompt:
         ; Warning: Passage de la Rev: sur x.yz
          .db	"### ATmega328p $Revision: 1.22 $", CHAR_LF, CHAR_NULL
C:003F43 2323232041546D6567613332387020245265766973696F6E3A20312E323220240A00
         
          .include		"ATmega328P_uOS.txt"
         ; "$Id: ATmega328P_uOS.txt,v 1.1 2026/02/18 18:01:34 administrateur Exp $"
         
         ; ---------
         ; Constantes et textes definis naturellement (MSB:LSB et ordre naturel du texte)
         ; => Remarque: Nombre pair de caracteres pour eviter le message:
         ;              "Warning : A .DB segment with an odd number..."
         
         ; Prompt lorsque le RESET est fait dans l'espace PROGRAMME
          _uos_text_program:
          .db	"### Hello World !..", CHAR_LF, CHAR_NULL, CHAR_NULL
C:003F54 2323232048656C6C6F20576F726C6420212E2E0A0000
         
         ; Prompt lorsque le RESET est fait dans l'espace BOOTLOADER
          _uos_text_bootloader:
          .db	"### Micro OS !..", CHAR_LF, CHAR_NULL
C:003F5F 232323204D6963726F204F5320212E2E0A00
         
          _uos_text_frequency_8_mhz:
          .db	"### 8 MHz", CHAR_LF, CHAR_NULL, CHAR_NULL
C:003F68 2323232038204D487A0A0000
         
          _uos_text_frequency_16_mhz:
          .db	"### 16 MHz", CHAR_LF, CHAR_NULL
C:003F6E 232323203136204D487A0A00
         
          _uos_text_prompt_eeprom_version:
          .db	"### EEPROM: ", CHAR_NULL, CHAR_NULL
C:003F74 23232320454550524F4D3A200000
         
          _uos_text_prompt_type:
          .db	"### Type: ", CHAR_NULL, CHAR_NULL
C:003F7B 23232320547970653A200000
         
          _uos_text_prompt_id:
          .db	"### Id: ", CHAR_NULL, CHAR_NULL
C:003F81 2323232049643A200000
         
          _uos_text_prompt_bauds_value:
          .db	"### Bauds: ", CHAR_NULL
C:003F86 2323232042617564733A2000
         
          _uos_text_press_button_short:
          .db	"### Press button short ", CHAR_NULL
C:003F8C 23232320507265737320627574746F6E2073686F72742000
         
          _uos_text_press_button_long:
          .db	"### Press button long ", CHAR_NULL, CHAR_NULL
C:003F98 23232320507265737320627574746F6E206C6F6E67200000
         
          _uos_text_convert_hex_to_min_ascii_table:
          .db	"0123456789abcdef"
C:003FA4 30313233343536373839616263646566
         
          _uos_text_flash_error:
          .db	"Err: FLASH at ", CHAR_NULL, CHAR_NULL
C:003FAC 4572723A20464C415348206174200000
         
          uos_text_eeprom_error:
          .db	"Err: EEPROM at ", CHAR_NULL
C:003FB4 4572723A20454550524F4D2061742000
         
          _uos_text_it_error:
          .db	"Err: Invalid It ", CHAR_NULL, CHAR_NULL
C:003FBC 4572723A20496E76616C6964204974200000
         
          uos_text_hexa_value:
          .db	"[0x", CHAR_NULL
C:003FC5 5B307800
         
          _uos_text_hexa_value_end:
          .db	"]", CHAR_NULL
C:003FC7 5D00
         
          uos_text_hexa_value_lf_end:
          .db	"]", CHAR_LF, CHAR_NULL, CHAR_NULL
C:003FC8 5D0A0000
         
          _uos_text_line_feed:
          .db	CHAR_LF, CHAR_NULL
C:003FCA 0A00
         
         ; Fin: Constantes et textes definis naturellement (MSB:LSB et ordre naturel du texte)
         
         ; End of file
          ; End of file
          .include		"ATmega328P_uOS_Misc.txt"
         ; "$Id: ATmega328P_uOS_Misc.txt,v 1.1 2026/02/18 18:01:34 administrateur Exp $"
         
          mask_for_test_leds:
          #define MASK_LEDS		(UOS_MSK_BIT_LED_BLUE | UOS_MSK_BIT_LED_RED | UOS_MSK_BIT_LED_GREEN | UOS_MSK_BIT_LED_YELLOw)
         
         ; Allumage/Extinction 1/0
         ; => Correspond aux masques d'allumage des Leds de 'UOS_G_PORTB_IMAGE'
         		; Allumage des 4 Leds BLUE, RED, GREEN et YELLOW suivi de ...
         		; Extinction de la Led BLUE et Allumage des 3 Leds RED, GREEN et YELLOW
          .db	FLG_GESTION_TEST_LEDS_MSK   | ~(MASK_LEDS) & MASK_LEDS, 		FLG_GESTION_TEST_LEDS_MSK   | ~(UOS_MSK_BIT_LED_RED | UOS_MSK_BIT_LED_GREEN | UOS_MSK_BIT_LED_YELLOW) & MASK_LEDS
C:003FCB 8090
         
         		; Extinction de la Led RED et Allumage des 2 Leds GREEN et YELLOW suivi de ...
         		; Extinction de la Led GREEN et Allumage de la Led YELLOW
          .db	FLG_GESTION_TEST_LEDS_MSK   | ~(UOS_MSK_BIT_LED_GREEN | UOS_MSK_BIT_LED_YELLOW) & MASK_LEDS, 		FLG_GESTION_TEST_LEDS_MSK   | ~(UOS_MSK_BIT_LED_YELLOW) & MASK_LEDS
C:003FCC 9296
         
         		; Extinction des 4 Leds BLUE, RED, GREEN et YELLOW suivi de ...
         		; Allumage de la Led BLUE et Extinction des 3 Leds RED, GREEN et YELLOW
          .db	FLG_GESTION_TEST_LEDS_MSK   | MASK_LEDS, 		FLG_GESTION_TEST_LEDS_MSK   | ~(UOS_MSK_BIT_LED_BLUE) & MASK_LEDS
C:003FCD B6A6
         
         		; Allumage de la Led RED et Extinction des 3 Leds BLUE, GREEN et YELLOW		 suivi de ...
         		; Allumage de la Led GREEN et Extinction des 3 Leds BLUE, RED et YELLOW
          .db	FLG_GESTION_TEST_LEDS_MSK   | ~(UOS_MSK_BIT_LED_RED) & MASK_LEDS, 		FLG_GESTION_TEST_LEDS_MSK   | ~(UOS_MSK_BIT_LED_GREEN) & MASK_LEDS
C:003FCE B4B2
         
         		; Allumage de la Led YELLOW et Extinction des 3 Leds BLUE, RED et GREEN suivi de ...
         		; Extinction des 4 Leds BLUE, RED, GREEN et YELLOW	
          .db	FLG_GESTION_TEST_LEDS_MSK   | ~(UOS_MSK_BIT_LED_YELLOW) & MASK_LEDS, 		FLG_GESTION_TEST_LEDS_MSK   | MASK_LEDS
C:003FCF 96B6
         
         		; Fin du test et Etat des 4 Leds BLUE, RED, GREEN et YELLOW inchange
          .db	(~FLG_GESTION_TEST_LEDS_MSK | MASK_LEDS) & MASK_LEDS, 0
C:003FD0 3600
         
         ; End of file
         
          
          .include		"ATmega328P_uOS_Print.txt"
         ; "$Id: ATmega328P_uOS_Print.txt,v 1.1 2026/02/18 18:01:34 administrateur Exp $"
         
         ; Textes d'affichage de la vitesse en Bauds @ 'UOS_G_HEADER_BAUDS_VALUE'
          const_for_bauds_rate_values:
          .db	"19200", CHAR_NULL	; #0: 19200 bauds
C:003FD1 313932303000
          .db	" 9600", CHAR_NULL	; #1:  9600 bauds
C:003FD4 203936303000
          .db	" 4800", CHAR_NULL	; #2:  4800 bauds
C:003FD7 203438303000
          .db	" 2400", CHAR_NULL	; #3:  2400 bauds
C:003FDA 203234303000
          .db	" 1200", CHAR_NULL	; #4:  1200 bauds
C:003FDD 203132303000
          .db	"  600", CHAR_NULL	; #5:   600 bauds
C:003FE0 202036303000
          .db	"  300", CHAR_NULL	; #6:   300 bauds
C:003FE3 202033303000
         
         ; End of file
         
          
          .include		"ATmega328P_uOS_Commands.txt"
         ; "$Id: ATmega328P_uOS_Commands.txt,v 1.1 2026/02/18 18:01:34 administrateur Exp $"
         
          const_for_bauds_rate:
         ; Durees en uS d'un bit a 16 MHz sur UART/Tx et UART/Rx
         ; => Division par 2 pour 8 MHz dans le cas du RC Osc interne (cf. 'init_hard')
          .dw	  52				; #0: 19200 bauds
C:003fe6 0034
          .dw	 104				; #1:  9600 bauds
C:003fe7 0068
          .dw	 208				; #2:  4800 bauds
C:003fe8 00d0
          .dw	 416				; #3:  2400 bauds
C:003fe9 01a0
          .dw	 832				; #4:  1200 bauds
C:003fea 0340
          .dw	1664				; #5:   600 bauds
C:003feb 0680
          .dw	3328				; #6:   300 bauds
C:003fec 0d00
          const_for_bauds_rate_end:
         
          text_hexa_value:
          .db	"[0x", CHAR_NULL
C:003FED 5B307800
            
          text_hexa_value_lf_end:
          .db	"]", CHAR_LF, CHAR_NULL, CHAR_NULL
C:003FEF 5D0A0000
         
         ; End of file
         
          
         
          _uos_magic_const:
          .dw	0x1234
C:003ff1 1234
         
          end_of_program:
         
         ; End of file
         
Used memory blocks:
   code      :  Start = 0x0000, End = 0x007F, Length = 0x0080 (128 words), Overlap=N
   code      :  Start = 0x3580, End = 0x37FF, Length = 0x0280 (640 words), Overlap=N
   code      :  Start = 0x3800, End = 0x3910, Length = 0x0111 (273 words), Overlap=N
   code      :  Start = 0x3911, End = 0x3A3E, Length = 0x012E (302 words), Overlap=N
   code      :  Start = 0x3A3F, End = 0x3B12, Length = 0x00D4 (212 words), Overlap=N
   code      :  Start = 0x3B13, End = 0x3CB1, Length = 0x019F (415 words), Overlap=N
   code      :  Start = 0x3CB2, End = 0x3D8C, Length = 0x00DB (219 words), Overlap=N
   code      :  Start = 0x3D8D, End = 0x3F3F, Length = 0x01B3 (435 words), Overlap=N
   code      :  Start = 0x3F40, End = 0x3FF1, Length = 0x00B2 (178 words), Overlap=N
   data      :  Start = 0x0100, End = 0x0534, Length = 0x0435 (1077 bytes), Overlap=N
   data      :  Start = 0x0535, End = 0x0574, Length = 0x0040 (64 bytes), Overlap=N
   data      :  Start = 0x0575, End = 0x06BB, Length = 0x0147 (327 bytes), Overlap=N
   data      :  Start = 0x06BC, End = 0x06C3, Length = 0x0008 (8 bytes), Overlap=N
   data      :  Start = 0x06C4, End = 0x074D, Length = 0x008A (138 bytes), Overlap=N
   data      :  Start = 0x074E, End = 0x074E, Length = 0x0001 (1 byte), Overlap=N


Segment usage:
   Code      :      2802 words (5604 bytes)
   Data      :      1615 bytes
   EEPROM    :         0 bytes

Assembly completed with no errors.
